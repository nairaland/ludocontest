<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Ludo Game by Stephen0mozzy</title>

    <!-- Link ThreeJS via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Internal CSS Styles -->
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        /* Use background image with a subtle black overlay for contrast */
        background-image: linear-gradient(
            rgba(0, 0, 0, 0.6),
            rgba(0, 0, 0, 0.6)
          ),
          url("https://res.cloudinary.com/dg0qc5gkl/image/upload/v1765992967/Nairaland-Competition/game_background_img_shfyzk.webp");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      #gameContainer {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
        display: none;
      }

      #gameContainer.active {
        display: block;
      }

      #gameContainer .storm-container {
        z-index: 0;
      }

      #canvas {
        display: block;
        position: relative;
        z-index: 1;
        touch-action: none;
      }

      /* UI Overlay */
      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 2;
      }

      #ui-overlay > * {
        pointer-events: auto;
      }

      /* Header */
      #header {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      #header h1 {
        font-size: 2.5rem;
        background: linear-gradient(45deg, #f39c12, #e74c3c, #9b59b6, #3498db);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      /* Player Info Panel */
      #player-panel {
        position: absolute;
        top: 80px;
        right: 10px;
        background: rgba(0, 0, 0, 0.75);
        border-radius: 12px;
        padding: 12px 15px;
        color: white;
        min-width: 160px;
        max-width: 180px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 0.9rem;
      }

      .player-info {
        display: flex;
        align-items: center;
        margin: 10px 0;
        padding: 10px;
        border-radius: 8px;
        transition: all 0.3s ease;
      }

      .player-info.active {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }

      .player-color {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        margin-right: 15px;
        box-shadow: 0 0 10px currentColor;
      }

      .player-name {
        font-weight: bold;
        flex: 1;
      }

      .player-home {
        font-size: 0.9rem;
        opacity: 0.8;
      }

      /* Dice Container */
      #dice-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        text-align: center;
      }

      #dice-display {
        font-size: 3.5rem;
        color: white;
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        margin-bottom: 10px;
        min-height: 60px;
      }

      #roll-btn {
        padding: 12px 35px;
        font-size: 1.1rem;
        font-weight: bold;
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        border: none;
        border-radius: 25px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 20px rgba(243, 156, 18, 0.4);
      }

      #roll-btn:hover:not(:disabled) {
        transform: translateY(-3px);
        box-shadow: 0 8px 30px rgba(243, 156, 18, 0.6);
      }

      #roll-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Game Message */
      #game-message {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 0.95rem;
        text-align: center;
        max-width: 280px;
        backdrop-filter: blur(10px);
      }

      /* Control Buttons */
      #control-buttons {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
      }

      .control-btn {
        padding: 10px 20px;
        font-size: 1rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 20px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      /* Modal Styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 3000;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
      }

      .modal.show {
        display: flex;
      }

      .modal-content {
        background: linear-gradient(135deg, #2c3e50 0%, #1a1a2e 100%);
        border-radius: 20px;
        padding: 40px 50px;
        width: 90%;
        max-width: 800px;
        max-height: 85vh;
        overflow-y: auto;
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      .modal-content h2 {
        font-size: 2rem;
        margin-bottom: 20px;
        text-align: center;
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .modal-content h3 {
        font-size: 1.3rem;
        margin: 20px 0 10px;
        color: #f39c12;
      }

      .modal-content p,
      .modal-content li {
        line-height: 1.8;
        margin-bottom: 10px;
      }

      .modal-content ul {
        padding-left: 25px;
      }

      .close-modal {
        display: block;
        margin: 30px auto 0;
        padding: 12px 40px;
        font-size: 1.1rem;
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        border: none;
        border-radius: 25px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .close-modal:hover {
        transform: scale(1.05);
      }

      /* Start Screen */
      #start-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        background: url("https://res.cloudinary.com/dg0qc5gkl/image/upload/v1765992966/Nairaland-Competition/start_screen_img_epbhcs.webp");
        background-color: rgba(0, 0, 0, 0.632);
        background-size: cover;
        background-position: center center;
        background-repeat: no-repeat;
        background-blend-mode: multiply;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        overflow: hidden;
      }

      #start-screen .storm-container {
        z-index: 0;
      }

      #start-screen > *:not(.storm-container) {
        position: relative;
        z-index: 3;
      }

      #start-screen h1 {
        font-size: 4rem;
        margin-bottom: 20px;
        background: linear-gradient(45deg, #dc2626, #16a34a, #eab308, #2563eb);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-align: center;
      }

      #start-screen p {
        font-size: 1.3rem;
        margin-bottom: 15px;
        opacity: 0.8;
      }

      .player-select {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
      }

      .player-count-btn {
        padding: 12px 30px;
        font-size: 1.3rem;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .player-count-btn:hover,
      .player-count-btn.selected {
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        border-color: transparent;
        transform: scale(1.1);
      }

      /* Game Mode Selection */
      .game-mode-select {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .game-mode-btn {
        padding: 10px 20px;
        font-size: 1rem;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3px;
      }

      .game-mode-btn:hover,
      .game-mode-btn.selected {
        background: linear-gradient(45deg, #9b59b6, #3498db);
        border-color: transparent;
        transform: scale(1.05);
      }

      .game-mode-btn .mode-icon {
        font-size: 1.3rem;
      }

      .game-mode-btn .mode-label {
        font-size: 0.8rem;
        opacity: 0.9;
      }

      #start-game-btn {
        padding: 14px 50px;
        font-size: 1.3rem;
        font-weight: bold;
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border: none;
        border-radius: 30px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 30px rgba(39, 174, 96, 0.4);
      }

      #start-game-btn:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 40px rgba(39, 174, 96, 0.6);
      }

      /* Winner Screen */
      #winner-screen {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 3000;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      #winner-screen.show {
        display: flex;
      }

      #winner-screen h1 {
        font-size: 4rem;
        margin-bottom: 20px;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      /* Smoke Effect */
      @keyframes smokeFlow1 {
        0% {
          transform: translateX(-30%) translateY(0) scale(1.2) skewX(-5deg);
          opacity: 0.1;
        }
        25% {
          transform: translateX(-10%) translateY(-10%) scale(1.4) skewX(3deg);
          opacity: 0.34;
        }
        50% {
          transform: translateX(20%) translateY(-5%) scale(1.3) skewX(-2deg);
          opacity: 0.2;
        }
        75% {
          transform: translateX(35%) translateY(5%) scale(1.5) skewX(4deg);
          opacity: 0.1;
        }
        100% {
          transform: translateX(-30%) translateY(0) scale(1.2) skewX(-5deg);
          opacity: 0.2;
        }
      }

      @keyframes smokeFlow2 {
        0% {
          transform: translateX(40%) translateY(10%) scale(1.3) skewX(5deg);
          opacity: 0.25;
        }
        33% {
          transform: translateX(10%) translateY(-8%) scale(1.5) skewX(-3deg);
          opacity: 0.35;
        }
        66% {
          transform: translateX(-25%) translateY(5%) scale(1.2) skewX(2deg);
          opacity: 0.15;
        }
        100% {
          transform: translateX(40%) translateY(10%) scale(1.3) skewX(5deg);
          opacity: 0.35;
        }
      }

      @keyframes smokeFlow3 {
        0% {
          transform: translateX(0) translateY(-15%) scale(1.4) skewX(-3deg);
          opacity: 0.15;
        }
        25% {
          transform: translateX(-20%) translateY(8%) scale(1.6) skewX(4deg);
          opacity: 0.27;
        }
        50% {
          transform: translateX(15%) translateY(-3%) scale(1.3) skewX(-2deg);
          opacity: 0.26;
        }
        75% {
          transform: translateX(30%) translateY(12%) scale(1.5) skewX(3deg);
          opacity: 0.05;
        }
        100% {
          transform: translateX(0) translateY(-15%) scale(1.4) skewX(-3deg);
          opacity: 0.15;
        }
      }

      /* Rain keyframes moved to cssRain above */

      @keyframes lightning {
        0%,
        89%,
        91%,
        93%,
        95%,
        100% {
          opacity: 0;
        }
        90%,
        92%,
        94% {
          opacity: 1;
        }
      }

      @keyframes thunderFlash {
        0%,
        100% {
          background: transparent;
        }
        50% {
          background: rgba(255, 255, 255, 0.3);
        }
      }

      .storm-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        pointer-events: none;
        z-index: 1;
      }

      .smoke-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        pointer-events: none;
      }

      .smoke-layer {
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        filter: blur(50px);
      }

      .smoke-layer-1 {
        animation: smokeFlow1 4s ease-in-out infinite;
        background: radial-gradient(
            ellipse at 30% 50%,
            rgba(150, 150, 160, 0.4) 0%,
            transparent 60%
          ),
          radial-gradient(
            ellipse at 70% 30%,
            rgba(130, 130, 140, 0.35) 0%,
            transparent 55%
          );
      }

      .smoke-layer-2 {
        animation: smokeFlow2 5s ease-in-out infinite;
        animation-delay: -1.5s;
        background: radial-gradient(
            ellipse at 60% 60%,
            rgba(140, 140, 150, 0.4) 0%,
            transparent 55%
          ),
          radial-gradient(
            ellipse at 20% 40%,
            rgba(160, 160, 170, 0.35) 0%,
            transparent 50%
          );
      }

      .smoke-layer-3 {
        animation: smokeFlow3 6s ease-in-out infinite;
        animation-delay: -3s;
        background: radial-gradient(
            ellipse at 40% 30%,
            rgba(155, 155, 165, 0.4) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 70% 70%,
            rgba(145, 145, 155, 0.35) 0%,
            transparent 55%
          );
      }

      /* Lightning Flash */
      .lightning-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 2;
      }

      .lightning-flash {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0);
        animation: lightning 8s infinite;
      }

      .lightning-flash:nth-child(2) {
        animation-delay: 3s;
      }

      .lightning-flash:nth-child(3) {
        animation-delay: 6s;
      }

      .lightning-bolt {
        position: absolute;
        width: 3px;
        height: 200px;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.9),
          rgba(200, 200, 255, 0.7),
          transparent
        );
        filter: blur(1px);
        opacity: 0;
        animation: lightning 10s infinite;
        transform: rotate(15deg);
      }

      .lightning-bolt::before {
        content: "";
        position: absolute;
        top: 80px;
        left: -30px;
        width: 3px;
        height: 120px;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.8),
          rgba(200, 200, 255, 0.6),
          transparent
        );
        transform: rotate(-30deg);
      }

      .lightning-bolt:nth-child(4) {
        left: 20%;
        animation-delay: 0s;
      }

      .lightning-bolt:nth-child(5) {
        left: 70%;
        animation-delay: 4s;
        transform: rotate(-10deg);
      }

      .lightning-bolt:nth-child(6) {
        left: 45%;
        animation-delay: 7s;
        transform: rotate(5deg);
      }

      #winner-screen p {
        font-size: 1.5rem;
        color: white;
        margin-bottom: 40px;
      }

      #play-again-btn {
        padding: 15px 50px;
        font-size: 1.3rem;
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        border: none;
        border-radius: 25px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      /* Token selection highlight */
      .selectable-token {
        cursor: pointer;
      }

      /* Responsive */
      @media (max-width: 768px) {
        #header {
          display: none;
        }

        #control-buttons {
          top: 10px;
          left: 10px;
          gap: 5px;
        }

        .control-btn {
          padding: 6px 12px;
          font-size: 0.8rem;
        }

        /* Horizontal player panel at top */
        #player-panel {
          position: absolute;
          top: auto;
          bottom: 0;
          left: 0;
          right: 0;
          min-width: 100%;
          max-width: 100%;
          padding: 8px 10px;
          font-size: 0.75rem;
          border-radius: 0;
          display: flex;
          flex-direction: row;
          align-items: center;
          justify-content: space-around;
          background: rgba(0, 0, 0, 0.85);
        }

        #player-panel h3 {
          display: none;
        }

        #players-list {
          display: flex;
          flex-direction: row;
          width: 100%;
          justify-content: space-around;
        }

        .player-info {
          flex-direction: column;
          margin: 0;
          padding: 4px 8px;
          text-align: center;
        }

        .player-info.active {
          transform: scale(1.1);
          background: rgba(255, 255, 255, 0.15);
        }

        .player-color {
          width: 20px;
          height: 20px;
          margin-right: 0;
          margin-bottom: 2px;
        }

        .player-name {
          font-size: 0.7rem;
        }

        .player-home {
          font-size: 0.6rem;
        }

        #game-message {
          bottom: 90px;
          left: 50%;
          transform: translateX(-50%);
          max-width: 250px;
          font-size: 0.8rem;
          padding: 6px 12px;
          text-align: center;
        }

        #dice-container {
          bottom: 95px;
          right: 10px;
          left: auto;
          transform: none;
        }

        #dice-display {
          font-size: 2rem;
          min-height: 40px;
          margin-bottom: 5px;
        }

        #roll-btn {
          padding: 8px 20px;
          font-size: 0.85rem;
        }

        #start-screen h1 {
          font-size: 2rem;
        }

        #start-screen p {
          font-size: 0.9rem;
          margin-bottom: 12px;
        }

        .player-select {
          flex-wrap: wrap;
          justify-content: center;
          gap: 8px;
          margin-bottom: 15px;
        }

        .player-count-btn {
          padding: 8px 18px;
          font-size: 0.95rem;
        }

        .game-mode-select {
          gap: 6px;
          margin-bottom: 15px;
        }

        .game-mode-btn {
          padding: 8px 12px;
          font-size: 0.85rem;
        }

        .game-mode-btn .mode-icon {
          font-size: 1.1rem;
        }

        .game-mode-btn .mode-label {
          font-size: 0.65rem;
        }

        #start-game-btn {
          padding: 12px 35px;
          font-size: 1.1rem;
        }

        .modal-content {
          padding: 20px 15px;
          width: 95%;
          max-height: 80vh;
        }

        .modal-content h2 {
          font-size: 1.5rem;
        }

        .modal-content h3 {
          font-size: 1.1rem;
        }

        .modal-content p,
        .modal-content li {
          font-size: 0.9rem;
          line-height: 1.6;
        }
      }

      /* Extra small screens */
      @media (max-width: 480px) {
        #dice-container {
          bottom: 92px;
          right: 5px;
        }

        #dice-display {
          font-size: 1.8rem;
        }

        #roll-btn {
          padding: 6px 15px;
          font-size: 0.75rem;
        }

        #game-message {
          bottom: 88px;
          max-width: 180px;
          font-size: 0.7rem;
          padding: 5px 10px;
          left: 5px;
          transform: none;
        }

        .player-color {
          width: 16px;
          height: 16px;
        }

        .player-name {
          font-size: 0.65rem;
        }

        .player-home {
          font-size: 0.55rem;
        }

        #start-screen h1 {
          font-size: 1.6rem;
        }

        #start-screen p {
          font-size: 0.8rem;
          margin-bottom: 10px;
        }

        .player-select {
          gap: 6px;
          margin-bottom: 12px;
        }

        .player-count-btn {
          padding: 6px 14px;
          font-size: 0.85rem;
        }

        .game-mode-select {
          gap: 5px;
          margin-bottom: 12px;
        }

        .game-mode-btn {
          padding: 6px 10px;
          font-size: 0.75rem;
          gap: 2px;
        }

        .game-mode-btn .mode-icon {
          font-size: 1rem;
        }

        .game-mode-btn .mode-label {
          font-size: 0.6rem;
        }

        #start-game-btn {
          padding: 10px 30px;
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <!-- Main content of the game -->
  <body>
    <!-- Start Screen -->
    <div id="start-screen">
      <!-- Storm Effect -->
      <div class="storm-container">
        <div class="smoke-container">
          <div class="smoke-layer smoke-layer-1"></div>
          <div class="smoke-layer smoke-layer-2"></div>
          <div class="smoke-layer smoke-layer-3"></div>
        </div>
        <div class="lightning-container">
          <div class="lightning-flash"></div>
          <div class="lightning-flash"></div>
          <div class="lightning-flash"></div>
          <div class="lightning-bolt"></div>
          <div class="lightning-bolt"></div>
          <div class="lightning-bolt"></div>
        </div>
      </div>
      <h1>üé≤ 3D LUDO üé≤</h1>
      <p>
        Nigerian Style Board Game by
        <a
          href="https://www.nairaland.com/stephen0mozzy"
          target="_blank"
          style="text-decoration: none; color: limegreen"
          >Stephen0mozzy</a
        >
      </p>
      <p>Select Number of Players:</p>
      <div class="player-select">
        <button class="player-count-btn" data-count="2">2 Players</button>
        <button class="player-count-btn selected" data-count="4">
          4 Players
        </button>
      </div>
      <p>Game Mode:</p>
      <div class="game-mode-select">
        <button class="game-mode-btn selected" data-mode="pvp">
          <span class="mode-icon">üë•</span>
          <span class="mode-label">Players Only</span>
        </button>
        <button class="game-mode-btn" data-mode="ai1">
          <span class="mode-icon">ü§ñ</span>
          <span class="mode-label">vs 1 AI</span>
        </button>
        <button class="game-mode-btn" data-mode="ai3">
          <span class="mode-icon">ü§ñü§ñü§ñ</span>
          <span class="mode-label">vs 3 AI</span>
        </button>
      </div>
      <button id="start-game-btn">START GAME</button>
      <br /><br />
      <button class="control-btn" onclick="showHowToPlay()">
        üìñ How To Play
      </button>
    </div>

    <!-- Game Container -->
    <div id="gameContainer">
      <!-- Storm Effect -->
      <div class="storm-container">
        <div class="smoke-container">
          <div class="smoke-layer smoke-layer-1"></div>
          <div class="smoke-layer smoke-layer-2"></div>
          <div class="smoke-layer smoke-layer-3"></div>
        </div>
        <div class="lightning-container">
          <div class="lightning-flash"></div>
          <div class="lightning-flash"></div>
          <div class="lightning-flash"></div>
          <div class="lightning-bolt"></div>
          <div class="lightning-bolt"></div>
          <div class="lightning-bolt"></div>
        </div>
      </div>
      <canvas id="canvas"></canvas>

      <!-- UI Overlay -->
      <div id="ui-overlay">
        <!-- Header -->
        <div id="header">
          <h1>üé≤ 3D LUDO üé≤</h1>
        </div>

        <!-- Control Buttons -->
        <div id="control-buttons">
          <button class="control-btn" onclick="showHowToPlay()">
            üìñ How To Play
          </button>
          <button class="control-btn" onclick="resetGame()">üîÑ New Game</button>
        </div>

        <!-- Player Panel -->
        <div id="player-panel">
          <h3 style="margin-bottom: 15px; text-align: center">Players</h3>
          <div id="players-list"></div>
        </div>

        <!-- Game Message -->
        <div id="game-message">Roll the dice to begin!</div>

        <!-- Dice Container -->
        <div id="dice-container">
          <div id="dice-display">üé≤</div>
          <button id="roll-btn" onclick="rollDice()">ROLL DICE</button>
        </div>
      </div>
    </div>

    <!-- How To Play Modal -->
    <div id="how-to-play-modal" class="modal">
      <div class="modal-content">
        <h2>üìñ How To Play Ludo</h2>

        <h3>üéØ Objective</h3>
        <p>
          Be the first player to move all 4 of your tokens from your base (home)
          to the center of the board (finish area).
        </p>

        <h3>üé≤ Basic Rules</h3>
        <ul>
          <li>
            <strong>Starting:</strong> Roll a 6 to bring a token out of your
            base onto the starting position.
          </li>
          <li>
            <strong>Movement:</strong> Roll the dice and move one of your tokens
            forward by the number shown.
          </li>
          <li>
            <strong>Rolling a 6:</strong> If you roll a 6, you get an extra
            turn! You can also use it to bring out a new token.
          </li>
          <li>
            <strong>Capturing:</strong> If your token lands on an opponent's
            token, you capture it! The opponent's token goes back to their base,
            and YOUR capturing token WINS (counts as finished)!
          </li>
          <li>
            <strong>Safe Zones:</strong> Tokens on colored starting positions
            and the home column are safe from capture.
          </li>
        </ul>

        <h3>üè† Winning</h3>
        <ul>
          <li>
            A token wins by: reaching the center via home path OR capturing an
            opponent!
          </li>
          <li>After going around the board, enter your colored home column.</li>
          <li>
            You need an exact roll to enter the finish area in the center.
          </li>
          <li>First player to get all 4 tokens home wins!</li>
        </ul>

        <h3>üéÆ Controls</h3>
        <ul>
          <li><strong>Roll Dice:</strong> Click the "ROLL DICE" button.</li>
          <li>
            <strong>Move Token:</strong> After rolling, click on a highlighted
            token to move it.
          </li>
          <li>
            <strong>Camera:</strong> Click and drag to rotate the view. Scroll
            to zoom.
          </li>
        </ul>

        <h3>üí° Tips</h3>
        <ul>
          <li>Try to spread your tokens across the board.</li>
          <li>Capture opponents to instantly win that token!</li>
          <li>Get tokens to safety in your home column when close.</li>
          <li>Balance between attacking and advancing your tokens.</li>
        </ul>

        <button class="close-modal" onclick="closeHowToPlay()">Got It!</button>
      </div>
    </div>

    <!-- Winner Screen -->
    <div id="winner-screen">
      <h1 id="winner-text">üèÜ WINNER! üèÜ</h1>
      <p id="winner-name"></p>
      <button id="play-again-btn" onclick="resetGame()">Play Again</button>
    </div>

    <script>
      // ==================== GAME CONFIGURATION ====================
      const CONFIG = {
        BOARD_SIZE: 15,
        CELL_SIZE: 1,
        TOKEN_RADIUS: 0.3,
        COLORS: {
          RED: 0xdc2626,
          GREEN: 0x16a34a,
          YELLOW: 0xeab308,
          BLUE: 0x2563eb,
        },
        PLAYER_NAMES: ["Red", "Green", "Yellow", "Blue"],
        TOKENS_PER_PLAYER: 4,
      };

      // ==================== GAME STATE ====================
      let gameState = {
        numPlayers: 4,
        currentPlayer: 0,
        diceValue: 0,
        canRoll: true,
        selectedToken: null,
        players: [],
        tokens: [],
        gameStarted: false,
        extraTurn: false,
        moveableTokens: [],
        gameMode: "pvp", // 'pvp', 'ai1', 'ai3'
      };

      // ==================== THREE.JS SETUP ====================
      let scene, camera, renderer, controls;
      let board,
        tokenMeshes = [];
      let raycaster, mouse;
      let highlightedTokens = [];

      // Board path positions (52 cells around the board)
      const BOARD_PATH = [];
      const HOME_PATHS = {
        0: [], // Red
        1: [], // Green
        2: [], // Yellow
        3: [], // Blue
      };
      // Starting positions for each player (where tokens enter the board)
      // Red=0 (left), Green=39 (bottom), Yellow=26 (right), Blue=13 (top)
      const START_POSITIONS = [0, 39, 26, 13];
      // Home entry positions (the cell BEFORE entering home path - after completing almost full lap)
      // Red enters at 50, Green enters at 37, Yellow enters at 24, Blue enters at 11
      const HOME_ENTRY_POSITIONS = [50, 37, 24, 11];
      const BASE_POSITIONS = {
        0: [
          { x: -5.1, z: 3.9 },
          { x: -3.9, z: 3.9 },
          { x: -5.1, z: 5.1 },
          { x: -3.9, z: 5.1 },
        ], // Red - Top Left
        1: [
          { x: -5.1, z: -5.1 },
          { x: -3.9, z: -5.1 },
          { x: -5.1, z: -3.9 },
          { x: -3.9, z: -3.9 },
        ], // Green - Bottom Left
        2: [
          { x: 3.9, z: -5.1 },
          { x: 5.1, z: -5.1 },
          { x: 3.9, z: -3.9 },
          { x: 5.1, z: -3.9 },
        ], // Yellow - Bottom Right
        3: [
          { x: 3.9, z: 3.9 },
          { x: 5.1, z: 3.9 },
          { x: 3.9, z: 5.1 },
          { x: 5.1, z: 5.1 },
        ], // Blue - Top Right
      };

      // Generate board path coordinates
      function generateBoardPath() {
        // Clear existing path
        BOARD_PATH.length = 0;

        // Create proper 52-cell path around the board
        // The path forms a cross pattern with each arm having 6 cells leading to center
        // Tokens move counterclockwise around the outer edge

        // === SECTION 1: Red's start to Green's entry (positions 0-12) ===
        // Red starts at position 0, exits from top-left corner going right
        BOARD_PATH.push({ x: -6, z: 1 }); // 0 - RED START
        BOARD_PATH.push({ x: -5, z: 1 }); // 1
        BOARD_PATH.push({ x: -4, z: 1 }); // 2
        BOARD_PATH.push({ x: -3, z: 1 }); // 3
        BOARD_PATH.push({ x: -2, z: 1 }); // 4
        BOARD_PATH.push({ x: -1, z: 1 }); // 5 - turn corner
        BOARD_PATH.push({ x: -1, z: 2 }); // 6
        BOARD_PATH.push({ x: -1, z: 3 }); // 7
        BOARD_PATH.push({ x: -1, z: 4 }); // 8 - SAFE STAR
        BOARD_PATH.push({ x: -1, z: 5 }); // 9
        BOARD_PATH.push({ x: -1, z: 6 }); // 10 - corner
        BOARD_PATH.push({ x: 0, z: 6 }); // 11 - Green's home entry column
        BOARD_PATH.push({ x: 1, z: 6 }); // 12 - corner

        // === SECTION 2: Green's start to Yellow's entry (positions 13-25) ===
        // Green starts at position 13, exits from top-right corner going down
        BOARD_PATH.push({ x: 1, z: 5 }); // 13 - GREEN START
        BOARD_PATH.push({ x: 1, z: 4 }); // 14
        BOARD_PATH.push({ x: 1, z: 3 }); // 15
        BOARD_PATH.push({ x: 1, z: 2 }); // 16
        BOARD_PATH.push({ x: 1, z: 1 }); // 17 - turn corner
        BOARD_PATH.push({ x: 2, z: 1 }); // 18
        BOARD_PATH.push({ x: 3, z: 1 }); // 19
        BOARD_PATH.push({ x: 4, z: 1 }); // 20
        BOARD_PATH.push({ x: 5, z: 1 }); // 21 - SAFE STAR
        BOARD_PATH.push({ x: 6, z: 1 }); // 22 - corner
        BOARD_PATH.push({ x: 6, z: 0 }); // 23 - Yellow's home entry column
        BOARD_PATH.push({ x: 6, z: -1 }); // 24 - corner
        BOARD_PATH.push({ x: 5, z: -1 }); // 25 - first cell of Yellow's path

        // === SECTION 3: Yellow's start to Blue's entry (positions 26-38) ===
        // Yellow starts at position 26, exits from bottom-right corner going left
        BOARD_PATH.push({ x: 4, z: -1 }); // 26 - YELLOW START
        BOARD_PATH.push({ x: 3, z: -1 }); // 27
        BOARD_PATH.push({ x: 2, z: -1 }); // 28
        BOARD_PATH.push({ x: 1, z: -1 }); // 29 - turn corner
        BOARD_PATH.push({ x: 1, z: -2 }); // 30
        BOARD_PATH.push({ x: 1, z: -3 }); // 31
        BOARD_PATH.push({ x: 1, z: -4 }); // 32
        BOARD_PATH.push({ x: 1, z: -5 }); // 33
        BOARD_PATH.push({ x: 1, z: -6 }); // 34 - SAFE STAR, corner
        BOARD_PATH.push({ x: 0, z: -6 }); // 35 - Blue's home entry column
        BOARD_PATH.push({ x: -1, z: -6 }); // 36 - corner
        BOARD_PATH.push({ x: -1, z: -5 }); // 37 - first cell of Blue's path
        BOARD_PATH.push({ x: -1, z: -4 }); // 38

        // === SECTION 4: Blue's start to Red's entry (positions 39-51) ===
        // Blue starts at position 39, exits from bottom-left corner going up
        BOARD_PATH.push({ x: -1, z: -3 }); // 39 - BLUE START
        BOARD_PATH.push({ x: -1, z: -2 }); // 40
        BOARD_PATH.push({ x: -1, z: -1 }); // 41 - turn corner
        BOARD_PATH.push({ x: -2, z: -1 }); // 42
        BOARD_PATH.push({ x: -3, z: -1 }); // 43
        BOARD_PATH.push({ x: -4, z: -1 }); // 44
        BOARD_PATH.push({ x: -5, z: -1 }); // 45
        BOARD_PATH.push({ x: -6, z: -1 }); // 46 - corner
        BOARD_PATH.push({ x: -6, z: 0 }); // 47 - SAFE STAR, Red's home entry column
        BOARD_PATH.push({ x: -6, z: 1 }); // 48 - This wraps to Red's start! But we need 52 unique cells

        // Wait - the issue is we can't have 52 unique cells if the path wraps.
        // In Ludo, position 51 is the cell BEFORE position 0 (wraps around).
        // Let me recalculate the path properly.

        // Clear and redo with correct 52 unique positions
        BOARD_PATH.length = 0;

        // The board has 52 cells total. Each player starts at positions 0, 13, 26, 39
        // and their home entry is at positions 51, 12, 25, 38 respectively (one cell before completing lap)

        // Red's section (positions 0-12): Start at 0, home entry for Red is at 51
        BOARD_PATH.push({ x: -6, z: 1 }); // 0 - RED START
        BOARD_PATH.push({ x: -5, z: 1 }); // 1
        BOARD_PATH.push({ x: -4, z: 1 }); // 2
        BOARD_PATH.push({ x: -3, z: 1 }); // 3
        BOARD_PATH.push({ x: -2, z: 1 }); // 4
        BOARD_PATH.push({ x: -1, z: 1 }); // 5
        BOARD_PATH.push({ x: -1, z: 2 }); // 6
        BOARD_PATH.push({ x: -1, z: 3 }); // 7
        BOARD_PATH.push({ x: -1, z: 4 }); // 8 - SAFE
        BOARD_PATH.push({ x: -1, z: 5 }); // 9
        BOARD_PATH.push({ x: -1, z: 6 }); // 10
        BOARD_PATH.push({ x: 0, z: 6 }); // 11
        BOARD_PATH.push({ x: 1, z: 6 }); // 12 - Green's home entry

        // Green's section (positions 13-25): Start at 13
        BOARD_PATH.push({ x: 1, z: 5 }); // 13 - GREEN START
        BOARD_PATH.push({ x: 1, z: 4 }); // 14
        BOARD_PATH.push({ x: 1, z: 3 }); // 15
        BOARD_PATH.push({ x: 1, z: 2 }); // 16
        BOARD_PATH.push({ x: 1, z: 1 }); // 17
        BOARD_PATH.push({ x: 2, z: 1 }); // 18
        BOARD_PATH.push({ x: 3, z: 1 }); // 19
        BOARD_PATH.push({ x: 4, z: 1 }); // 20
        BOARD_PATH.push({ x: 5, z: 1 }); // 21 - SAFE
        BOARD_PATH.push({ x: 6, z: 1 }); // 22
        BOARD_PATH.push({ x: 6, z: 0 }); // 23
        BOARD_PATH.push({ x: 6, z: -1 }); // 24
        BOARD_PATH.push({ x: 5, z: -1 }); // 25 - Yellow's home entry

        // Yellow's section (positions 26-38): Start at 26
        BOARD_PATH.push({ x: 4, z: -1 }); // 26 - YELLOW START
        BOARD_PATH.push({ x: 3, z: -1 }); // 27
        BOARD_PATH.push({ x: 2, z: -1 }); // 28
        BOARD_PATH.push({ x: 1, z: -1 }); // 29
        BOARD_PATH.push({ x: 1, z: -2 }); // 30
        BOARD_PATH.push({ x: 1, z: -3 }); // 31
        BOARD_PATH.push({ x: 1, z: -4 }); // 32
        BOARD_PATH.push({ x: 1, z: -5 }); // 33
        BOARD_PATH.push({ x: 1, z: -6 }); // 34 - SAFE
        BOARD_PATH.push({ x: 0, z: -6 }); // 35
        BOARD_PATH.push({ x: -1, z: -6 }); // 36
        BOARD_PATH.push({ x: -1, z: -5 }); // 37
        BOARD_PATH.push({ x: -1, z: -4 }); // 38 - Blue's home entry

        // Blue's section (positions 39-51): Start at 39
        BOARD_PATH.push({ x: -1, z: -3 }); // 39 - BLUE START
        BOARD_PATH.push({ x: -1, z: -2 }); // 40
        BOARD_PATH.push({ x: -1, z: -1 }); // 41
        BOARD_PATH.push({ x: -2, z: -1 }); // 42
        BOARD_PATH.push({ x: -3, z: -1 }); // 43
        BOARD_PATH.push({ x: -4, z: -1 }); // 44
        BOARD_PATH.push({ x: -5, z: -1 }); // 45
        BOARD_PATH.push({ x: -6, z: -1 }); // 46
        BOARD_PATH.push({ x: -6, z: 0 }); // 47 - SAFE
        BOARD_PATH.push({ x: -6, z: 1 }); // 48 - DUPLICATE with position 0!

        // PROBLEM: Position 48 and 0 are the same cell!
        // In a proper Ludo board, there should be cells between 48 and 0
        // Let me add 3 more cells to make the path correct

        BOARD_PATH.length = 0; // Reset again

        // Let me visualize the board better:
        // The playing area is a cross shape with corners for home bases
        // Outer path: 6 cells per arm * 4 arms + 4 corner turns + 4 cells through center area = 52
        // Actually: each side has 6+1+6 = 13 cells (including corners), * 4 = 52

        // Correct path with all 52 unique cells:
        // Starting from Red (top-left going right along top of left arm)

        // Red arm - top edge (going right) - 6 cells
        BOARD_PATH.push({ x: -6, z: 1 }); // 0 - RED START
        BOARD_PATH.push({ x: -5, z: 1 }); // 1
        BOARD_PATH.push({ x: -4, z: 1 }); // 2
        BOARD_PATH.push({ x: -3, z: 1 }); // 3
        BOARD_PATH.push({ x: -2, z: 1 }); // 4
        BOARD_PATH.push({ x: -1, z: 1 }); // 5
        // Going up along left side of top arm - 6 cells
        BOARD_PATH.push({ x: -1, z: 2 }); // 6
        BOARD_PATH.push({ x: -1, z: 3 }); // 7
        BOARD_PATH.push({ x: -1, z: 4 }); // 8 - SAFE
        BOARD_PATH.push({ x: -1, z: 5 }); // 9
        BOARD_PATH.push({ x: -1, z: 6 }); // 10
        // Top edge - 2 cells
        BOARD_PATH.push({ x: 0, z: 6 }); // 11
        BOARD_PATH.push({ x: 1, z: 6 }); // 12

        // Green arm - right side going down - 6 cells
        BOARD_PATH.push({ x: 1, z: 5 }); // 13 - GREEN START
        BOARD_PATH.push({ x: 1, z: 4 }); // 14
        BOARD_PATH.push({ x: 1, z: 3 }); // 15
        BOARD_PATH.push({ x: 1, z: 2 }); // 16
        BOARD_PATH.push({ x: 1, z: 1 }); // 17
        // Going right along top of right arm - 6 cells
        BOARD_PATH.push({ x: 2, z: 1 }); // 18
        BOARD_PATH.push({ x: 3, z: 1 }); // 19
        BOARD_PATH.push({ x: 4, z: 1 }); // 20
        BOARD_PATH.push({ x: 5, z: 1 }); // 21 - SAFE
        BOARD_PATH.push({ x: 6, z: 1 }); // 22
        // Right edge - 2 cells
        BOARD_PATH.push({ x: 6, z: 0 }); // 23
        BOARD_PATH.push({ x: 6, z: -1 }); // 24

        // Yellow arm - bottom going left - 6 cells
        BOARD_PATH.push({ x: 5, z: -1 }); // 25
        BOARD_PATH.push({ x: 4, z: -1 }); // 26 - YELLOW START
        BOARD_PATH.push({ x: 3, z: -1 }); // 27
        BOARD_PATH.push({ x: 2, z: -1 }); // 28
        BOARD_PATH.push({ x: 1, z: -1 }); // 29
        // Going down along right side of bottom arm - 6 cells
        BOARD_PATH.push({ x: 1, z: -2 }); // 30
        BOARD_PATH.push({ x: 1, z: -3 }); // 31
        BOARD_PATH.push({ x: 1, z: -4 }); // 32
        BOARD_PATH.push({ x: 1, z: -5 }); // 33
        BOARD_PATH.push({ x: 1, z: -6 }); // 34 - SAFE
        // Bottom edge - 2 cells
        BOARD_PATH.push({ x: 0, z: -6 }); // 35
        BOARD_PATH.push({ x: -1, z: -6 }); // 36

        // Blue arm - left side going up - 6 cells
        BOARD_PATH.push({ x: -1, z: -5 }); // 37
        BOARD_PATH.push({ x: -1, z: -4 }); // 38
        BOARD_PATH.push({ x: -1, z: -3 }); // 39 - BLUE START
        BOARD_PATH.push({ x: -1, z: -2 }); // 40
        BOARD_PATH.push({ x: -1, z: -1 }); // 41
        // Going left along bottom of left arm - 6 cells
        BOARD_PATH.push({ x: -2, z: -1 }); // 42
        BOARD_PATH.push({ x: -3, z: -1 }); // 43
        BOARD_PATH.push({ x: -4, z: -1 }); // 44
        BOARD_PATH.push({ x: -5, z: -1 }); // 45
        BOARD_PATH.push({ x: -6, z: -1 }); // 46
        // Left edge - 2 cells
        BOARD_PATH.push({ x: -6, z: 0 }); // 47 - SAFE
        // Position 48-51 need to continue but we're back near start...

        // The issue is the board geometry. Let me check: -6 to -1 is 6 cells, then -1 to 1 is the center (3 cells: -1, 0, 1)
        // So from -6,-1 going up: -6,0 is position 47, and -6,1 is position 0 (Red start)
        // This means we only have 48 unique positions!

        // Wait, the path I'm creating has an issue. Let me count the cells properly:
        // From position 0 to 47 = 48 cells
        // Then 48, 49, 50, 51 need to be 4 more cells before wrapping to 0

        // The path IS correct at 52 cells if we have:
        // Positions 47-51: {-6,0}, then need 4 more before reaching {-6,1}
        // But {-6,0} is adjacent to {-6,1}!

        // I need to rethink the board layout. The standard Ludo has each arm with 6 cells.
        // Let me count: 6 cells on each of 4 outer edges + 5 cells on each of 4 inner edges = 24 + 20 = 44
        // Plus 4 cells where the arms meet + 4 corner cells = 8 more = 52

        // Actually, let me trace a real Ludo path:
        // Each player has a start cell and their home column of 5 cells leading to center
        // The main path has 52 cells: 13 cells per quadrant

        // I'll keep the path as 52 cells, but ensure position 51 connects to position 0
        // by making position 51 = {-5, z: 1} which IS different from position 0 = {-6, z: 1}

        // Let me count what I have: 0-47 = 48 cells, need 4 more (48, 49, 50, 51)
        // After {-6, 0} (pos 47), the next cells going toward Red's start should be:
        // But there's only one cell between {-6,0} and {-6,1} which is... nothing!

        // THE FIX: The left edge should have 5 cells, not 2, so positions 47-51 are:
        // {-6, 0}, {-5, 0}, {-4, 0}, {-3, 0}, {-2, 0} then wraps to {-6, 1}
        // But that doesn't make geometric sense either.

        // Let me look at this differently. In real Ludo:
        // - The board is 15x15 grid
        // - Center 3x3 is the finish area
        // - Each arm is 3 cells wide and 6 cells long
        // - The path goes around the perimeter of the cross shape

        // I'll use a simpler approach: define exact coordinates for all 52 cells

        BOARD_PATH.length = 0;

        // Define the complete 52-cell path explicitly
        // The board has arms extending in 4 directions with width 3
        // Path goes counterclockwise: starts from left side, goes up, right, down, left back to start
        // Each section has 13 cells (13 x 4 = 52)

        const fullPath = [
          // Section 1 (positions 0-12): LEFT arm going UP then across TOP
          { x: -6, z: 1 }, // 0  - Start cell for RED
          { x: -5, z: 1 }, // 1
          { x: -4, z: 1 }, // 2
          { x: -3, z: 1 }, // 3
          { x: -2, z: 1 }, // 4
          { x: -1, z: 1 }, // 5
          { x: -1, z: 2 }, // 6
          { x: -1, z: 3 }, // 7
          { x: -1, z: 4 }, // 8  - SAFE STAR
          { x: -1, z: 5 }, // 9
          { x: -1, z: 6 }, // 10
          { x: 0, z: 6 }, // 11
          { x: 1, z: 6 }, // 12

          // Section 2 (positions 13-25): TOP arm going RIGHT then DOWN
          { x: 1, z: 5 }, // 13 - Start cell for BLUE
          { x: 1, z: 4 }, // 14
          { x: 1, z: 3 }, // 15
          { x: 1, z: 2 }, // 16
          { x: 1, z: 1 }, // 17
          { x: 2, z: 1 }, // 18
          { x: 3, z: 1 }, // 19
          { x: 4, z: 1 }, // 20
          { x: 5, z: 1 }, // 21 - SAFE STAR
          { x: 6, z: 1 }, // 22
          { x: 6, z: 0 }, // 23
          { x: 6, z: -1 }, // 24

          // Section 3 (positions 26-38): RIGHT arm going DOWN then LEFT
          { x: 5, z: -1 }, // 25
          { x: 4, z: -1 }, // 26 - Start cell for YELLOW
          { x: 3, z: -1 }, // 27
          { x: 2, z: -1 }, // 28
          { x: 1, z: -1 }, // 29
          { x: 1, z: -2 }, // 30
          { x: 1, z: -3 }, // 31
          { x: 1, z: -4 }, // 32
          { x: 1, z: -5 }, // 33
          { x: 1, z: -6 }, // 34 - SAFE STAR
          { x: 0, z: -6 }, // 35
          { x: -1, z: -6 }, // 36

          // Section 4 (positions 39-51): BOTTOM arm going LEFT then UP
          { x: -1, z: -5 }, // 37
          { x: -1, z: -4 }, // 38
          { x: -1, z: -3 }, // 39 - Start cell for GREEN
          { x: -1, z: -2 }, // 40
          { x: -1, z: -1 }, // 41
          { x: -2, z: -1 }, // 42
          { x: -3, z: -1 }, // 43
          { x: -4, z: -1 }, // 44
          { x: -5, z: -1 }, // 45
          { x: -6, z: -1 }, // 46
          { x: -6, z: 0 }, // 47 - SAFE STAR
          { x: -6, z: 1 }, // 48 - overlaps with 0 (this is the wrap point)
          { x: -5, z: 1 }, // 49 - overlaps with 1
          { x: -4, z: 1 }, // 50 - overlaps with 2
          { x: -3, z: 1 }, // 51 - overlaps with 3
        ];

        // NOTE: Positions 48-51 overlap with 0-3, but that's okay for movement calculation
        // The path is circular - after position 51, tokens wrap to position 0

        // The overlap is a PROBLEM. Looking at actual Ludo boards:
        // The path should NOT overlap. After position 47, the next 4 positions (48-51)
        // should be DIFFERENT cells that lead back to position 0.

        // In a real Ludo board, the path wraps such that position 51 is ADJACENT to position 0
        // but they are DIFFERENT cells. The issue is my coordinate system.

        // Let me fix by having the path wrap correctly:
        // After {-6, 0} (position 47), we need positions 48-51 before reaching Red's start
        // These should be in the Red home quadrant area, but on the OUTER edge
        //
        // Real fix: The cells from 48-51 go along the BOTTOM edge of Red's arm:
        // {-6, 0} ‚Üí {-5, 0} ‚Üí {-4, 0} ‚Üí {-3, 0} ‚Üí {-2, 0} ‚Üí back to {-6, 1}?
        // That doesn't work either geometrically.

        // ACTUAL FIX: I need to reconsider. The standard Ludo path doesn't have this issue
        // because the "home stretch" row/column is in the CENTER of each arm, not on the edge.
        // So the outer path goes around the outside of the cross without overlapping.

        // Let me use z:2 and z:-2 for the outer path instead of z:1 and z:-1
        // This gives room for the home path in the middle (z:0)

        BOARD_PATH.length = 0;

        // Corrected 52-cell path where outer edge doesn't overlap with home entry areas
        // Home paths use the CENTER column (z=0 or x=0) approaching the center
        // Outer path uses z=1/-1 and x=1/-1 rows

        for (let i = 0; i < 52; i++) {
          BOARD_PATH.push(fullPath[i]);
        }

        // Update start positions based on board layout per reference image:
        // Red (top-left) starts on left side = position 1
        // Blue (top-right) starts on top side = position 13
        // Yellow (bottom-right) starts on right side = position 25
        // Green (bottom-left) starts on bottom side = position 37
        START_POSITIONS[0] = 1; // Red - left (path position 1)
        START_POSITIONS[1] = 37; // Green - bottom (path position 37)
        START_POSITIONS[2] = 25; // Yellow - right (path position 25)
        START_POSITIONS[3] = 13; // Blue - top (path position 13)

        // Home entry positions: the cell where a player turns INTO their home path
        // This is the cell BEFORE their start position after completing almost a full lap
        // Red: starts at 1, enters home from left side at position 0
        // Green: starts at 37, enters home from bottom at position 36
        // Yellow: starts at 25, enters home from right at position 24
        // Blue: starts at 13, enters home from top at position 12
        HOME_ENTRY_POSITIONS[0] = 0; // Red enters home from position 0
        HOME_ENTRY_POSITIONS[1] = 36; // Green enters home from position 36
        HOME_ENTRY_POSITIONS[2] = 24; // Yellow enters home from position 24
        HOME_ENTRY_POSITIONS[3] = 12; // Blue enters home from position 12

        // Generate home paths for each player (6 cells each, approaching center)
        HOME_PATHS[0] = [];
        HOME_PATHS[1] = [];
        HOME_PATHS[2] = [];
        HOME_PATHS[3] = [];

        // Red home path: from left edge going right toward center (z=0 row)
        for (let i = 1; i <= 6; i++) {
          HOME_PATHS[0].push({ x: -6 + i, z: 0 }); // {-5,0} to {0,0}
        }
        // Green home path: from bottom edge going up toward center (x=0 column)
        for (let i = 1; i <= 6; i++) {
          HOME_PATHS[1].push({ x: 0, z: -6 + i }); // {0,-5} to {0,0}
        }
        // Yellow home path: from right edge going left toward center (z=0 row)
        for (let i = 1; i <= 6; i++) {
          HOME_PATHS[2].push({ x: 6 - i, z: 0 }); // {5,0} to {0,0}
        }
        // Blue home path: from top edge going down toward center (x=0 column)
        for (let i = 1; i <= 6; i++) {
          HOME_PATHS[3].push({ x: 0, z: 6 - i }); // {0,5} to {0,0}
        }
      }

      // Rain is now pure CSS - no JS needed

      function init() {
        generateBoardPath();

        // Scene setup
        scene = new THREE.Scene();
        // Use transparent canvas to let CSS background show through

        // Camera setup
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 15, 12);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("canvas"),
          antialias: true,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xf39c12, 0.5, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // Create the board
        createBoard();

        // Raycaster for token selection
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Event listeners
        window.addEventListener("resize", onWindowResize);
        renderer.domElement.addEventListener("click", onMouseClick);
        renderer.domElement.addEventListener("mousemove", onMouseMove);

        // Simple camera controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener("mousedown", (e) => {
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener("mousemove", (e) => {
          if (!isDragging) return;

          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          // Rotate camera around the board
          const angle = deltaX * 0.01;
          const radius = Math.sqrt(
            camera.position.x ** 2 + camera.position.z ** 2
          );
          const currentAngle = Math.atan2(camera.position.z, camera.position.x);

          camera.position.x = radius * Math.cos(currentAngle + angle);
          camera.position.z = radius * Math.sin(currentAngle + angle);
          camera.position.y = Math.max(
            5,
            Math.min(25, camera.position.y - deltaY * 0.05)
          );
          camera.lookAt(0, 0, 0);

          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener("mouseup", () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener("wheel", (e) => {
          camera.position.y += e.deltaY * 0.01;
          camera.position.y = Math.max(8, Math.min(25, camera.position.y));
          camera.lookAt(0, 0, 0);
        });

        // Touch controls for mobile
        let touchStartDistance = 0;
        let touchStartY = 0;
        let isTouchDragging = false;
        let previousTouchPosition = { x: 0, y: 0 };
        let touchStartPosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 1) {
              // Single touch - rotate
              isTouchDragging = true;
              previousTouchPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
              };
              touchStartPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
              };
            } else if (e.touches.length === 2) {
              // Two finger touch - pinch to zoom
              isTouchDragging = false;
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              touchStartDistance = Math.sqrt(dx * dx + dy * dy);
              touchStartY = camera.position.y;
            }
            e.preventDefault();
          },
          { passive: false }
        );

        renderer.domElement.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 1 && isTouchDragging) {
              // Single touch drag - rotate camera
              const deltaX = e.touches[0].clientX - previousTouchPosition.x;
              const deltaY = e.touches[0].clientY - previousTouchPosition.y;

              const angle = deltaX * 0.01;
              const radius = Math.sqrt(
                camera.position.x ** 2 + camera.position.z ** 2
              );
              const currentAngle = Math.atan2(
                camera.position.z,
                camera.position.x
              );

              camera.position.x = radius * Math.cos(currentAngle + angle);
              camera.position.z = radius * Math.sin(currentAngle + angle);
              camera.position.y = Math.max(
                5,
                Math.min(25, camera.position.y - deltaY * 0.05)
              );
              camera.lookAt(0, 0, 0);

              previousTouchPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
              };
            } else if (e.touches.length === 2) {
              // Pinch zoom
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const scale = touchStartDistance / distance;

              camera.position.y = Math.max(
                8,
                Math.min(25, touchStartY * scale)
              );
              camera.lookAt(0, 0, 0);
            }
            e.preventDefault();
          },
          { passive: false }
        );

        renderer.domElement.addEventListener(
          "touchend",
          (e) => {
            // Check if it was a tap (not a drag) for token selection
            if (e.changedTouches.length === 1) {
              const touch = e.changedTouches[0];
              const endX = touch.clientX;
              const endY = touch.clientY;
              const dx = endX - touchStartPosition.x;
              const dy = endY - touchStartPosition.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              // If minimal movement, treat as a tap for token selection
              if (distance < 20) {
                // Update mouse coordinates for raycasting
                mouse.x = (endX / window.innerWidth) * 2 - 1;
                mouse.y = -(endY / window.innerHeight) * 2 + 1;

                // Try to select token
                if (
                  gameState.gameStarted &&
                  gameState.moveableTokens.length > 0
                ) {
                  raycaster.setFromCamera(mouse, camera);
                  const intersects = raycaster.intersectObjects(
                    gameState.moveableTokens
                  );
                  if (intersects.length > 0) {
                    const clickedToken = intersects[0].object;
                    moveToken(clickedToken);
                    gameState.moveableTokens = [];
                  }
                }
              }
            }
            isTouchDragging = false;
            touchStartDistance = 0;
          },
          { passive: false }
        );

        // Player selection buttons
        document.querySelectorAll(".player-count-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".player-count-btn")
              .forEach((b) => b.classList.remove("selected"));
            e.target.classList.add("selected");
            gameState.numPlayers = parseInt(e.target.dataset.count);
          });
        });

        // Game mode selection buttons
        document.querySelectorAll(".game-mode-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const button = e.target.closest(".game-mode-btn");
            document
              .querySelectorAll(".game-mode-btn")
              .forEach((b) => b.classList.remove("selected"));
            button.classList.add("selected");
            gameState.gameMode = button.dataset.mode;
          });
        });

        document
          .getElementById("start-game-btn")
          .addEventListener("click", startGame);

        // Start animation loop
        animate();
      }

      function createBoard() {
        // Main board base with black border effect
        const boardBaseGeometry = new THREE.BoxGeometry(15.5, 0.3, 15.5);
        const boardBaseMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.3,
          metalness: 0.5,
        });
        const boardBase = new THREE.Mesh(boardBaseGeometry, boardBaseMaterial);
        boardBase.position.y = -0.35;
        boardBase.receiveShadow = true;
        scene.add(boardBase);

        // Main board surface (cream/beige color)
        const boardGeometry = new THREE.BoxGeometry(15, 0.4, 15);
        const boardMaterial = new THREE.MeshStandardMaterial({
          color: 0xfdf6e3,
          roughness: 0.4,
          metalness: 0.1,
        });
        board = new THREE.Mesh(boardGeometry, boardMaterial);
        board.position.y = -0.15;
        board.receiveShadow = true;
        scene.add(board);

        // Create colored corners (home bases) with glassy effect
        const corners = [
          { color: CONFIG.COLORS.RED, x: -4.5, z: 4.5, rotation: 0 }, // Red - Top Left
          { color: CONFIG.COLORS.BLUE, x: 4.5, z: 4.5, rotation: Math.PI / 2 }, // Blue - Top Right
          { color: CONFIG.COLORS.YELLOW, x: 4.5, z: -4.5, rotation: Math.PI }, // Yellow - Bottom Right
          {
            color: CONFIG.COLORS.GREEN,
            x: -4.5,
            z: -4.5,
            rotation: -Math.PI / 2,
          }, // Green - Bottom Left
        ];

        corners.forEach((corner, idx) => {
          // Corner base with glassy material
          const cornerGeometry = new THREE.BoxGeometry(5.8, 0.5, 5.8);
          const cornerMaterial = new THREE.MeshStandardMaterial({
            color: corner.color,
            roughness: 0.2,
            metalness: 0.3,
            transparent: true,
            opacity: 0.95,
          });
          const cornerMesh = new THREE.Mesh(cornerGeometry, cornerMaterial);
          cornerMesh.position.set(corner.x, 0.05, corner.z);
          cornerMesh.receiveShadow = true;
          scene.add(cornerMesh);

          // Black border around corner
          const borderGeometry = new THREE.BoxGeometry(5.9, 0.52, 5.9);
          const borderMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000,
            roughness: 0.5,
          });
          const border = new THREE.Mesh(borderGeometry, borderMaterial);
          border.position.set(corner.x, 0.03, corner.z);
          scene.add(border);

          // Move colored part above border
          cornerMesh.position.y = 0.08;

          // Inner circle for token home area (lighter shade)
          const innerCircleGeometry = new THREE.CylinderGeometry(
            1.8,
            1.8,
            0.15,
            32
          );
          const lighterColor = new THREE.Color(corner.color);
          lighterColor.lerp(new THREE.Color(0xffffff), 0.3);
          const innerCircleMaterial = new THREE.MeshStandardMaterial({
            color: lighterColor,
            roughness: 0.3,
            metalness: 0.2,
          });
          const innerCircle = new THREE.Mesh(
            innerCircleGeometry,
            innerCircleMaterial
          );
          innerCircle.position.set(corner.x, 0.18, corner.z);
          scene.add(innerCircle);

          // Token holder circles (white circles for seeds)
          const holderPositions = [
            { x: -0.6, z: -0.6 },
            { x: 0.6, z: -0.6 },
            { x: -0.6, z: 0.6 },
            { x: 0.6, z: 0.6 },
          ];

          holderPositions.forEach((pos, i) => {
            // White circle holder
            const holderGeometry = new THREE.CylinderGeometry(
              0.35,
              0.35,
              0.08,
              32
            );
            const holderMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.3,
              metalness: 0.1,
            });
            const holder = new THREE.Mesh(holderGeometry, holderMaterial);
            holder.position.set(corner.x + pos.x, 0.28, corner.z + pos.z);
            scene.add(holder);
          });
        });

        // Create center finish area with trophy design
        createCenterArea();

        // Create path cells with proper grid
        createPathCells();

        // Create home path cells
        createHomePathCells();

        // Create starting point arrows
        createStartingArrows();
      }

      function createCenterArea() {
        // Center base (black)
        const centerBaseGeometry = new THREE.BoxGeometry(3.2, 0.3, 3.2);
        const centerBaseMaterial = new THREE.MeshStandardMaterial({
          color: 0x000000,
          roughness: 0.3,
        });
        const centerBase = new THREE.Mesh(
          centerBaseGeometry,
          centerBaseMaterial
        );
        centerBase.position.y = 0.05;
        scene.add(centerBase);

        // Center triangles for each player color
        const centerColors = [
          { color: CONFIG.COLORS.RED, rotation: Math.PI }, // Red - pointing down
          { color: CONFIG.COLORS.GREEN, rotation: -Math.PI / 2 }, // Green - pointing left
          { color: CONFIG.COLORS.YELLOW, rotation: 0 }, // Yellow - pointing up
          { color: CONFIG.COLORS.BLUE, rotation: Math.PI / 2 }, // Blue - pointing right
        ];

        centerColors.forEach((data, i) => {
          const triangleShape = new THREE.Shape();
          triangleShape.moveTo(0, 0);
          triangleShape.lineTo(1.4, 1.4);
          triangleShape.lineTo(-1.4, 1.4);
          triangleShape.closePath();

          const extrudeSettings = { depth: 0.15, bevelEnabled: false };
          const triangleGeometry = new THREE.ExtrudeGeometry(
            triangleShape,
            extrudeSettings
          );
          const triangleMaterial = new THREE.MeshStandardMaterial({
            color: data.color,
            roughness: 0.3,
            metalness: 0.2,
          });
          const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
          triangle.rotation.x = -Math.PI / 2;
          triangle.rotation.z = data.rotation;
          triangle.position.y = 0.2;
          scene.add(triangle);
        });

        // Trophy symbol in center (golden sphere)
        const trophyGeometry = new THREE.SphereGeometry(0.4, 32, 32);
        const trophyMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          roughness: 0.1,
          metalness: 0.8,
        });
        const trophy = new THREE.Mesh(trophyGeometry, trophyMaterial);
        trophy.position.set(0, 0.6, 0);
        scene.add(trophy);
      }

      function createStartingArrows() {
        // Arrow/triangle markers at starting positions
        // Positions from BOARD_PATH: Red=1, Blue=13, Yellow=25, Green=37
        const startMarkers = [
          { x: -5, z: 1, rotation: Math.PI / 2, color: CONFIG.COLORS.RED }, // Red start (pos 1) - {-5, 1}
          { x: 1, z: 5, rotation: Math.PI, color: CONFIG.COLORS.BLUE }, // Blue start (pos 13) - {1, 5}
          { x: 5, z: -1, rotation: -Math.PI / 2, color: CONFIG.COLORS.YELLOW }, // Yellow start (pos 25) - {5, -1}
          { x: -1, z: -5, rotation: 0, color: CONFIG.COLORS.GREEN }, // Green start (pos 37) - {-1, -5}
        ];

        startMarkers.forEach((marker) => {
          // Arrow shape
          const arrowShape = new THREE.Shape();
          arrowShape.moveTo(0, 0.3);
          arrowShape.lineTo(0.25, 0);
          arrowShape.lineTo(0.1, 0);
          arrowShape.lineTo(0.1, -0.3);
          arrowShape.lineTo(-0.1, -0.3);
          arrowShape.lineTo(-0.1, 0);
          arrowShape.lineTo(-0.25, 0);
          arrowShape.closePath();

          const extrudeSettings = { depth: 0.05, bevelEnabled: false };
          const arrowGeometry = new THREE.ExtrudeGeometry(
            arrowShape,
            extrudeSettings
          );
          const arrowMaterial = new THREE.MeshStandardMaterial({
            color: marker.color,
            roughness: 0.3,
          });
          const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
          arrow.rotation.x = -Math.PI / 2;
          arrow.rotation.z = marker.rotation;
          arrow.position.set(marker.x, 0.25, marker.z);
          scene.add(arrow);
        });
      }

      function createPathCells() {
        // Create cells with proper borders like the reference image
        const safeStarPositions = [8, 21, 34, 47]; // Star safe spots (not start positions)

        BOARD_PATH.forEach((pos, index) => {
          // Cell border (black)
          const borderGeometry = new THREE.BoxGeometry(0.95, 0.12, 0.95);
          const borderMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.5,
          });
          const border = new THREE.Mesh(borderGeometry, borderMaterial);
          border.position.set(pos.x, 0.06, pos.z);
          scene.add(border);

          // Cell surface
          const cellGeometry = new THREE.BoxGeometry(0.85, 0.14, 0.85);
          let cellColor = 0xffffff; // Default white
          let isStartPosition = false;

          // Color start positions - must match START_POSITIONS array
          // Red=1, Blue=13, Yellow=25, Green=37
          if (index === 1) {
            cellColor = CONFIG.COLORS.RED;
            isStartPosition = true;
          } else if (index === 13) {
            cellColor = CONFIG.COLORS.BLUE;
            isStartPosition = true;
          } else if (index === 25) {
            cellColor = CONFIG.COLORS.YELLOW;
            isStartPosition = true;
          } else if (index === 37) {
            cellColor = CONFIG.COLORS.GREEN;
            isStartPosition = true;
          }

          const cellMaterial = new THREE.MeshStandardMaterial({
            color: cellColor,
            roughness: 0.4,
            metalness: 0.1,
          });
          const cell = new THREE.Mesh(cellGeometry, cellMaterial);
          cell.position.set(pos.x, 0.08, pos.z);
          cell.receiveShadow = true;
          scene.add(cell);

          // Add star markers on safe spots
          if (safeStarPositions.includes(index)) {
            createStarMarker(pos.x, pos.z, 0x333333);
          }
        });
      }

      function createStarMarker(x, z, color) {
        // Create a simple star shape
        const starShape = new THREE.Shape();
        const outerRadius = 0.25;
        const innerRadius = 0.1;
        const points = 5;

        for (let i = 0; i < points * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const px = Math.cos(angle) * radius;
          const py = Math.sin(angle) * radius;
          if (i === 0) starShape.moveTo(px, py);
          else starShape.lineTo(px, py);
        }
        starShape.closePath();

        const extrudeSettings = { depth: 0.02, bevelEnabled: false };
        const starGeometry = new THREE.ExtrudeGeometry(
          starShape,
          extrudeSettings
        );
        const starMaterial = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.5,
        });
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.rotation.x = -Math.PI / 2;
        star.position.set(x, 0.18, z);
        scene.add(star);
      }

      function createHomePathCells() {
        const colors = [
          CONFIG.COLORS.RED,
          CONFIG.COLORS.GREEN,
          CONFIG.COLORS.YELLOW,
          CONFIG.COLORS.BLUE,
        ];

        Object.keys(HOME_PATHS).forEach((playerIndex) => {
          const path = HOME_PATHS[playerIndex];
          const playerColor = colors[playerIndex];

          path.forEach((pos, i) => {
            // Border
            const borderGeometry = new THREE.BoxGeometry(0.95, 0.12, 0.95);
            const borderMaterial = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.5,
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.set(pos.x, 0.06, pos.z);
            scene.add(border);

            // Colored cell
            const cellGeometry = new THREE.BoxGeometry(0.85, 0.14, 0.85);
            const cellMaterial = new THREE.MeshStandardMaterial({
              color: playerColor,
              roughness: 0.3,
              metalness: 0.2,
            });
            const cell = new THREE.Mesh(cellGeometry, cellMaterial);
            cell.position.set(pos.x, 0.08, pos.z);
            cell.receiveShadow = true;
            scene.add(cell);

            // Add small star/arrow on last cell pointing to center
            if (i === path.length - 1) {
              createStarMarker(pos.x, pos.z, 0xffffff);
            }
          });
        });
      }

      function createTokens() {
        // Clear existing tokens
        tokenMeshes.forEach((token) => scene.remove(token));
        tokenMeshes = [];
        gameState.tokens = [];

        const colors = [
          CONFIG.COLORS.RED,
          CONFIG.COLORS.GREEN,
          CONFIG.COLORS.YELLOW,
          CONFIG.COLORS.BLUE,
        ];
        const playerCount = gameState.numPlayers;
        const activePlayerIndices = playerCount === 2 ? [0, 2] : [0, 1, 2, 3];

        activePlayerIndices.forEach((playerIndex) => {
          for (
            let tokenIndex = 0;
            tokenIndex < CONFIG.TOKENS_PER_PLAYER;
            tokenIndex++
          ) {
            // Create spherical seed token with glassy appearance
            const tokenGeometry = new THREE.SphereGeometry(
              CONFIG.TOKEN_RADIUS,
              32,
              32
            );
            const tokenMaterial = new THREE.MeshStandardMaterial({
              color: colors[playerIndex],
              roughness: 0.15,
              metalness: 0.6,
              transparent: true,
              opacity: 0.95,
            });

            const token = new THREE.Mesh(tokenGeometry, tokenMaterial);
            token.castShadow = true;

            // Add a highlight ring around the seed for better visibility
            const ringGeometry = new THREE.TorusGeometry(
              CONFIG.TOKEN_RADIUS * 0.8,
              0.03,
              8,
              32
            );
            const ringMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.2,
              metalness: 0.8,
              transparent: true,
              opacity: 0.5,
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -CONFIG.TOKEN_RADIUS * 0.3;
            token.add(ring);

            // Position in base
            const basePos = BASE_POSITIONS[playerIndex][tokenIndex];
            token.position.set(basePos.x, 0.5, basePos.z);

            // Store token data
            token.userData = {
              playerIndex: playerIndex,
              tokenIndex: tokenIndex,
              state: "base", // 'base', 'active', 'home', 'finished'
              pathPosition: -1, // Current position on the 52-cell board path (-1 = in base)
              homePosition: -1, // Position in home path (0-5, -1 = not in home path)
              distanceTraveled: 0, // Total cells moved since leaving base (for lap tracking)
            };

            scene.add(token);
            tokenMeshes.push(token);
            gameState.tokens.push(token);
          }
        });
      }

      function startGame() {
        document.getElementById("start-screen").style.display = "none";
        document.getElementById("gameContainer").classList.add("active");
        gameState.gameStarted = true;

        // Initialize players
        const playerCount = gameState.numPlayers;
        const activePlayerIndices = playerCount === 2 ? [0, 2] : [0, 1, 2, 3];

        // Determine which players are AI based on game mode
        const aiPlayerIndices = [];
        if (gameState.gameMode === "ai1") {
          // 1 AI: In 2-player mode, opponent is AI. In 4-player, last player is AI.
          if (playerCount === 2) {
            aiPlayerIndices.push(2); // Yellow (opponent)
          } else {
            aiPlayerIndices.push(3); // Blue
          }
        } else if (gameState.gameMode === "ai3") {
          // 3 AI: All except first player (Red) are AI
          aiPlayerIndices.push(1, 2, 3); // Green, Yellow, Blue
        }

        gameState.players = activePlayerIndices.map((index) => ({
          index: index,
          name: CONFIG.PLAYER_NAMES[index],
          color: Object.values(CONFIG.COLORS)[index],
          tokensHome: 0,
          isAI: aiPlayerIndices.includes(index),
        }));

        // Create tokens
        createTokens();

        // Update UI
        updatePlayerPanel();
        updateGameMessage(
          `${
            CONFIG.PLAYER_NAMES[gameState.players[0].index]
          }'s turn - Roll the dice!`
        );

        gameState.currentPlayer = 0;
        gameState.canRoll = true;
      }

      function updatePlayerPanel() {
        const playersList = document.getElementById("players-list");
        playersList.innerHTML = "";

        gameState.players.forEach((player, index) => {
          const colorHex = "#" + player.color.toString(16).padStart(6, "0");
          const isActive = index === gameState.currentPlayer;
          const aiLabel = player.isAI ? " ü§ñ" : "";

          const playerDiv = document.createElement("div");
          playerDiv.className = `player-info ${isActive ? "active" : ""}`;
          playerDiv.innerHTML = `
                    <div class="player-color" style="background-color: ${colorHex}; box-shadow: 0 0 10px ${colorHex}"></div>
                    <div>
                        <div class="player-name">${player.name}${aiLabel}</div>
                        <div class="player-home">Home: ${player.tokensHome}/4</div>
                    </div>
                `;
          playersList.appendChild(playerDiv);
        });
      }

      function updateGameMessage(message) {
        document.getElementById("game-message").textContent = message;
      }

      function rollDice() {
        if (!gameState.canRoll || !gameState.gameStarted) return;

        gameState.canRoll = false;
        document.getElementById("roll-btn").disabled = true;

        // Dice animation
        const diceDisplay = document.getElementById("dice-display");
        let rolls = 0;
        const animationInterval = setInterval(() => {
          diceDisplay.textContent = ["‚öÄ", "‚öÅ", "‚öÇ", "‚öÉ", "‚öÑ", "‚öÖ"][
            Math.floor(Math.random() * 6)
          ];
          rolls++;
          if (rolls > 10) {
            clearInterval(animationInterval);

            // Final dice value
            gameState.diceValue = Math.floor(Math.random() * 6) + 1;
            diceDisplay.textContent = ["‚öÄ", "‚öÅ", "‚öÇ", "‚öÉ", "‚öÑ", "‚öÖ"][
              gameState.diceValue - 1
            ];

            // Check for possible moves
            checkPossibleMoves();
          }
        }, 100);
      }

      function checkPossibleMoves() {
        const currentPlayerIndex =
          gameState.players[gameState.currentPlayer].index;
        const playerTokens = gameState.tokens.filter(
          (t) => t.userData.playerIndex === currentPlayerIndex
        );

        gameState.moveableTokens = [];

        playerTokens.forEach((token) => {
          if (canTokenMove(token)) {
            gameState.moveableTokens.push(token);
          }
        });

        if (gameState.moveableTokens.length === 0) {
          updateGameMessage(
            `No valid moves. ${
              gameState.diceValue === 6 ? "Roll again!" : "Next player!"
            }`
          );

          if (gameState.diceValue === 6) {
            gameState.canRoll = true;
            document.getElementById("roll-btn").disabled = false;
            // If AI, trigger another roll
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (currentPlayer.isAI) {
              setTimeout(() => aiTurn(), 800);
            }
          } else {
            setTimeout(nextTurn, 1500);
          }
        } else if (gameState.moveableTokens.length === 1) {
          // Auto-move if only one option
          moveToken(gameState.moveableTokens[0]);
        } else {
          // Multiple options available
          const currentPlayer = gameState.players[gameState.currentPlayer];

          if (currentPlayer.isAI) {
            // AI selects the best move
            const selectedToken = aiSelectMove();
            setTimeout(() => {
              moveToken(selectedToken);
            }, 600);
          } else {
            // Human player - highlight and wait for click
            highlightMoveableTokens();
            updateGameMessage(
              `Click a token to move (rolled ${gameState.diceValue})`
            );
          }
        }
      }

      function canTokenMove(token) {
        const dice = gameState.diceValue;
        const state = token.userData.state;
        const playerIndex = token.userData.playerIndex;

        if (state === "base") {
          // Need a 6 to leave base
          return dice === 6;
        } else if (state === "finished") {
          // Already at home center - can't move
          return false;
        } else if (state === "home") {
          // In home path - check if can advance toward center
          const currentHomePos = token.userData.homePosition;
          const newHomePos = currentHomePos + dice;
          // Home path has 6 positions (0-5), need exact roll to finish
          // Position 5 is the last cell, rolling to 6 means reaching center
          return newHomePos <= 6; // Can move if won't overshoot
        } else {
          // state === "active" - on the main board
          const distanceTraveled = token.userData.distanceTraveled;
          const distanceAfterMove = distanceTraveled + dice;

          // All players need to travel 51 cells to reach their home entry
          // Red starts at 0, enters at 51; Green starts at 39, enters at 38
          // Yellow starts at 26, enters at 25; Blue starts at 13, enters at 12
          const distanceToHomeEntry = 51;

          // Total distance to finish: distanceToHomeEntry + 6 (home path cells) + 1 (to center)
          const totalDistanceToFinish = distanceToHomeEntry + 7;

          if (distanceAfterMove <= distanceToHomeEntry) {
            // Still on main board - always valid
            return true;
          } else if (distanceAfterMove <= totalDistanceToFinish) {
            // Entering or advancing in home path - valid
            return true;
          } else {
            // Would overshoot center - need exact roll
            return false;
          }
        }
      }

      function highlightMoveableTokens() {
        // Add glow effect to moveable tokens - pulsing animation
        gameState.moveableTokens.forEach((token) => {
          token.material.emissive = new THREE.Color(0xffffff);
          token.material.emissiveIntensity = 0.7;
          // Add a slight scale up for visibility
          token.scale.set(1.2, 1.2, 1.2);
        });
      }

      function clearHighlights() {
        gameState.tokens.forEach((token) => {
          token.material.emissive = new THREE.Color(0x000000);
          token.material.emissiveIntensity = 0;
          token.scale.set(1, 1, 1);
        });
      }

      function moveToken(token) {
        clearHighlights();

        const dice = gameState.diceValue;
        const state = token.userData.state;
        const playerIndex = token.userData.playerIndex;
        const startPos = START_POSITIONS[playerIndex];

        if (state === "base" && dice === 6) {
          // Move out of base to start position
          token.userData.state = "active";
          token.userData.pathPosition = startPos;
          token.userData.distanceTraveled = 0; // Just started, 0 cells traveled

          const newPos = BOARD_PATH[startPos];
          animateTokenMove(token, newPos.x, newPos.z);

          // Check for capture at start position
          checkCapture(token, startPos);

          updateGameMessage(
            `${CONFIG.PLAYER_NAMES[playerIndex]} token enters the board!`
          );

          // Get another turn for rolling 6
          setTimeout(() => {
            gameState.canRoll = true;
            document.getElementById("roll-btn").disabled = false;
            updateGameMessage(
              `${CONFIG.PLAYER_NAMES[playerIndex]} rolled 6! Roll again!`
            );
            // Trigger AI turn if current player is AI
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (currentPlayer.isAI) {
              setTimeout(() => aiTurn(), 800);
            }
          }, 500);
        } else if (state === "home") {
          // Already in home path - advance toward center
          const currentHomePos = token.userData.homePosition;
          const newHomePos = currentHomePos + dice;

          if (newHomePos >= 6) {
            // Reached the center - FINISHED!
            token.userData.state = "finished";
            token.userData.homePosition = 6;

            // Move to center with stacking
            animateTokenMove(token, 0, 0, () => {
              const finishedCount = gameState.tokens.filter(
                (t) =>
                  t.userData.playerIndex === playerIndex &&
                  t.userData.state === "finished"
              ).length;
              token.position.y = 0.8 + (finishedCount - 1) * 0.6;
            });

            // Update player score
            const player = gameState.players.find(
              (p) => p.index === playerIndex
            );
            player.tokensHome++;
            updatePlayerPanel();

            updateGameMessage(
              `${CONFIG.PLAYER_NAMES[playerIndex]} got a token HOME! üè†`
            );

            // Check for winner
            if (player.tokensHome === 4) {
              setTimeout(() => showWinner(player), 1000);
              return;
            }
          } else {
            // Move within home path
            token.userData.homePosition = newHomePos;
            const homePos = HOME_PATHS[playerIndex][newHomePos];
            animateTokenMove(token, homePos.x, homePos.z);

            updateGameMessage(
              `${CONFIG.PLAYER_NAMES[playerIndex]} advances in home path!`
            );
          }

          // Extra turn for rolling 6
          if (dice === 6) {
            setTimeout(() => {
              gameState.canRoll = true;
              document.getElementById("roll-btn").disabled = false;
              updateGameMessage(
                `${CONFIG.PLAYER_NAMES[playerIndex]} rolled 6! Roll again!`
              );
              // Trigger AI turn if current player is AI
              const currentPlayer = gameState.players[gameState.currentPlayer];
              if (currentPlayer.isAI) {
                setTimeout(() => aiTurn(), 800);
              }
            }, 500);
          } else {
            setTimeout(nextTurn, 500);
          }
        } else if (state === "active") {
          // On the main board - move forward
          const currentDistanceTraveled = token.userData.distanceTraveled;
          const distanceAfterMove = currentDistanceTraveled + dice;

          // All players need 51 steps to reach home entry
          const distanceToHomeEntry = 51;

          if (distanceAfterMove <= distanceToHomeEntry) {
            // Still on main board after move
            const currentPathPos = token.userData.pathPosition;
            const newPathPos = (currentPathPos + dice) % 52;

            token.userData.pathPosition = newPathPos;
            token.userData.distanceTraveled = distanceAfterMove;

            const newPos = BOARD_PATH[newPathPos];
            animateTokenMove(token, newPos.x, newPos.z);

            // Check for capture
            checkCapture(token, newPathPos);

            updateGameMessage(
              `${CONFIG.PLAYER_NAMES[playerIndex]} moves ${dice} steps`
            );
          } else {
            // Entering home path!
            // Calculate home path position based on distance past home entry
            // Home path has 6 cells (indices 0-5)
            const stepsIntoHomePath = distanceAfterMove - distanceToHomeEntry;
            const homePathPos = stepsIntoHomePath - 1; // -1 because first step into home is position 0

            if (homePathPos >= 6) {
              // Reached the center - FINISHED! (exact roll required, but canTokenMove should prevent overshoot)
              token.userData.state = "finished";
              token.userData.homePosition = 6;
              token.userData.pathPosition = -1;
              token.userData.distanceTraveled = distanceAfterMove;

              animateTokenMove(token, 0, 0, () => {
                const finishedCount = gameState.tokens.filter(
                  (t) =>
                    t.userData.playerIndex === playerIndex &&
                    t.userData.state === "finished"
                ).length;
                token.position.y = 0.8 + (finishedCount - 1) * 0.6;
              });

              const player = gameState.players.find(
                (p) => p.index === playerIndex
              );
              player.tokensHome++;
              updatePlayerPanel();

              updateGameMessage(
                `${CONFIG.PLAYER_NAMES[playerIndex]} got a token HOME! üè†`
              );

              if (player.tokensHome === 4) {
                setTimeout(() => showWinner(player), 1000);
                return;
              }
            } else if (homePathPos >= 0) {
              // Enter home path at specific position
              token.userData.state = "home";
              token.userData.homePosition = homePathPos;
              token.userData.pathPosition = -1;
              token.userData.distanceTraveled = distanceAfterMove;

              const homePos = HOME_PATHS[playerIndex][homePathPos];
              animateTokenMove(token, homePos.x, homePos.z);

              updateGameMessage(
                `${CONFIG.PLAYER_NAMES[playerIndex]} enters home path!`
              );
            } else {
              // homePathPos < 0 means we're still approaching home entry (shouldn't happen)
              // Fallback to regular board move
              const currentPathPos = token.userData.pathPosition;
              const newPathPos = (currentPathPos + dice) % 52;

              token.userData.pathPosition = newPathPos;
              token.userData.distanceTraveled = distanceAfterMove;

              const newPos = BOARD_PATH[newPathPos];
              animateTokenMove(token, newPos.x, newPos.z);
              checkCapture(token, newPathPos);
            }
          }

          // Extra turn for rolling 6
          if (dice === 6) {
            setTimeout(() => {
              gameState.canRoll = true;
              document.getElementById("roll-btn").disabled = false;
              updateGameMessage(
                `${CONFIG.PLAYER_NAMES[playerIndex]} rolled 6! Roll again!`
              );
              // Trigger AI turn if current player is AI
              const currentPlayer = gameState.players[gameState.currentPlayer];
              if (currentPlayer.isAI) {
                setTimeout(() => aiTurn(), 800);
              }
            }, 500);
          } else {
            setTimeout(nextTurn, 500);
          }
        }

        updatePlayerPanel();
      }

      function animateTokenMove(token, targetX, targetZ, callback) {
        const startPos = { x: token.position.x, z: token.position.z };
        const duration = 300;
        const startTime = Date.now();
        const baseHeight = 0.5; // Height for spherical seeds

        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Ease out cubic
          const eased = 1 - Math.pow(1 - progress, 3);

          token.position.x = startPos.x + (targetX - startPos.x) * eased;
          token.position.z = startPos.z + (targetZ - startPos.z) * eased;

          // Add a hop effect for seeds
          token.position.y = baseHeight + Math.sin(progress * Math.PI) * 0.6;

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            token.position.y = baseHeight;
            if (callback) callback();
          }
        }

        animate();
      }

      function checkCapture(movingToken, pathPosition) {
        const movingPlayerIndex = movingToken.userData.playerIndex;

        // Safe positions: start positions (1, 13, 25, 37) and star safe spots (8, 21, 34, 47)
        const safePositions = [1, 8, 13, 21, 25, 34, 37, 47];
        if (safePositions.includes(pathPosition)) return;

        gameState.tokens.forEach((token) => {
          if (token === movingToken) return;
          if (token.userData.playerIndex === movingPlayerIndex) return;
          if (token.userData.state !== "active") return;
          if (token.userData.pathPosition !== pathPosition) return;

          // Capture! Send opponent back to base
          token.userData.state = "base";
          token.userData.pathPosition = -1;
          token.userData.homePosition = -1;
          token.userData.distanceTraveled = 0;

          const basePos =
            BASE_POSITIONS[token.userData.playerIndex][
              token.userData.tokenIndex
            ];
          animateTokenMove(token, basePos.x, basePos.z);

          // CAPTURE = WIN: The capturing token finishes (wins) immediately!
          movingToken.userData.state = "finished";
          movingToken.userData.pathPosition = -1;
          movingToken.userData.homePosition = -1;

          // Move capturing token to center (trophy area) to show it won
          animateTokenMove(movingToken, 0, 0);
          movingToken.visible = false; // Hide the token after capture win

          // Increment tokens home for the capturing player
          const capturingPlayer = gameState.players[movingPlayerIndex];
          capturingPlayer.tokensHome++;

          updateGameMessage(
            `${CONFIG.PLAYER_NAMES[movingPlayerIndex]} captured ${
              CONFIG.PLAYER_NAMES[token.userData.playerIndex]
            }'s token and WINS that seed! (${capturingPlayer.tokensHome}/4)`
          );

          // Check for overall winner
          if (capturingPlayer.tokensHome >= 4) {
            setTimeout(() => showWinner(capturingPlayer), 500);
          }
        });
      }

      function nextTurn() {
        gameState.currentPlayer =
          (gameState.currentPlayer + 1) % gameState.players.length;
        const currentPlayer = gameState.players[gameState.currentPlayer];

        gameState.canRoll = true;
        document.getElementById("roll-btn").disabled = false;

        updatePlayerPanel();
        updateGameMessage(
          `${CONFIG.PLAYER_NAMES[currentPlayer.index]}'s turn - Roll the dice!`
        );

        // If current player is AI, trigger AI turn after a short delay
        if (currentPlayer.isAI) {
          document.getElementById("roll-btn").disabled = true;
          setTimeout(() => aiTurn(), 800);
        }
      }

      // ==================== AI LOGIC ====================
      function aiTurn() {
        const currentPlayer = gameState.players[gameState.currentPlayer];
        if (!currentPlayer.isAI) return;

        updateGameMessage(
          `${CONFIG.PLAYER_NAMES[currentPlayer.index]} ü§ñ is thinking...`
        );

        // AI rolls dice after a short delay
        setTimeout(() => {
          rollDice();
        }, 500);
      }

      function aiSelectMove() {
        // Called after dice roll when AI has multiple token options
        const currentPlayer = gameState.players[gameState.currentPlayer];
        if (!currentPlayer.isAI || gameState.moveableTokens.length === 0)
          return null;

        const tokens = gameState.moveableTokens;
        const dice = gameState.diceValue;

        // Score each possible move
        let bestToken = tokens[0];
        let bestScore = -Infinity;

        tokens.forEach((token) => {
          let score = 0;
          const state = token.userData.state;
          const playerIndex = token.userData.playerIndex;

          // Priority 1: Get tokens out of base with a 6
          if (state === "base" && dice === 6) {
            score += 100;
          }

          // Priority 2: Capture opportunity
          if (state === "active") {
            const currentPos = token.userData.pathPosition;
            const newPos = (currentPos + dice) % 52;

            // Check if we can capture an opponent
            const canCapture = gameState.tokens.some(
              (t) =>
                t.userData.playerIndex !== playerIndex &&
                t.userData.state === "active" &&
                t.userData.pathPosition === newPos &&
                !isSafePosition(newPos)
            );

            if (canCapture) {
              score += 200; // Highest priority - capture wins the token!
            }

            // Priority 3: Move toward home
            const distanceAfterMove = token.userData.distanceTraveled + dice;
            if (distanceAfterMove > 40) {
              score += 50; // Close to home entry
            }

            // Priority 4: Avoid danger - check if current position is unsafe
            const isCurrentlyExposed = isTokenExposed(token);
            if (isCurrentlyExposed) {
              score += 30; // Move exposed tokens
            }

            // Priority 5: Land on safe position
            if (isSafePosition(newPos)) {
              score += 20;
            }
          }

          // Priority 6: Advance in home path
          if (state === "home") {
            const newHomePos = token.userData.homePosition + dice;
            if (newHomePos >= 6) {
              score += 150; // Can reach center - very high priority
            } else {
              score += 40; // Advancing in home is good
            }
          }

          // Add small randomness to make AI less predictable
          score += Math.random() * 10;

          if (score > bestScore) {
            bestScore = score;
            bestToken = token;
          }
        });

        return bestToken;
      }

      function isSafePosition(position) {
        // Safe positions: starting positions and star cells
        const safePositions = [0, 8, 13, 21, 26, 34, 39, 47];
        return safePositions.includes(position);
      }

      function isTokenExposed(token) {
        // Check if any opponent token could potentially capture this token
        const position = token.userData.pathPosition;
        const playerIndex = token.userData.playerIndex;

        if (isSafePosition(position)) return false;

        // Check if any opponent is within 6 cells behind
        return gameState.tokens.some((t) => {
          if (t.userData.playerIndex === playerIndex) return false;
          if (t.userData.state !== "active") return false;

          const opponentPos = t.userData.pathPosition;
          // Check if opponent is 1-6 cells behind (could reach us with a roll)
          for (let i = 1; i <= 6; i++) {
            if ((opponentPos + i) % 52 === position) return true;
          }
          return false;
        });
      }

      function showWinner(player) {
        const colorHex = "#" + player.color.toString(16).padStart(6, "0");
        document.getElementById("winner-text").style.color = colorHex;
        document.getElementById(
          "winner-name"
        ).textContent = `${player.name} Player Wins!`;
        document.getElementById("winner-screen").classList.add("show");
      }

      function resetGame() {
        // Hide screens
        document.getElementById("winner-screen").classList.remove("show");
        document.getElementById("start-screen").style.display = "flex";
        document.getElementById("gameContainer").classList.remove("active");

        // Reset game state
        gameState = {
          numPlayers: 4,
          currentPlayer: 0,
          diceValue: 0,
          canRoll: true,
          selectedToken: null,
          players: [],
          tokens: [],
          gameStarted: false,
          extraTurn: false,
          moveableTokens: [],
          gameMode: "pvp",
        };

        // Clear tokens
        tokenMeshes.forEach((token) => scene.remove(token));
        tokenMeshes = [];

        // Reset dice display
        document.getElementById("dice-display").textContent = "üé≤";
        document.getElementById("roll-btn").disabled = false;

        // Reset UI selections
        document
          .querySelectorAll(".player-count-btn")
          .forEach((b) => b.classList.remove("selected"));
        document
          .querySelector('.player-count-btn[data-count="4"]')
          .classList.add("selected");
        document
          .querySelectorAll(".game-mode-btn")
          .forEach((b) => b.classList.remove("selected"));
        document
          .querySelector('.game-mode-btn[data-mode="pvp"]')
          .classList.add("selected");
      }

      function showHowToPlay() {
        document.getElementById("how-to-play-modal").classList.add("show");
      }

      function closeHowToPlay() {
        document.getElementById("how-to-play-modal").classList.remove("show");
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onMouseClick(event) {
        if (!gameState.gameStarted) return;
        if (gameState.moveableTokens.length === 0) return;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(gameState.moveableTokens);

        if (intersects.length > 0) {
          const clickedToken = intersects[0].object;
          moveToken(clickedToken);
          gameState.moveableTokens = [];
        }
      }

      function onTouchTap(event) {
        if (!gameState.gameStarted) return;
        if (gameState.moveableTokens.length === 0) return;
        if (event.changedTouches.length === 0) return;

        const touch = event.changedTouches[0];
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(gameState.moveableTokens);

        if (intersects.length > 0) {
          const clickedToken = intersects[0].object;
          moveToken(clickedToken);
          gameState.moveableTokens = [];
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // Initialize the game
      init();
    </script>
  </body>
</html>
