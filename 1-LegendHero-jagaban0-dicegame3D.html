<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Ludo Game - Ultimate Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Fallback OrbitControls if CDN fails (non-module, r128 style)
        if (typeof THREE !== 'undefined' && !THREE.OrbitControls) {
            THREE.OrbitControls = function (object, domElement) {
                this.object = object;
                this.domElement = domElement || document;
                this.domElement.style.touchAction = 'none';
                this.enabled = true;
                this.target = new THREE.Vector3();
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.enablePan = true;
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.rotateSpeed = 0.45;
                let state = 'none';
                const EPS = 1e-6;
                const spherical = new THREE.Spherical();
                const sphericalDelta = new THREE.Spherical();
                const panOffset = new THREE.Vector3();
                let scale = 1;
                const quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                const quatInverse = quat.clone().invert();
                const rotateStart = new THREE.Vector2();
                const rotateEnd = new THREE.Vector2();
                const rotateDelta = new THREE.Vector2();
                const panStart = new THREE.Vector2();
                const panEnd = new THREE.Vector2();
                const panDelta = new THREE.Vector2();
                const dollyStart = new THREE.Vector2();
                const dollyEnd = new THREE.Vector2();
                const dollyDelta = new THREE.Vector2();

                const scope = this;
                function getPolarAngle() { return spherical.phi; }

                this.getPolarAngle = getPolarAngle;

                this.update = function () {
                    const offset = new THREE.Vector3();
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    offset.applyQuaternion(quat);
                    spherical.setFromVector3(offset);
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                    spherical.phi = Math.max(EPS, Math.min(Math.PI - EPS, spherical.phi));
                    spherical.makeSafe();
                    spherical.radius *= scale;
                    spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                    scope.target.add(panOffset);
                    offset.setFromSpherical(spherical);
                    offset.applyQuaternion(quatInverse);
                    position.copy(scope.target).add(offset);
                    scope.object.lookAt(scope.target);
                    if (scope.enableDamping) {
                        sphericalDelta.theta *= 1 - scope.dampingFactor;
                        sphericalDelta.phi *= 1 - scope.dampingFactor;
                        panOffset.multiplyScalar(1 - scope.dampingFactor);
                    } else {
                        sphericalDelta.set(0, 0, 0);
                        panOffset.set(0, 0, 0);
                    }
                    scale = 1;
                };

                function handleMouseDownRotate(event) {
                    rotateStart.set(event.clientX, event.clientY);
                }
                function handleMouseDownPan(event) {
                    panStart.set(event.clientX, event.clientY);
                }
                function handleMouseDownDolly(event) {
                    dollyStart.set(event.clientX, event.clientY);
                }
                function handleMouseMoveRotate(event) {
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart);
                    const element = scope.domElement;
                    sphericalDelta.theta -= (2 * Math.PI * rotateDelta.x / element.clientHeight) * scope.rotateSpeed;
                    sphericalDelta.phi -= (2 * Math.PI * rotateDelta.y / element.clientHeight) * scope.rotateSpeed;
                    rotateStart.copy(rotateEnd);
                }
                function handleMouseMovePan(event) {
                    panEnd.set(event.clientX, event.clientY);
                    panDelta.subVectors(panEnd, panStart);
                    pan(panDelta.x, panDelta.y);
                    panStart.copy(panEnd);
                }
                function handleMouseMoveDolly(event) {
                    dollyEnd.set(event.clientX, event.clientY);
                    dollyDelta.subVectors(dollyEnd, dollyStart);
                    const dollyScale = Math.pow(0.95, dollyDelta.y * 0.1);
                    scale *= dollyScale;
                    dollyStart.copy(dollyEnd);
                }
                function handleMouseUp() { state = 'none'; }

                function onMouseDown(event) {
                    if (scope.enabled === false) return;
                    if (event.button === 0) {
                        state = 'rotate'; handleMouseDownRotate(event);
                    } else if (event.button === 1 || event.button === 2) {
                        state = 'dolly'; handleMouseDownDolly(event);
                    }
                    scope.domElement.addEventListener('mousemove', onMouseMove, false);
                    scope.domElement.addEventListener('mouseup', onMouseUp, false);
                }
                function onMouseMove(event) {
                    if (scope.enabled === false) return;
                    if (state === 'rotate') handleMouseMoveRotate(event);
                    else if (state === 'dolly') handleMouseMoveDolly(event);
                }
                function onMouseUp(event) {
                    scope.domElement.removeEventListener('mousemove', onMouseMove, false);
                    scope.domElement.removeEventListener('mouseup', onMouseUp, false);
                    handleMouseUp(event);
                }
                function onMouseWheel(event) {
                    if (scope.enabled === false || !scope.enablePan) return;
                    if (event.deltaY < 0) scale /= 0.95; else scale *= 0.95;
                }
                function pan(deltaX, deltaY) {
                    const offset = new THREE.Vector3();
                    const element = scope.domElement;
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    let targetDistance = offset.length();
                    targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);
                    panOffset.add(new THREE.Vector3(-2 * deltaX * targetDistance / element.clientHeight, 2 * deltaY * targetDistance / element.clientHeight, 0));
                }
                function onContextMenu(event) { event.preventDefault(); }
                this.domElement.addEventListener('contextmenu', onContextMenu, false);
                this.domElement.addEventListener('mousedown', onMouseDown, false);
                this.domElement.addEventListener('wheel', onMouseWheel, false);

                // Touch support (iOS Safari)
                let touchDistanceStart = 0;
                function getTouchDistance(touches) {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                function onTouchStart(event) {
                    if (scope.enabled === false) return;
                    if (event.cancelable) event.preventDefault();
                    if (event.touches.length === 1) {
                        state = 'rotate';
                        rotateStart.set(event.touches[0].clientX, event.touches[0].clientY);
                    } else if (event.touches.length === 2) {
                        state = 'dolly';
                        touchDistanceStart = getTouchDistance(event.touches);
                    }
                }
                function onTouchMove(event) {
                    if (scope.enabled === false) return;
                    if (event.cancelable) event.preventDefault();
                    if (state === 'rotate' && event.touches.length === 1) {
                        handleMouseMoveRotate(event.touches[0]);
                    } else if (state === 'dolly' && event.touches.length === 2) {
                        const dist = getTouchDistance(event.touches);
                        if (touchDistanceStart > 0) {
                            const delta = dist - touchDistanceStart;
                            const dollyScale = Math.pow(0.95, -delta * 0.02);
                            scale *= dollyScale;
                        }
                        touchDistanceStart = dist;
                    }
                }
                function onTouchEnd(event) {
                    if (event.cancelable) event.preventDefault();
                    state = 'none';
                    touchDistanceStart = 0;
                }
                this.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                this.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                this.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                this.domElement.addEventListener('touchcancel', onTouchEnd, { passive: false });
            };
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        #gameCanvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Header */
        #header {
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
        }

        .game-title {
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
            letter-spacing: 2px;
        }

        .game-title span {
            background: linear-gradient(45deg, #f39c12, #e74c3c, #9b59b6, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Player Panel - Cleaner Design */
        #playerPanel {
            top: 70px;
            left: 20px;
            width: 180px;
        }

        /* Start menu: 2-player full mode layout (owners grouped in columns) */
        @media (min-width: 769px) {
            #startMenu .player-setup.two-player-full {
                grid-template-columns: 1fr 1fr;
                grid-template-areas:
                    "red blue"
                    "green yellow";
            }

            #startMenu .player-setup.two-player-full .player-option.red { grid-area: red; }
            #startMenu .player-setup.two-player-full .player-option.green { grid-area: green; }
            #startMenu .player-setup.two-player-full .player-option.blue { grid-area: blue; }
            #startMenu .player-setup.two-player-full .player-option.yellow { grid-area: yellow; }
        }

        .player-card-wrapper {
            margin-bottom: 12px;
        }

        .player-card-label {
            color: #fff;
            font-size: 14px;
            font-weight: 800;
            margin-bottom: 4px;
            padding: 0 4px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 0.5px;
        }

        .player-card {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 10px 12px;
            margin-bottom: 0;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-card.active {
            transform: translateX(5px);
            box-shadow: 0 0 25px rgba(255,255,255,0.2);
        }

        .player-card.red { border-color: rgba(231,76,60,0.4); }
        .player-card.red.active {
            background: rgba(231,76,60,0.15);
            border-color: #e74c3c;
            box-shadow: 0 0 20px rgba(231,76,60,0.4);
        }
        .player-card.green { border-color: rgba(46,204,113,0.4); }
        .player-card.green.active {
            background: rgba(46,204,113,0.15);
            border-color: #2ecc71;
            box-shadow: 0 0 20px rgba(46,204,113,0.4);
        }
        .player-card.yellow { border-color: rgba(241,196,15,0.4); }
        .player-card.yellow.active {
            background: rgba(241,196,15,0.15);
            border-color: #f1c40f;
            box-shadow: 0 0 20px rgba(241,196,15,0.4);
        }
        .player-card.blue { border-color: rgba(52,152,219,0.4); }
        .player-card.blue.active {
            background: rgba(52,152,219,0.15);
            border-color: #3498db;
            box-shadow: 0 0 20px rgba(52,152,219,0.4);
        }

        .player-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .player-card.red .player-icon { background: #e74c3c; }
        .player-card.green .player-icon { background: #2ecc71; }
        .player-card.yellow .player-icon { background: #f1c40f; }
        .player-card.blue .player-icon { background: #3498db; }

        .player-info {
            flex: 1;
            min-width: 0;
        }

        .player-name {
            color: #fff;
            font-weight: 700;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-status {
            color: rgba(255,255,255,0.6);
            font-size: 10px;
            margin-top: 2px;
            font-weight: 500;
        }

        .player-tokens {
            display: flex;
            gap: 3px;
            flex-shrink: 0;
        }

        .token-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0.25;
            transition: all 0.2s ease;
        }

        .token-indicator.home {
            opacity: 1;
            box-shadow: 0 0 8px currentColor;
        }

        .player-card.red .token-indicator { background: #e74c3c; color: #e74c3c; }
        .player-card.green .token-indicator { background: #2ecc71; color: #2ecc71; }
        .player-card.yellow .token-indicator { background: #f1c40f; color: #f1c40f; }
        .player-card.blue .token-indicator { background: #3498db; color: #3498db; }

        /* Explicit token colors (used in 2-player full mode owner cards) */
        .player-tokens .token-indicator.red { background: #e74c3c !important; color: #e74c3c !important; }
        .player-tokens .token-indicator.green { background: #2ecc71 !important; color: #2ecc71 !important; }
        .player-tokens .token-indicator.yellow { background: #f1c40f !important; color: #f1c40f !important; }
        .player-tokens .token-indicator.blue { background: #3498db !important; color: #3498db !important; }

        /* Dice Panel - Docked to top-right to avoid covering the board */
        #dicePanel {
            top: 70px;
            right: 20px;
            left: auto;
            transform: none;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            max-width: 320px;
        }

        #rollDiceBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 45%, #f093fb 100%);
            color: white;
            border: 1px solid rgba(255,255,255,0.18);
            padding: 14px 16px;
            font-size: 16px;
            font-weight: 900;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 30px rgba(102,126,234,0.45), inset 0 1px 0 rgba(255,255,255,0.25);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
            min-width: 160px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #rollDiceBtn:not(:disabled) {
            animation: rollReadyPulse 1.4s ease-in-out infinite;
        }

        @keyframes rollReadyPulse {
            0%, 100% { transform: translateY(0); filter: saturate(1); }
            50% { transform: translateY(-1px); filter: saturate(1.15); }
        }

        #rollDiceBtn:focus-visible {
            outline: 3px solid rgba(255,255,255,0.6);
            outline-offset: 3px;
        }

        #rollDiceBtn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
            pointer-events: none;
        }

        #rollDiceBtn::after {
            content: '';
            position: absolute;
            inset: -40% -60%;
            background: linear-gradient(120deg, transparent 35%, rgba(255,255,255,0.22) 50%, transparent 65%);
            transform: translateX(-30%) rotate(6deg);
            opacity: 0;
            pointer-events: none;
        }

        #rollDiceBtn:hover:not(:disabled)::before {
            width: 200px;
            height: 200px;
        }

        #rollDiceBtn:hover:not(:disabled)::after {
            opacity: 1;
            animation: rollShine 1.1s ease forwards;
        }

        @keyframes rollShine {
            0% { transform: translateX(-30%) rotate(6deg); }
            100% { transform: translateX(30%) rotate(6deg); }
        }

        #rollDiceBtn:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 12px 35px rgba(102,126,234,0.6);
        }

        #rollDiceBtn:active:not(:disabled) {
            transform: translateY(-1px) scale(0.99);
        }

        #rollDiceBtn:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.6;
            transform: none;
            animation: none;
        }

        #rollDiceBtn .rollDiceBtn__text {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            line-height: 1.05;
        }

        #rollDiceBtn .rollDiceBtn__title {
            font-size: 16px;
            font-weight: 950;
            letter-spacing: 2px;
        }

        #rollDiceBtn .rollDiceBtn__hint {
            margin-top: 4px;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 0.6px;
            text-transform: none;
            opacity: 0.82;
        }

        #rollDiceBtn .dice-cube {
            width: 26px;
            height: 26px;
            border-radius: 8px;
            background:
                radial-gradient(circle at 30% 30%, rgba(26,26,46,0.95) 0 2px, transparent 3px),
                radial-gradient(circle at 70% 30%, rgba(26,26,46,0.95) 0 2px, transparent 3px),
                radial-gradient(circle at 50% 50%, rgba(26,26,46,0.95) 0 2px, transparent 3px),
                radial-gradient(circle at 30% 70%, rgba(26,26,46,0.95) 0 2px, transparent 3px),
                radial-gradient(circle at 70% 70%, rgba(26,26,46,0.95) 0 2px, transparent 3px),
                linear-gradient(145deg, rgba(255,255,255,0.92), rgba(255,255,255,0.72));
            box-shadow:
                0 8px 18px rgba(0,0,0,0.25),
                inset 0 1px 0 rgba(255,255,255,0.65),
                inset 0 -1px 0 rgba(0,0,0,0.15);
            transform: rotate(-10deg);
            transition: transform 0.25s ease;
        }

        #rollDiceBtn:hover:not(:disabled) .dice-cube {
            transform: rotate(0deg) scale(1.03);
        }

        #rollDiceBtn:not(:disabled) .dice-cube {
            animation: diceWiggle 1.2s ease-in-out infinite;
        }

        @keyframes diceWiggle {
            0%, 100% { transform: rotate(-10deg); }
            50% { transform: rotate(6deg); }
        }

        #rollDiceBtn .rollDiceBtn__chev {
            width: 10px;
            height: 10px;
            border-right: 2px solid rgba(255,255,255,0.85);
            border-bottom: 2px solid rgba(255,255,255,0.85);
            transform: rotate(-45deg);
            opacity: 0.85;
        }

        #rollDiceBtn:not(:disabled) .rollDiceBtn__chev {
            animation: rollNudge 1.2s ease-in-out infinite;
        }

        @keyframes rollNudge {
            0%, 100% { transform: translateX(0) rotate(-45deg); opacity: 0.8; }
            50% { transform: translateX(3px) rotate(-45deg); opacity: 1; }
        }

        #turnTimer {
            display: inline-block;
            background: rgba(0,0,0,0.5);
            padding: 8px 16px;
            border-radius: 10px;
            margin-top: 10px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            min-width: 120px;
            text-align: center;
            border: 2px solid rgba(102,126,234,0.3);
        }

        #turnTimer.warning {
            color: #f39c12;
            border-color: #f39c12;
            animation: timerPulse 1s ease-in-out infinite;
        }

        #turnTimer.critical {
            color: #e74c3c;
            border-color: #e74c3c;
            animation: timerPulse 0.5s ease-in-out infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px currentColor; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px currentColor; }
        }

        #diceResult {
            margin-top: 10px;
            font-size: 24px;
            line-height: 1.3;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,215,0,0.55);
            background: rgba(0,0,0,0.5);
            padding: 10px 16px;
            border-radius: 12px;
            display: inline-block;
            font-weight: 700;
            border: 2px solid rgba(102,126,234,0.3);
            transition: opacity 0.3s ease;
        }
        #diceResult:empty {
            display: none;
        }
        #diceResult.counting { animation: pulse 0.8s ease-in-out; }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .die-choice {
            margin-top: 12px;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 16px 20px;
            border-radius: 15px;
            border: 2px solid rgba(102,126,234,0.3);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        .die-choice.hidden { display: none; }
        .die-choice-label {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .die-choice-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .die-btn {
            background: linear-gradient(135deg, rgba(102,126,234,0.3) 0%, rgba(118,75,162,0.3) 100%);
            border: 2px solid rgba(102,126,234,0.5);
            color: #fff;
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 800;
            font-size: 16px;
            min-width: 110px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(102,126,234,0.2);
            position: relative;
            overflow: hidden;
        }
        .die-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transform: translate(-50%, -50%);
            transition: width 0.4s, height 0.4s;
        }
        .die-btn:hover:not(:disabled)::before {
            width: 200px;
            height: 200px;
        }
        .die-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(102,126,234,0.5) 0%, rgba(118,75,162,0.5) 100%);
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102,126,234,0.4);
        }
        .die-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }
        .die-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .die-btn.secondary {
            background: linear-gradient(135deg, rgba(231,76,60,0.3) 0%, rgba(192,57,43,0.3) 100%);
            border: 2px dashed rgba(231,76,60,0.5);
        }
        .die-btn.secondary:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(231,76,60,0.5) 0%, rgba(192,57,43,0.5) 100%);
            border-color: #e74c3c;
        }
        .hidden { display: none !important; }

        #turnMessage {
            margin-top: 10px;
            color: rgba(255,255,255,0.8);
            font-size: 16px;
        }

        /* Control Buttons */
        #controls {
            top: 15px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            width: 45px;
            height: 45px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 25px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 28px;
            color: #fff;
            margin-bottom: 25px;
            text-align: center;
        }

        .modal-title span {
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Start Menu */
        #startMenu .player-setup {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }

        /* Slightly more compact start menu overall */
        #startMenu .modal-title { margin-bottom: 10px; }
        #startMenu .player-setup { margin-bottom: 12px; gap: 12px; }
        #startMenu .player-option { padding: 14px; border-radius: 16px; }
        #startMenu .player-option-header { margin-bottom: 10px; }
        #startMenu .player-type-select { padding: 10px 12px; }
        #startMenu .player-name-input { margin-top: 10px; padding: 10px 12px; }
        #startMenu .start-btn { padding: 14px; font-size: 18px; }

        /* Make Start Game always reachable on small screens */
        #startMenu .modal-content {
            max-height: 92vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #startMenu .startmenu-scroll {
            overflow-y: auto;
            padding-right: 6px;
        }

        #startMenu .startmenu-subtitle {
            color: rgba(255,255,255,0.7);
            text-align: center;
            margin: 0 0 14px;
        }

        #startMenu .startmenu-row {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin: 0 0 12px;
        }

        .player-option {
            background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.08) 100%);
            border-radius: 20px;
            padding: 25px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .player-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
        }

        .player-option.selected {
            border-color: #667eea;
            background: linear-gradient(145deg, rgba(102,126,234,0.15) 0%, rgba(102,126,234,0.25) 100%);
            box-shadow: 0 0 30px rgba(102,126,234,0.4), 0 10px 30px rgba(0,0,0,0.3);
        }

        .player-option.disabled {
            opacity: 0.4;
            filter: grayscale(0.6);
            cursor: not-allowed;
        }

        .player-option.red.selected {
            border-color: #e74c3c;
            background: linear-gradient(145deg, rgba(231,76,60,0.15) 0%, rgba(231,76,60,0.25) 100%);
            box-shadow: 0 0 30px rgba(231,76,60,0.4), 0 10px 30px rgba(0,0,0,0.3);
        }

        .player-option.green.selected {
            border-color: #2ecc71;
            background: linear-gradient(145deg, rgba(46,204,113,0.15) 0%, rgba(46,204,113,0.25) 100%);
            box-shadow: 0 0 30px rgba(46,204,113,0.4), 0 10px 30px rgba(0,0,0,0.3);
        }

        .player-option.yellow.selected {
            border-color: #f1c40f;
            background: linear-gradient(145deg, rgba(241,196,15,0.15) 0%, rgba(241,196,15,0.25) 100%);
            box-shadow: 0 0 30px rgba(241,196,15,0.4), 0 10px 30px rgba(0,0,0,0.3);
        }

        .player-option.blue.selected {
            border-color: #3498db;
            background: linear-gradient(145deg, rgba(52,152,219,0.15) 0%, rgba(52,152,219,0.25) 100%);
            box-shadow: 0 0 30px rgba(52,152,219,0.4), 0 10px 30px rgba(0,0,0,0.3);
        }

        .player-option-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .player-color-dot {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            box-shadow: 0 0 20px currentColor;
            animation: dotPulse 2s ease-in-out infinite;
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .player-option.red .player-color-dot { background: #e74c3c; color: #e74c3c; }
        .player-option.green .player-color-dot { background: #2ecc71; color: #2ecc71; }
        .player-option.yellow .player-color-dot { background: #f1c40f; color: #f1c40f; }
        .player-option.blue .player-color-dot { background: #3498db; color: #3498db; }

        .player-option-title {
            color: #fff;
            font-weight: bold;
            flex: 1;
        }

        .player-type-select {
            width: 100%;
            padding: 12px 15px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.4);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            outline: none;
        }

        .player-type-select:hover {
            border-color: rgba(255,255,255,0.4);
            background: rgba(0,0,0,0.5);
        }

        .player-type-select option {
            background: #1a1a2e;
            padding: 10px;
        }

        .player-name-input {
            width: 100%;
            margin-top: 12px;
            padding: 12px 15px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.4);
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            outline: none;
        }

        .player-name-input:focus {
            border-color: #667eea;
            background: rgba(0,0,0,0.6);
            box-shadow: 0 0 20px rgba(102,126,234,0.3);
        }

        .player-option.red .player-name-input:focus { border-color: #e74c3c; box-shadow: 0 0 20px rgba(231,76,60,0.3); }
        .player-option.green .player-name-input:focus { border-color: #2ecc71; box-shadow: 0 0 20px rgba(46,204,113,0.3); }
        .player-option.yellow .player-name-input:focus { border-color: #f1c40f; box-shadow: 0 0 20px rgba(241,196,15,0.3); }
        .player-option.blue .player-name-input:focus { border-color: #3498db; box-shadow: 0 0 20px rgba(52,152,219,0.3); }

        .player-name-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .start-btn {
            width: 100%;
            padding: 20px;
            font-size: 22px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 40px rgba(102,126,234,0.4);
            position: relative;
            overflow: hidden;
        }

        .start-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .start-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .start-btn:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 20px 60px rgba(102,126,234,0.6);
        }

        .start-btn:active {
            transform: translateY(-2px) scale(0.98);
        }

        .legal-notice {
            margin-top: 10px;
            text-align: center;
            font-size: 11px;
            line-height: 1.35;
            color: rgba(255,255,255,0.6);
        }

        .legal-notice a {
            color: rgba(255,255,255,0.8);
            text-decoration: underline;
        }

        /* Debug overlay (off by default) */
        #debugOverlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 99999;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .debugLabel {
            position: absolute;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(0,0,0,0.65);
            border: 1px solid rgba(255,255,255,0.28);
            color: rgba(255,255,255,0.95);
            font-size: 11px;
            white-space: nowrap;
            transform: translate(-50%, -50%);
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        }

        .cellLabel {
            position: absolute;
            padding: 1px 4px;
            border-radius: 6px;
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.18);
            color: rgba(255,255,255,0.9);
            font-size: 10px;
            white-space: nowrap;
            transform: translate(-50%, -50%);
            text-shadow: 0 1px 2px rgba(0,0,0,0.55);
            opacity: 0.95;
        }

        /* In-game guide (optional) */
        #coachPanel {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(14px + env(safe-area-inset-bottom, 0px));
            max-width: min(560px, calc(100vw - 24px));
            width: max-content;
            z-index: 99998;
            pointer-events: auto;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 14px;
            padding: 10px 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
            color: rgba(255,255,255,0.95);
            line-height: 1.35;
        }

        #coachPanel.hidden { display: none; }

        #coachHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 6px;
        }

        #coachTitle {
            font-size: 12px;
            letter-spacing: 0.6px;
            text-transform: uppercase;
            color: rgba(255,255,255,0.75);
            user-select: none;
        }

        #coachText {
            font-size: 13px;
            color: rgba(255,255,255,0.92);
            user-select: none;
        }

        #coachActions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #coachToggleBtn {
            appearance: none;
            border: 1px solid rgba(255,255,255,0.22);
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.92);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        #coachToggleBtn:hover {
            background: rgba(255,255,255,0.12);
        }

        #coachMiniBtn {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(14px + env(safe-area-inset-bottom, 0px));
            z-index: 99998;
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.22);
            background: rgba(0,0,0,0.5);
            color: rgba(255,255,255,0.9);
            border-radius: 999px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: none;
        }

        #coachMiniBtn:hover {
            background: rgba(0,0,0,0.6);
        }

        /* Rules Modal */
        .rules-section {
            margin-bottom: 25px;
        }

        .rules-section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .rules-section p, .rules-section li {
            color: rgba(255,255,255,0.8);
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .rules-section ul {
            padding-left: 20px;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .close-btn:hover {
            opacity: 1;
        }

        /* Winner Modal */
        #winnerModal .modal-content {
            text-align: center;
        }

        .winner-trophy {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .winner-name {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .winner-name.red { color: #e74c3c; }
        .winner-name.green { color: #2ecc71; }
        .winner-name.yellow { color: #f1c40f; }
        .winner-name.blue { color: #3498db; }

        .winner-subtitle {
            color: rgba(255,255,255,0.6);
            font-size: 18px;
            margin-bottom: 30px;
        }

        /* Turn badge */
        #turnMessage {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.12);
            padding: 10px 16px;
            border-radius: 14px;
            display: inline-block;
            margin-top: 8px;
            font-weight: 700;
            letter-spacing: 0.5px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
            transition: all 0.2s ease;
        }
        body[data-turn="red"] #turnMessage { background: rgba(231,76,60,0.18); border-color: rgba(231,76,60,0.5); box-shadow: 0 10px 30px rgba(231,76,60,0.35); }
        body[data-turn="green"] #turnMessage { background: rgba(46,204,113,0.18); border-color: rgba(46,204,113,0.5); box-shadow: 0 10px 30px rgba(46,204,113,0.35); }
        body[data-turn="yellow"] #turnMessage { background: rgba(241,196,15,0.18); border-color: rgba(241,196,15,0.5); box-shadow: 0 10px 30px rgba(241,196,15,0.35); }
        body[data-turn="blue"] #turnMessage { background: rgba(52,152,219,0.18); border-color: rgba(52,152,219,0.5); box-shadow: 0 10px 30px rgba(52,152,219,0.35); }

        /* Notification */
        #notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(102,126,234,0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: bold;
            z-index: 500;
            transition: transform 0.5s ease;
            pointer-events: none;
        }

        #notification.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Token Selection Highlight */
        .token-highlight {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 10px 25px;
            border-radius: 25px;
            display: none;
        }

        .token-highlight.show {
            display: block;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #fff;
            margin-top: 20px;
            font-size: 18px;
        }

        /* Intro Title Screen */
        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f1419 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease, transform 1s ease, visibility 0s 1s;
            overflow: hidden;
        }

        #titleScreen.active {
            opacity: 1;
            visibility: visible;
            transition: opacity 1s ease, transform 1s ease;
        }

        .splash-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            background: radial-gradient(circle, rgba(102,126,234,0.8) 0%, transparent 70%);
            border-radius: 50%;
            animation: float 3s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.5; }
            50% { transform: translateY(-20px) scale(1.1); opacity: 1; }
        }

        .splash-dice {
            font-size: 60px;
            margin-bottom: 20px;
            animation: diceRoll 2s ease-in-out infinite;
        }

        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
        }

        .title-card {
            text-align: center;
            z-index: 1;
            animation: splashFadeIn 1s ease-out;
        }

        @keyframes splashFadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .title-card::before, .title-card::after {
            display: none;
        }

        .intro-logo {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 3px;
            color: #fff;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .intro-title {
            font-size: 120px;
            font-weight: 900;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 15px;
            margin-bottom: 20px;
            text-shadow: 0 0 80px rgba(102,126,234,0.5);
            animation: titleGlow 2s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 20px rgba(102,126,234,0.5)); }
            50% { filter: brightness(1.3) drop-shadow(0 0 40px rgba(102,126,234,0.8)); }
        }

        .intro-subtitle {
            font-size: 16px;
            color: #667eea;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            padding: 10px 30px;
            border: 2px solid #667eea;
            border-radius: 50px;
            display: inline-block;
            margin-top: 30px;
            margin-bottom: 40px;
            animation: borderPulse 2s ease-in-out infinite;
        }

        @keyframes borderPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(102,126,234,0.3); }
            50% { box-shadow: 0 0 40px rgba(102,126,234,0.8); }
        }

        .intro-highlight {
            color: #ffd700;
            font-weight: bold;
        }

        .intro-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 22px;
            font-weight: 900;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 40px rgba(102,126,234,0.4);
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
        }

        .intro-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .intro-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .intro-btn:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 20px 60px rgba(102,126,234,0.6);
        }

        .intro-btn:active {
            transform: translateY(-2px) scale(0.98);
        }

        .legendhero-pill {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            border-radius: 999px;
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.85);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
        }

        .legendhero-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: linear-gradient(120deg, #f39c12, #e74c3c);
            box-shadow: 0 0 12px rgba(243,156,18,0.8);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-title { font-size: 18px; padding: 12px 15px; }
            #playerPanel { width: 160px; left: 10px; top: 60px; }
            .player-card { padding: 8px 10px; margin-bottom: 6px; }
            .player-icon { width: 28px; height: 28px; font-size: 14px; }
            .player-name { font-size: 12px; }
            .player-status { font-size: 9px; }
            .token-indicator { width: 8px; height: 8px; gap: 2px; }

            #dicePanel {
                left: 10px;
                right: 10px;
                bottom: 12px;
                top: auto;
                text-align: center;
                align-items: center;
                max-width: none;
            }
            #rollDiceBtn { padding: 12px 24px; font-size: 15px; min-width: 130px; }
            #diceResult { font-size: 20px; padding: 8px 12px; }
            #turnTimer { font-size: 13px; padding: 6px 12px; }

            .die-choice { padding: 12px 16px; }
            .die-choice-label { font-size: 12px; }
            .die-btn { padding: 10px 16px; font-size: 14px; min-width: 100px; }

            .modal-content { padding: 25px; }

            .splash-dice { font-size: 40px; }
            .intro-title { font-size: 60px; letter-spacing: 8px; }
            .intro-logo { font-size: 18px; }
            .intro-subtitle { font-size: 14px; padding: 8px 20px; }
            .intro-btn { font-size: 18px; padding: 16px 40px; }

            #startMenu .player-setup { grid-template-columns: 1fr 1fr; gap: 12px; }
            .player-option { padding: 20px; }
            .player-name-input { font-size: 14px; padding: 10px; }
            .start-btn { font-size: 18px; padding: 16px; }
        }

        @media (max-height: 720px) {
            #startMenu .modal-content { padding: 18px; max-height: 96vh; border-radius: 18px; }
            #startMenu .modal-title { font-size: 22px; margin-bottom: 10px; }
            #startMenu .startmenu-subtitle { margin-bottom: 10px; font-size: 13px; }
            #startMenu .startmenu-row { margin-bottom: 10px; }
            #startMenu .player-setup { gap: 10px; margin-bottom: 14px; }
            #startMenu .player-option { padding: 14px; border-radius: 16px; box-shadow: 0 6px 18px rgba(0,0,0,0.28); }
            #startMenu .player-option-header { margin-bottom: 10px; }
            #startMenu .player-color-dot { width: 24px; height: 24px; box-shadow: 0 0 12px currentColor; }
            #startMenu .player-type-select { padding: 8px 10px; font-size: 12px; }
            #startMenu .player-name-input { margin-top: 8px; padding: 8px 10px; font-size: 13px; }
            #startMenu .start-btn { padding: 12px; font-size: 16px; letter-spacing: 2px; }
        }

        @media (max-width: 420px) {
            #startMenu .player-setup { grid-template-columns: 1fr; }
        }

        /* Main Menu Styles */
        #mainMenuScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f1419 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            overflow: auto;
        }

        #mainMenuScreen.active {
            display: flex;
        }

        /* Title rules summary gate */
        #titleRulesModal {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 18px;
            background: rgba(0, 0, 0, 0.6);
            z-index: 5;
        }

        #titleRulesModal.hidden { display: none; }

        .title-rules-card {
            width: min(720px, calc(100vw - 28px));
            max-height: min(78vh, 640px);
            overflow: auto;
            background: rgba(15, 15, 28, 0.92);
            border: 1px solid rgba(255,255,255,0.14);
            border-radius: 18px;
            padding: 16px 16px 14px;
            box-shadow: 0 18px 60px rgba(0,0,0,0.45);
            backdrop-filter: blur(12px);
        }

        .title-rules-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            letter-spacing: 0.6px;
            text-transform: uppercase;
            color: rgba(255,255,255,0.82);
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.14);
            border-radius: 999px;
            padding: 6px 10px;
            margin-bottom: 10px;
        }

        .title-rules-title {
            margin: 0 0 6px;
            font-size: 22px;
            color: rgba(255,255,255,0.95);
        }

        .title-rules-lead {
            margin: 0 0 12px;
            font-size: 14px;
            color: rgba(255,255,255,0.78);
            line-height: 1.45;
        }

        .title-rules-tip {
            margin: -4px 0 12px;
            font-size: 13px;
            line-height: 1.45;
            color: rgba(255, 231, 164, 0.95);
            background: rgba(255, 191, 71, 0.12);
            border: 1px solid rgba(255, 191, 71, 0.18);
            border-radius: 12px;
            padding: 10px 12px;
        }

        .title-rules-list {
            margin: 0 0 12px 18px;
            padding: 0;
            color: rgba(255,255,255,0.9);
            line-height: 1.5;
            font-size: 14px;
        }

        .title-rules-list li { margin-bottom: 8px; }

        .title-rules-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255,255,255,0.85);
            font-size: 13px;
            margin: 6px 0 12px;
            user-select: none;
        }

        .title-rules-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .title-rules-primary,
        .title-rules-secondary {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 10px 12px;
            font-size: 13px;
            cursor: pointer;
        }

        .title-rules-secondary {
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.92);
        }

        .title-rules-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            border-color: rgba(255,255,255,0.12);
        }

        .title-rules-primary:hover { filter: brightness(1.05); }
        .title-rules-secondary:hover { background: rgba(255,255,255,0.12); }

        .main-menu-container {
            text-align: center;
            padding: 40px;
            max-width: 600px;
        }

        .main-menu-title {
            font-size: 56px;
            font-weight: 900;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 10px;
            margin-bottom: 15px;
        }

        .main-menu-subtitle {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 50px;
            letter-spacing: 2px;
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .menu-option-btn {
            background: linear-gradient(145deg, rgba(102,126,234,0.15) 0%, rgba(118,75,162,0.15) 100%);
            border: 2px solid rgba(102,126,234,0.3);
            border-radius: 20px;
            padding: 25px 40px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .menu-option-btn.disabled {
            opacity: 0.45;
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(0.35);
        }

        .menu-option-btn.disabled:hover {
            transform: none;
            box-shadow: none;
            border-color: rgba(102,126,234,0.3);
            background: linear-gradient(145deg, rgba(102,126,234,0.15) 0%, rgba(118,75,162,0.15) 100%);
        }

        .coming-soon-badge {
            position: absolute;
            top: 14px;
            right: 14px;
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            color: rgba(255,255,255,0.9);
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 999px;
            backdrop-filter: blur(6px);
        }

        .menu-option-btn:hover {
            background: linear-gradient(145deg, rgba(102,126,234,0.25) 0%, rgba(118,75,162,0.25) 100%);
            border-color: rgba(102,126,234,0.6);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102,126,234,0.3);
        }

        .menu-option-btn:active {
            transform: translateY(-1px);
        }

        .menu-option-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .menu-option-title {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .menu-option-desc {
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .main-menu-title { font-size: 36px; letter-spacing: 5px; }
            .main-menu-container { padding: 30px 20px; }
            .menu-option-btn { padding: 20px 30px; }
            .menu-option-icon { font-size: 28px; }
            .menu-option-title { font-size: 20px; }
        }

        /* Online Lobby Styles */
        .lobby-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 25px 0;
        }

        .lobby-btn {
            background: linear-gradient(145deg, rgba(102,126,234,0.15) 0%, rgba(118,75,162,0.15) 100%);
            border: 2px solid rgba(102,126,234,0.3);
            border-radius: 12px;
            padding: 18px 30px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lobby-btn:hover {
            background: linear-gradient(145deg, rgba(102,126,234,0.25) 0%, rgba(118,75,162,0.25) 100%);
            border-color: rgba(102,126,234,0.6);
            transform: translateY(-2px);
        }

        .lobby-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
        }

        .lobby-btn.primary:hover {
            background: linear-gradient(135deg, #7b8ef5 0%, #8a5bb7 100%);
            transform: translateY(-2px);
        }

        .lobby-section {
            display: none;
            margin: 25px 0;
        }

        .lobby-section.active {
            display: block;
        }

        .room-code-display {
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(102,126,234,0.4);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .room-code-label {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .room-code-value {
            font-size: 32px;
            font-weight: 900;
            color: #667eea;
            letter-spacing: 8px;
            font-family: 'Courier New', monospace;
        }

        .lobby-input {
            width: 100%;
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-size: 18px;
            text-align: center;
            letter-spacing: 4px;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            margin: 15px 0;
        }

        .lobby-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102,126,234,0.3);
        }

        .lobby-status {
            text-align: center;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            font-size: 14px;
        }

        .lobby-status.waiting {
            background: rgba(255,193,7,0.15);
            color: #ffc107;
            border: 2px solid rgba(255,193,7,0.3);
        }

        .lobby-status.connected {
            background: rgba(76,175,80,0.15);
            color: #4caf50;
            border: 2px solid rgba(76,175,80,0.3);
        }

        .lobby-status.error {
            background: rgba(244,67,54,0.15);
            color: #f44336;
            border: 2px solid rgba(244,67,54,0.3);
        }

        .lobby-back-btn {
            margin-top: 20px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .lobby-back-btn:hover {
            background: rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="hidden">
        <div class="legendhero-pill"><span class="legendhero-dot"></span>Ludo by Legendhero</div>
        <div class="loader"></div>
        <div class="loading-text">Preparing the board...</div>
    </div>

    <!-- Title Screen -->
    <div id="titleScreen" class="active">
            <div class="splash-particles"></div>
            <div class="title-card">
                <div class="splash-dice"></div>
                <div class="intro-title">LUDO</div>
                <div class="intro-logo">by Legendhero</div>
                <div class="intro-subtitle">Nairaland Coding Challenge</div>
                <button class="intro-btn" id="titleContinueBtn"> Continue</button>
            </div>

            <!-- Title rules summary gate (shown when clicking Continue) -->
            <div id="titleRulesModal" class="hidden" role="dialog" aria-modal="true" aria-labelledby="titleRulesHeading">
                <div class="title-rules-card">
                    <div class="title-rules-badge">Nigerian Ludo</div>
                    <h3 id="titleRulesHeading" class="title-rules-title">Quick Rules Summary</h3>
                    <p class="title-rules-lead">If you already know how to play Naija/Nigerian Ludo, youll feel at home here  we built this game with that same knowledge in mind. Read the rules below, then continue.</p>
                    <p class="title-rules-tip">Tip: theres a Guide at the bottom of the screen during gameplay; you can turn it off and on anytime.</p>
                    <ul class="title-rules-list">
                        <li><strong>Two dice</strong> per turn.</li>
                        <li><strong>6 to come out:</strong> you must roll an actual <strong>6</strong> to bring a token from base to your start square.</li>
                        <li><strong>Start-square protection (Naija rule):</strong> you cant capture an opponent on <em>their</em> start square; you need a <strong>6</strong> to capture on <em>your</em> start square.</li>
                        <li><strong>Home lane:</strong> enter your color lane near the end and finish on your last home square by <strong>exact count</strong>.</li>
                        <li><strong>Controls:</strong> mobile (drag + pinch), desktop (drag + scroll/trackpad).</li>
                    </ul>
                    <label class="title-rules-checkbox">
                        <input type="checkbox" id="titleRulesDontShow"> Dont show this again
                    </label>
                    <div class="title-rules-actions">
                        <button class="title-rules-secondary" id="titleRulesBackBtn" type="button">Back</button>
                        <button class="title-rules-primary" id="titleRulesContinueBtn" type="button">I Understand, Continue</button>
                    </div>
                </div>
            </div>
        </div>

    <!-- Main Menu Screen -->
    <div id="mainMenuScreen">
        <div class="main-menu-container">
            <div class="main-menu-title">Choose Mode</div>
            <div class="main-menu-subtitle">Select how you want to play</div>
            <div class="menu-options">
                <div class="menu-option-btn disabled" id="playOnlineBtn" title="Online multiplayer coming soon">
                    <div class="coming-soon-badge">Coming soon</div>
                    <div class="menu-option-icon"></div>
                    <div class="menu-option-title">Play Online</div>
                    <div class="menu-option-desc">Online multiplayer is coming soon</div>
                </div>
                <div class="menu-option-btn" id="playVsAIBtn">
                    <div class="menu-option-icon"></div>
                    <div class="menu-option-title">Play vs AI</div>
                    <div class="menu-option-desc">Test your skills against computer opponents</div>
                </div>
                <div class="menu-option-btn" id="playLocalBtn">
                    <div class="menu-option-icon"></div>
                    <div class="menu-option-title">Local Multiplayer</div>
                    <div class="menu-option-desc">Play with friends on the same device</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Header -->
    <div id="header" class="ui-overlay">
        <div class="game-title"><span>3D LUDO</span> by Legendhero</div>
        <div id="controls">
            <button class="control-btn" id="rulesBtn" title="Rules">?</button>
            <button class="control-btn" id="soundBtn" title="Sound"></button>
            <button class="control-btn" id="resetBtn" title="New Game"></button>
        </div>
    </div>

    <!-- Player Panel -->
    <div id="playerPanel" class="ui-overlay"></div>

    <!-- Dice Panel -->
    <div id="dicePanel" class="ui-overlay">
        <button id="rollDiceBtn"><span class="dice-icon"></span> Roll Dice</button>
        <div id="turnTimer" style="display: none;"> <span id="timerSeconds">30</span>s</div>
        <div id="diceResult"></div>
        <div id="dieChoice" class="die-choice hidden">
            <div class="die-choice-label">Pick which die to use first:</div>
            <div class="die-choice-buttons">
                <button id="chooseDie1" class="die-btn">First: ?</button>
                <button id="chooseDie2" class="die-btn">First: ?</button>
                <button id="skipDie" class="die-btn secondary hidden">Skip</button>
            </div>
        </div>
        <div id="turnMessage"></div>
    </div>

    <!-- Token Selection Hint -->
    <div id="tokenHint" class="token-highlight">Click a token to move</div>

    <!-- Notification -->
    <div id="notification"></div>

    <!-- Start Menu Modal -->
    <div id="startMenu" class="modal">
        <div class="modal-content">
            <div class="startmenu-scroll">
            <h2 class="modal-title"> <span>3D LUDO</span></h2>
            <p class="startmenu-subtitle">
                Select players and start the game!
            </p>
            <div class="startmenu-row">
                <span style="color: rgba(255,255,255,0.8); font-size: 13px;">Players:</span>
                <label style="color: white; font-size: 13px;">
                    <input type="radio" name="playerCount" value="2" checked style="margin-right: 6px;"> 2 Players
                </label>
                <label style="color: white; font-size: 13px;">
                    <input type="radio" name="playerCount" value="3" style="margin-right: 6px;"> 3 Players
                </label>
                <label style="color: white; font-size: 13px;">
                    <input type="radio" name="playerCount" value="4" style="margin-right: 6px;"> 4 Players
                </label>
            </div>
            <div id="twoPlayerModeContainer" class="startmenu-row">
                <span style="color: rgba(255,255,255,0.8); font-size: 13px;">2-Player Mode:</span>
                <label id="twoPlayerModeLabel1" style="color: white; font-size: 13px;">
                    <input type="radio" name="twoPlayerMode" value="half" checked style="margin-right: 6px;" id="twoPlayerHalf"> Half (one side each)
                </label>
                <label id="twoPlayerModeLabel2" style="color: white; font-size: 13px;">
                    <input type="radio" name="twoPlayerMode" value="full" style="margin-right: 6px;" id="twoPlayerFull"> Full (two sides each)
                </label>
            </div>
            <div class="player-setup">
                <div class="player-option red selected" data-player="0">
                    <div class="player-option-header">
                        <div class="player-color-dot"></div>
                        <span class="player-option-title">Red Player</span>
                    </div>
                    <select class="player-type-select" data-player="0">
                        <option value="human">Human</option>
                        <option value="ai">AI</option>
                        <option value="none">Not Playing</option>
                    </select>
                    <input class="player-name-input" data-player="0" type="text" placeholder=" Click to rename">
                </div>
                <div class="player-option green selected" data-player="1">
                    <div class="player-option-header">
                        <div class="player-color-dot"></div>
                        <span class="player-option-title">Green Player</span>
                    </div>
                    <select class="player-type-select" data-player="1">
                        <option value="human">Human</option>
                        <option value="ai" selected>AI</option>
                        <option value="none">Not Playing</option>
                    </select>
                    <input class="player-name-input" data-player="1" type="text" placeholder=" Click to rename">
                </div>
                <div class="player-option yellow selected" data-player="2">
                    <div class="player-option-header">
                        <div class="player-color-dot"></div>
                        <span class="player-option-title">Yellow Player</span>
                    </div>
                    <select class="player-type-select" data-player="2">
                        <option value="human">Human</option>
                        <option value="ai" selected>AI</option>
                        <option value="none">Not Playing</option>
                    </select>
                    <input class="player-name-input" data-player="2" type="text" placeholder=" Click to rename">
                </div>
                <div class="player-option blue selected" data-player="3">
                    <div class="player-option-header">
                        <div class="player-color-dot"></div>
                        <span class="player-option-title">Blue Player</span>
                    </div>
                    <select class="player-type-select" data-player="3">
                        <option value="human">Human</option>
                        <option value="ai" selected>AI</option>
                        <option value="none">Not Playing</option>
                    </select>
                    <input class="player-name-input" data-player="3" type="text" placeholder=" Click to rename">
                </div>
            </div>
            </div>
            <button class="start-btn" id="startGameBtn">Start Game</button>
            <div class="legal-notice">
                 2025 LegendHero. All rights reserved. No redistribution or re-hosting without permission.
                <span style="display:block; margin-top: 4px;">See <a href="LICENSE" target="_blank" rel="noopener">LICENSE</a>.</span>
            </div>
        </div>
    </div>

    <!-- Rules Modal -->
    <div id="rulesModal" class="modal">
        <div class="modal-content" style="position: relative;">
            <button class="close-btn" id="closeRules">&times;</button>
            <h2 class="modal-title"> Game <span>Rules</span></h2>

            <div class="rules-section">
                <h3> Objective</h3>
                <p>Be the first player to move all 4 of your tokens from your home base, around the board, and into your finish zone (center column of your color).</p>
            </div>

            <div class="rules-section">
                <h3> Rolling the Dice</h3>
                <ul>
                    <li>Click "Roll Dice" on your turn to roll a single die (1-6).</li>
                    <li>You must roll a <strong>6</strong> to move a token out of your home base onto the starting square.</li>
                    <li>Rolling a 6 gives you an <strong>extra turn</strong>!</li>
                    <li>If you roll three 6s in a row, your turn ends (to prevent infinite turns).</li>
                </ul>
            </div>

            <div class="rules-section">
                <h3> Movement</h3>
                <ul>
                    <li>Tokens move clockwise around the board.</li>
                    <li>You must move a token if any legal move is possible.</li>
                    <li>Click on a highlighted token to select it for movement.</li>
                    <li>Tokens travel 51 squares around the board before entering their home column.</li>
                </ul>
            </div>

            <div class="rules-section">
                <h3> Capturing - Nigerian Ludo Rules</h3>
                <ul>
                    <li>Landing on an opponent's token sends it back to their home base.</li>
                    <li>Capturing gives a <strong>bonus turn</strong>!</li>
                    <li><strong>Cannot capture opponent on THEIR start square</strong> (they're protected).</li>
                    <li><strong>Need a 6 to capture on YOUR start square</strong> when opponent is there.</li>
                    <li>All other squares: normal capture rules apply.</li>
                </ul>
            </div>

            <div class="rules-section">
                <h3> Start Square Protection</h3>
                <ul>
                    <li><strong>Your start square (colored):</strong> Need a 6 to capture opponents there.</li>
                    <li><strong>Opponent's start square:</strong> They're fully protected - cannot capture.</li>
                    <li>Multiple tokens can stack on start squares.</li>
                    <li><strong>No decorative stars</strong> - this is Nigerian Ludo style!</li>
                </ul>
            </div>

            <div class="rules-section">
                <h3> Finishing</h3>
                <ul>
                    <li>After going around the board, tokens enter their colored home column.</li>
                    <li>Tokens must land on the final square by exact count.</li>
                    <li>Once a token reaches the center, it is safe and scored.</li>
                    <li>First player to get all 4 tokens home wins!</li>
                </ul>
            </div>

            <div class="rules-section">
                <h3> AI Difficulty</h3>
                <ul>
                    <li><strong>Easy:</strong> Makes random valid moves.</li>
                    <li><strong>Medium:</strong> Prioritizes captures and finishing.</li>
                    <li><strong>Hard:</strong> Strategic play with defensive awareness.</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Winner Modal -->
    <div id="winnerModal" class="modal">
        <div class="modal-content">
            <div class="winner-trophy"></div>
            <div class="winner-name" id="winnerName">Red Player</div>
            <div class="winner-subtitle">Wins the Game!</div>
            <button class="start-btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            BOARD_SIZE: 15,
            CELL_SIZE: 1,
            TOKEN_RADIUS: 0.35,
            TOKEN_HEIGHT: 0.4,
            DICE_SIZE: 0.8,
            ANIMATION_SPEED: 0.05,
            AI_DELAY: 800,
            COLORS: {
                RED: 0xe74c3c,
                GREEN: 0x2ecc71,
                YELLOW: 0xf1c40f,
                BLUE: 0x3498db,
                WHITE: 0xffffff,
                BOARD: 0xf5f5dc,
                SAFE: 0xffd700
            }
        };

        // Player color names
        const PLAYER_COLORS = ['red', 'green', 'yellow', 'blue'];
        const PLAYER_HEX = [CONFIG.COLORS.RED, CONFIG.COLORS.GREEN, CONFIG.COLORS.YELLOW, CONFIG.COLORS.BLUE];
        const BASE_PHOTOS = { red: null, green: null, yellow: null, blue: null };
        let WOOD_TEXTURE = null;
        // Exit pads (when a token leaves play after a capture)
        const EXIT_POSITIONS = [
            [ {x: -2.0, z: -9.2}, {x: -3.4, z: -9.2}, {x: -4.8, z: -9.2}, {x: -6.2, z: -9.2} ], // Red (above red quadrant)
            [ {x: 2.0, z: -9.2}, {x: 3.4, z: -9.2}, {x: 4.8, z: -9.2}, {x: 6.2, z: -9.2} ],    // Green (above green quadrant)
            [ {x: 2.0, z: 9.2}, {x: 3.4, z: 9.2}, {x: 4.8, z: 9.2}, {x: 6.2, z: 9.2} ],        // Yellow (below yellow quadrant)
            [ {x: -2.0, z: 9.2}, {x: -3.4, z: 9.2}, {x: -4.8, z: 9.2}, {x: -6.2, z: 9.2} ]     // Blue (below blue quadrant)
        ];

        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer, controls;
        let board, dice, dice2, tokens = [];
        let raycaster, mouse;
        let selectableTokens = [];
        let keyboardSelectedTokenIndex = -1;
        let controlsUserInteracted = false;
        let debugEnabled = false;
        let cellLabelsEnabled = false;
        let debugOverlayEl = null;
        let cellLabelsContainerEl = null;
        let cellLabelItems = null; // [{ el, world }]
        let coachEnabled = true;
        let coachPanelEl = null;
        let coachTextEl = null;
        let coachToggleBtnEl = null;
        let coachMiniBtnEl = null;
        let coachLastText = '';

        function getViewportSize() {
            // visualViewport is more stable on mobile browsers with dynamic address bars.
            const vv = window.visualViewport;
            const width = Math.floor((vv && vv.width) ? vv.width : window.innerWidth);
            const height = Math.floor((vv && vv.height) ? vv.height : window.innerHeight);
            return { width, height };
        }

        function isTouchDevice() {
            return ('ontouchstart' in window) || (navigator.maxTouchPoints || 0) > 0;
        }

        // For UI copy (coach tips), treat devices with a coarse primary pointer as "mobile-like".
        // Some laptops report touch capability even when primarily used with mouse/trackpad.
        function isMobileLikePointer() {
            try {
                if (!window.matchMedia) return isTouchDevice();
                const coarse = window.matchMedia('(pointer: coarse)').matches;
                const hover = window.matchMedia('(hover: hover)').matches;
                return coarse && !hover;
            } catch (_) {
                return isTouchDevice();
            }
        }

        function initCoachOverlay() {
            try {
                const stored = localStorage.getItem('ludoGuideEnabled');
                coachEnabled = stored === null ? true : stored === '1';
            } catch (_) {
                coachEnabled = true;
            }

            coachPanelEl = document.createElement('div');
            coachPanelEl.id = 'coachPanel';

            const header = document.createElement('div');
            header.id = 'coachHeader';

            const title = document.createElement('div');
            title.id = 'coachTitle';
            title.textContent = 'Guide';

            const actions = document.createElement('div');
            actions.id = 'coachActions';

            coachToggleBtnEl = document.createElement('button');
            coachToggleBtnEl.id = 'coachToggleBtn';
            coachToggleBtnEl.type = 'button';
            coachToggleBtnEl.addEventListener('click', () => setCoachEnabled(false));

            actions.appendChild(coachToggleBtnEl);
            header.appendChild(title);
            header.appendChild(actions);

            coachTextEl = document.createElement('div');
            coachTextEl.id = 'coachText';

            coachPanelEl.appendChild(header);
            coachPanelEl.appendChild(coachTextEl);
            document.body.appendChild(coachPanelEl);

            coachMiniBtnEl = document.createElement('button');
            coachMiniBtnEl.id = 'coachMiniBtn';
            coachMiniBtnEl.type = 'button';
            coachMiniBtnEl.textContent = 'Guide: OFF (tap)';
            coachMiniBtnEl.addEventListener('click', () => setCoachEnabled(true));
            document.body.appendChild(coachMiniBtnEl);

            setCoachEnabled(coachEnabled, { silent: true });
        }

        function setCoachEnabled(enabled, opts = {}) {
            coachEnabled = !!enabled;
            if (!opts.silent) {
                try {
                    localStorage.setItem('ludoGuideEnabled', coachEnabled ? '1' : '0');
                } catch (_) {}
            }

            if (coachPanelEl) coachPanelEl.classList.toggle('hidden', !coachEnabled);
            if (coachMiniBtnEl) coachMiniBtnEl.style.display = coachEnabled ? 'none' : 'block';
            if (coachToggleBtnEl) coachToggleBtnEl.textContent = 'Turn off';
        }

        function setCoachText(text) {
            if (!coachPanelEl || !coachTextEl) return;
            const safe = String(text || '').trim();
            if (safe === coachLastText) return;
            coachLastText = safe;
            coachTextEl.textContent = safe;
        }

        function updateCoachOverlay() {
            if (!coachEnabled) return;
            if (!coachPanelEl || !coachTextEl) return;

            // Pre-game
            if (!gameState || !gameState.gameStarted) {
                const titleScreen = document.getElementById('titleScreen');
                if (titleScreen && titleScreen.classList.contains('active')) {
                    const titleRules = document.getElementById('titleRulesModal');
                    if (titleRules && !titleRules.classList.contains('hidden')) {
                        setCoachText('Read the rules summary, then tap I Understand, Continue.');
                        return;
                    }
                    setCoachText(isMobileLikePointer() ? 'Tap Continue to play.' : 'Click Continue to play.');
                    return;
                }
                const mainMenu = document.getElementById('mainMenuScreen');
                if (mainMenu && mainMenu.classList.contains('active')) {
                    setCoachText('Choose a mode to play.');
                    return;
                }
                setCoachText('Choose players, then press Start Game.');
                return;
            }

            // Game ended
            if (gameState.phase === 'ended' || gameState.winner !== null) {
                setCoachText('Game over. Use Restart to play again.');
                return;
            }

            // Die choice prompt
            if (gameState.awaitingDieChoice) {
                if (gameState.dieChoiceMode === 'single') {
                    const v = Array.isArray(gameState.pendingDice) && gameState.pendingDice.length ? gameState.pendingDice[0] : '?';
                    setCoachText(`Use ${v} or Skip.`);
                    return;
                }
                setCoachText('Choose which die to use first.');
                return;
            }

            // Roll phase
            if (gameState.phase === 'roll') {
                if (isMobileLikePointer()) {
                    setCoachText('Tap Roll Dice. Tip: 1 finger rotates, 2 fingers pinch-zoom.');
                } else {
                    setCoachText('Click Roll Dice (Space). Drag to rotate, scroll/pinch to zoom.');
                }
                return;
            }

            // Select phase
            if (gameState.phase === 'select') {
                const die = gameState.currentDieValue || 0;
                if (die) {
                    if (isMobileLikePointer()) {
                        setCoachText(`Tap a highlighted token to move ${die}.`);
                    } else {
                        setCoachText(`Click a highlighted token to move ${die}. (Keyboard: \u2190/\u2192 selects, Enter moves)`);
                    }
                } else {
                    setCoachText('Select a highlighted token.');
                }
                return;
            }

            // Animating / AI
            if (gameState.phase === 'animating') {
                const isAI = getCurrentPlayer && getCurrentPlayer() && getCurrentPlayer().type !== 'human';
                setCoachText(isAI ? 'AI is moving...' : 'Moving...');
                return;
            }

            // Fallback
            setCoachText('');
        }

        function initDebugOverlay() {
            const params = new URLSearchParams(window.location.search);
            debugEnabled = params.get('debug') === '1';
            cellLabelsEnabled = params.get('cells') === '1';
            if (debugEnabled) {
                ensureDebugOverlay();
            }
            if (cellLabelsEnabled) {
                ensureDebugOverlay();
                ensureCellLabelsBuilt();
            }
            // Toggle with Ctrl+Shift+D
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && (e.key === 'D' || e.key === 'd')) {
                    e.preventDefault();
                    setDebugEnabled(!debugEnabled);
                }
            });
            // Toggle with Ctrl+Shift+G
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && (e.key === 'G' || e.key === 'g')) {
                    e.preventDefault();
                    setCellLabelsEnabled(!cellLabelsEnabled);
                }
            });
        }

        function setDebugEnabled(enabled) {
            debugEnabled = !!enabled;
            if (debugEnabled) ensureDebugOverlay();
            if (!debugEnabled) {
                // Hide token labels when cell labels are still shown.
                tokens.forEach(t => {
                    const el = t?.userData?.debugLabelEl;
                    if (el) el.style.display = 'none';
                });
            }
            syncDebugOverlayVisibility();
        }

        function setCellLabelsEnabled(enabled) {
            cellLabelsEnabled = !!enabled;
            if (cellLabelsEnabled) {
                ensureDebugOverlay();
                ensureCellLabelsBuilt();
            }
            if (cellLabelsContainerEl) {
                cellLabelsContainerEl.style.display = cellLabelsEnabled ? 'block' : 'none';
            }
            syncDebugOverlayVisibility();
        }

        function syncDebugOverlayVisibility() {
            if (!debugOverlayEl) return;
            debugOverlayEl.style.display = (debugEnabled || cellLabelsEnabled) ? 'block' : 'none';
        }

        function ensureDebugOverlay() {
            if (debugOverlayEl) return debugOverlayEl;
            debugOverlayEl = document.createElement('div');
            debugOverlayEl.id = 'debugOverlay';
            document.body.appendChild(debugOverlayEl);
            return debugOverlayEl;
        }

        function ensureCellLabelsContainer() {
            if (!debugOverlayEl) return null;
            if (cellLabelsContainerEl) return cellLabelsContainerEl;
            cellLabelsContainerEl = document.createElement('div');
            cellLabelsContainerEl.id = 'cellLabelsContainer';
            cellLabelsContainerEl.style.display = cellLabelsEnabled ? 'block' : 'none';
            debugOverlayEl.appendChild(cellLabelsContainerEl);
            return cellLabelsContainerEl;
        }

        function buildCellLabelDescriptors() {
            const offset = (CONFIG.BOARD_SIZE - 1) / 2;
            const labels = [];
            const letters = ['R', 'G', 'Y', 'B'];

            // Main track: positions 0..51
            for (let i = 0; i < MAIN_TRACK.length; i++) {
                const p = MAIN_TRACK[i];
                labels.push({
                    key: `M${i}`,
                    text: `${i}`,
                    world: new THREE.Vector3(p.x - offset, 0.2, p.y - offset)
                });
            }

            // Home paths: positions 52..57 are player-relative (same numbers, different cells per color)
            for (let playerIndex = 0; playerIndex < HOME_PATHS.length; playerIndex++) {
                const path = HOME_PATHS[playerIndex] || [];
                for (let k = 0; k < path.length; k++) {
                    const pos = 52 + k;
                    const p = path[k];
                    labels.push({
                        key: `H${playerIndex}-${pos}`,
                        text: `${letters[playerIndex]}${pos}`,
                        world: new THREE.Vector3(p.x - offset, 0.2, p.y - offset)
                    });
                }
            }

            return labels;
        }

        function ensureCellLabelsBuilt() {
            if (!debugOverlayEl || !window.THREE) return;
            const container = ensureCellLabelsContainer();
            if (!container) return;
            if (cellLabelItems) return;

            const descriptors = buildCellLabelDescriptors();
            cellLabelItems = descriptors.map(d => {
                const el = document.createElement('div');
                el.className = 'cellLabel';
                el.textContent = d.text;
                container.appendChild(el);
                return { el, world: d.world };
            });
        }

        function ensureDebugLabel(token) {
            if (!debugOverlayEl) return null;
            if (token.userData.debugLabelEl) return token.userData.debugLabelEl;
            const el = document.createElement('div');
            el.className = 'debugLabel';
            el.textContent = '';
            debugOverlayEl.appendChild(el);
            token.userData.debugLabelEl = el;
            return el;
        }

        function removeDebugLabel(token) {
            const el = token?.userData?.debugLabelEl;
            if (el && el.parentNode) el.parentNode.removeChild(el);
            if (token && token.userData) token.userData.debugLabelEl = null;
        }

        function updateDebugOverlay() {
            if ((!debugEnabled && !cellLabelsEnabled) || !debugOverlayEl || !camera) return;
            const vv = window.visualViewport;
            const width = (vv && vv.width) ? vv.width : window.innerWidth;
            const height = (vv && vv.height) ? vv.height : window.innerHeight;
            const offsetLeft = (vv && vv.offsetLeft) ? vv.offsetLeft : 0;
            const offsetTop = (vv && vv.offsetTop) ? vv.offsetTop : 0;

            if (cellLabelsEnabled) {
                ensureCellLabelsBuilt();
                if (cellLabelItems) {
                    for (const item of cellLabelItems) {
                        const world = item.world.clone().project(camera);
                        const onScreen = world.z > -1 && world.z < 1;
                        if (!onScreen) {
                            item.el.style.display = 'none';
                            continue;
                        }
                        item.el.style.display = 'block';
                        const x = (world.x * 0.5 + 0.5) * width + offsetLeft;
                        const y = (-world.y * 0.5 + 0.5) * height + offsetTop;
                        item.el.style.left = `${x}px`;
                        item.el.style.top = `${y}px`;
                    }
                }
            }

            if (debugEnabled) {
                tokens.forEach(token => {
                    const posIndex = token?.userData?.position;
                    if (typeof posIndex !== 'number') return;
                    const label = ensureDebugLabel(token);
                    if (!label) return;

                    const world = token.position.clone();
                    world.y += 1.0;
                    world.project(camera);

                    const onScreen = world.z > -1 && world.z < 1;
                    if (!onScreen) {
                        label.style.display = 'none';
                        return;
                    }
                    label.style.display = 'block';
                    const x = (world.x * 0.5 + 0.5) * width + offsetLeft;
                    const y = (-world.y * 0.5 + 0.5) * height + offsetTop;
                    label.style.left = `${x}px`;
                    label.style.top = `${y}px`;

                    const color = PLAYER_COLORS[token.userData.playerIndex] || '?';
                    const tokenId = `${color[0].toUpperCase()}${token.userData.tokenIndex}`;
                    const exitSlot = token.userData.exitSlot ?? '';
                    const extra = (posIndex >= 52 && posIndex <= 57) ? ` (home ${posIndex})` : '';
                    const exitInfo = (posIndex === 58) ? ` (FIN slot ${exitSlot})` : '';
                    label.textContent = `${tokenId} pos:${posIndex}${extra}${exitInfo}`;
                });
            }
        }

        function applyResponsiveFog() {
            if (!scene || !scene.fog || !camera) return;
            const target = (controls && controls.target) ? controls.target : new THREE.Vector3(0, 0, 0);
            const dist = camera.position.distanceTo(target);
            // Keep the board crisp even when the camera is further back on mobile.
            scene.fog.near = Math.max(12, dist - 26);
            scene.fog.far = Math.max(scene.fog.near + 20, dist + 42);
        }

        function applyResponsiveCamera() {
            if (!camera) return;
            const { width, height } = getViewportSize();
            const aspect = width / Math.max(height, 1);

            // Mobile portrait needs a wider framing to keep the whole board visible.
            if (aspect < 0.85) {
                camera.fov = 60;
                if (!controlsUserInteracted) camera.position.set(0, 26, 22);
            } else if (aspect < 1.15) {
                camera.fov = 54;
                if (!controlsUserInteracted) camera.position.set(0, 20, 16);
            } else {
                camera.fov = 50;
                if (!controlsUserInteracted) camera.position.set(0, 18, 14);
            }
            if (!controlsUserInteracted) camera.lookAt(0, 0, 0);
            camera.updateProjectionMatrix();

            if (controls) {
                if (!controlsUserInteracted) controls.target.set(0, 0, 0);
                controls.minDistance = 10;
                controls.maxDistance = 45;
                controls.update();
            }
            applyResponsiveFog();
        }

        // ==================== GAME STATE ====================
        let gameState = {
            players: [],
            currentPlayer: 0,
            currentOwner: 0, // Used only in 2-player full mode (0 or 1)
            dice: { d1: 0, d2: 0 },
            pendingDice: [],
            currentDieValue: 0,
            doubleSixBonus: false,
            captureBonus: false,
            phase: 'roll', // roll, select, animating
            bonusStreak: 0,
            gameStarted: false,
            winner: null,
            soundEnabled: true,
            awaitingDieChoice: false,
            dieChoiceMode: null, // 'order' | 'single' | null
            confirmedDieValue: null, // number | null (home-lane "use/skip" confirmation)
            noSpawnThisDie: false, // used for combined-move dice (prevents treating sum==6 as a spawn)
            suppressCaptureThisMove: false // used for forced "spawn + continue" so start-square doesn't capture mid-way
        };

        let gameMode = 'vsAI'; // vsAI, local, online
        let peer = null; // PeerJS peer instance
        let connection = null; // Active peer connection
        let isHost = false; // Whether this player is the host in online games
        let myPlayerIndex = 0; // Which player index this client controls in online games

        function isOnlineGame() {
            return gameMode === 'online' && connection && connection.open;
        }

        function ownsTurnColor(colorIdx) {
            return isFullMode() ? ownerForColor(colorIdx) === ownerForColor(myPlayerIndex) : colorIdx === myPlayerIndex;
        }

        function isMyTurn() {
            if (!isOnlineGame()) return true;
            return ownsTurnColor(gameState.currentPlayer);
        }

        // ==================== TURN TIMER ====================
        let turnTimer = null;
        let turnTimeRemaining = 30; // 30 seconds per turn
        const TURN_TIME_LIMIT = 30;

        function startTurnTimer() {
            stopTurnTimer(); // Clear any existing timer
            turnTimeRemaining = TURN_TIME_LIMIT;

            const timerDisplay = document.getElementById('turnTimer');
            const timerSeconds = document.getElementById('timerSeconds');
            const currentPlayer = getCurrentPlayer();
            if (!currentPlayer) {
                timerDisplay.style.display = 'none';
                return;
            }

            // Only show timer for human players
            if (currentPlayer.type === 'human' && isMyTurn()) {
                timerDisplay.style.display = 'inline-block';
                timerSeconds.textContent = turnTimeRemaining;
                timerDisplay.className = ''; // Reset classes

                turnTimer = setInterval(() => {
                    turnTimeRemaining--;
                    timerSeconds.textContent = turnTimeRemaining;

                    // Update timer appearance based on time remaining
                    if (turnTimeRemaining <= 5) {
                        timerDisplay.className = 'critical';
                    } else if (turnTimeRemaining <= 10) {
                        timerDisplay.className = 'warning';
                    }

                    // Time's up! Auto-skip turn
                    if (turnTimeRemaining <= 0) {
                        stopTurnTimer();
                        showNotification(' Time\'s up! Turn skipped.', 'warning');
                        AudioManager.play('move');
                        setTimeout(nextTurn, 800);
                    }
                }, 1000);
            } else {
                timerDisplay.style.display = 'none';
            }
        }

        function stopTurnTimer() {
            if (turnTimer) {
                clearInterval(turnTimer);
                turnTimer = null;
            }
            const timerDisplay = document.getElementById('turnTimer');
            timerDisplay.style.display = 'none';
            timerDisplay.className = '';
        }

        // ==================== BOARD PATH DEFINITIONS ====================
        // Define the path for each player (52 main squares + 6 home squares)
        // Positions are in grid coordinates (0-14, 0-14)

        // Main track positions (shared path, 52 squares)
        const MAIN_TRACK = [
            // Red's exit and bottom row going right
            {x: 1, y: 6}, {x: 2, y: 6}, {x: 3, y: 6}, {x: 4, y: 6}, {x: 5, y: 6},
            // Up the right side
            {x: 6, y: 5}, {x: 6, y: 4}, {x: 6, y: 3}, {x: 6, y: 2}, {x: 6, y: 1}, {x: 6, y: 0},
            // Across top
            {x: 7, y: 0}, {x: 8, y: 0},
            // Green's side going down
            {x: 8, y: 1}, {x: 8, y: 2}, {x: 8, y: 3}, {x: 8, y: 4}, {x: 8, y: 5},
            // Right side going down
            {x: 9, y: 6}, {x: 10, y: 6}, {x: 11, y: 6}, {x: 12, y: 6}, {x: 13, y: 6}, {x: 14, y: 6},
            // Down turn
            {x: 14, y: 7}, {x: 14, y: 8},
            // Yellow's side going left
            {x: 13, y: 8}, {x: 12, y: 8}, {x: 11, y: 8}, {x: 10, y: 8}, {x: 9, y: 8},
            // Down the right side
            {x: 8, y: 9}, {x: 8, y: 10}, {x: 8, y: 11}, {x: 8, y: 12}, {x: 8, y: 13}, {x: 8, y: 14},
            // Across bottom
            {x: 7, y: 14}, {x: 6, y: 14},
            // Blue's side going up
            {x: 6, y: 13}, {x: 6, y: 12}, {x: 6, y: 11}, {x: 6, y: 10}, {x: 6, y: 9},
            // Left side going up
            {x: 5, y: 8}, {x: 4, y: 8}, {x: 3, y: 8}, {x: 2, y: 8}, {x: 1, y: 8}, {x: 0, y: 8},
            // Up turn
            {x: 0, y: 7}, {x: 0, y: 6}
        ];

        // Starting positions on main track for each player
        const START_POSITIONS = [0, 13, 26, 39]; // Red, Green, Yellow, Blue
        const START_POS_SET = new Set(START_POSITIONS);

        // Home column paths (after completing the track)
        const HOME_PATHS = [
            // Red: enters from left, goes right toward center
            [{x: 1, y: 7}, {x: 2, y: 7}, {x: 3, y: 7}, {x: 4, y: 7}, {x: 5, y: 7}, {x: 6, y: 7}],
            // Green: enters from top, goes down toward center
            [{x: 7, y: 1}, {x: 7, y: 2}, {x: 7, y: 3}, {x: 7, y: 4}, {x: 7, y: 5}, {x: 7, y: 6}],
            // Yellow: enters from right, goes left toward center
            [{x: 13, y: 7}, {x: 12, y: 7}, {x: 11, y: 7}, {x: 10, y: 7}, {x: 9, y: 7}, {x: 8, y: 7}],
            // Blue: enters from bottom, goes up toward center
            [{x: 7, y: 13}, {x: 7, y: 12}, {x: 7, y: 11}, {x: 7, y: 10}, {x: 7, y: 9}, {x: 7, y: 8}]
        ];

        // Base (home) positions for tokens before entering the game
        const BASE_POSITIONS = [
            // Red base (top-left)
            [{x: 2.5, y: 2.5}, {x: 3.5, y: 2.5}, {x: 2.5, y: 3.5}, {x: 3.5, y: 3.5}],
            // Green base (top-right)
            [{x: 11.5, y: 2.5}, {x: 12.5, y: 2.5}, {x: 11.5, y: 3.5}, {x: 12.5, y: 3.5}],
            // Yellow base (bottom-right)
            [{x: 11.5, y: 11.5}, {x: 12.5, y: 11.5}, {x: 11.5, y: 12.5}, {x: 12.5, y: 12.5}],
            // Blue base (bottom-left)
            [{x: 2.5, y: 11.5}, {x: 3.5, y: 11.5}, {x: 2.5, y: 12.5}, {x: 3.5, y: 12.5}]
        ];

        // Safe square indices on main track - Nigerian Ludo rules
        // Only start squares have special protection rules (not the star squares)
        const SAFE_SQUARES = [0, 13, 26, 39]; // Starting squares only (Red, Green, Yellow, Blue)

        // Dice face materials cache
        const DIE_MATERIALS = [];

        // ==================== AUDIO ====================
        const AudioManager = {
            context: null,
            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            },
            resume() {
                if (this.context && this.context.state === 'suspended') {
                    this.context.resume().catch(() => {});
                }
            },
            play(type) {
                if (!this.context || !gameState.soundEnabled) return;

                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                switch(type) {
                    case 'roll':
                        oscillator.frequency.setValueAtTime(200, this.context.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(400, this.context.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.2);
                        break;
                    case 'move':
                        oscillator.frequency.setValueAtTime(523, this.context.currentTime);
                        gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.1);
                        break;
                    case 'capture':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(150, this.context.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(50, this.context.currentTime + 0.3);
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.3);
                        break;
                    case 'six':
                        oscillator.frequency.setValueAtTime(523, this.context.currentTime);
                        oscillator.frequency.setValueAtTime(659, this.context.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(784, this.context.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.3);
                        break;
                    case 'win':
                        const notes = [523, 659, 784, 1047];
                        notes.forEach((freq, i) => {
                            const osc = this.context.createOscillator();
                            const gain = this.context.createGain();
                            osc.connect(gain);
                            gain.connect(this.context.destination);
                            osc.frequency.setValueAtTime(freq, this.context.currentTime + i * 0.15);
                            gain.gain.setValueAtTime(0.3, this.context.currentTime + i * 0.15);
                            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + i * 0.15 + 0.3);
                            osc.start(this.context.currentTime + i * 0.15);
                            osc.stop(this.context.currentTime + i * 0.15 + 0.3);
                        });
                        break;
                    case 'home':
                        oscillator.frequency.setValueAtTime(784, this.context.currentTime);
                        oscillator.frequency.setValueAtTime(1047, this.context.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.2);
                        break;
                }
            }
        };

        // ==================== ONLINE MULTIPLAYER ====================
        function generateRoomCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function getPeerJsOptions() {
            const params = new URLSearchParams(window.location.search);
            const host = params.get('peerHost');
            const portRaw = params.get('peerPort');
            const path = params.get('peerPath');
            const secureRaw = params.get('peerSecure');
            const key = params.get('peerKey');

            if (!host && !portRaw && !path && !secureRaw && !key) {
                return undefined; // Use PeerJS defaults
            }

            const opts = { debug: 2 };
            if (host) opts.host = host;
            if (path) opts.path = path;
            if (key) opts.key = key;
            if (portRaw) {
                const port = parseInt(portRaw, 10);
                if (!Number.isNaN(port)) opts.port = port;
            }
            if (secureRaw !== null) {
                opts.secure = secureRaw === '1' || secureRaw.toLowerCase() === 'true';
            }
            return opts;
        }

        function initializePeer(roomCode) {
            if (peer) {
                peer.destroy();
            }
            peer = new Peer(roomCode, getPeerJsOptions());

            peer.on('open', (id) => {
                console.log('Peer initialized with ID:', id);
            });

            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                showLobbyError(err.type === 'peer-unavailable' ? 'Room code not found' : 'Connection error');
            });
        }

        function createGame() {
            const roomCode = generateRoomCode();
            initializePeer(roomCode);
            isHost = true;
            myPlayerIndex = 0;

            document.getElementById('lobbyInitial').classList.remove('active');
            document.getElementById('lobbyCreate').classList.add('active');
            document.getElementById('roomCodeDisplay').textContent = roomCode;

            peer.on('connection', (conn) => {
                connection = conn;
                setupConnection();
                document.getElementById('createStatus').textContent = 'Opponent connected!';
                document.getElementById('createStatus').className = 'lobby-status connected';

                setTimeout(() => {
                    hideModal('onlineLobby');
                    gameMode = 'online';
                    showModal('startMenu');
                    refreshStartButton();
                }, 1500);
            });
        }

        function joinGame() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (roomCode.length !== 4) {
                showLobbyError('Please enter a 4-digit room code');
                return;
            }

            isHost = false;
            myPlayerIndex = 1;

            const tempPeer = new Peer(getPeerJsOptions());
            tempPeer.on('open', () => {
                connection = tempPeer.connect(roomCode);
                peer = tempPeer;
                setupConnection();

                connection.on('open', () => {
                    document.getElementById('joinStatus').textContent = 'Connected successfully!';
                    document.getElementById('joinStatus').className = 'lobby-status connected';
                    document.getElementById('joinStatus').style.display = 'block';

                    setTimeout(() => {
                        hideModal('onlineLobby');
                        gameMode = 'online';
                        showModal('startMenu');
                        refreshStartButton();
                    }, 1500);
                });

                connection.on('error', (err) => {
                    showLobbyError('Failed to connect to game');
                });
            });

            tempPeer.on('error', (err) => {
                showLobbyError(err.type === 'peer-unavailable' ? 'Room not found' : 'Connection error');
            });
        }

        function setupConnection() {
            if (!connection) return;

            connection.on('data', (data) => {
                handlePeerData(data);
            });

            connection.on('close', () => {
                showNotification('Opponent disconnected', 'error');
                connection = null;
            });
        }

        function sendGameState(action, payload) {
            if (connection && connection.open) {
                connection.send({ action, payload });
            }
        }

        function applyRemoteDiceRoll(d1, d2) {
            if (!dice || !dice2) return;
            gameState.dice = { d1, d2 };
            gameState.pendingDice = [d1, d2];
            gameState.currentDieValue = 0;
            gameState.doubleSixBonus = (d1 === 6 && d2 === 6);
            gameState.awaitingDieChoice = false;
            gameState.dieChoiceMode = null;
            gameState.confirmedDieValue = null;
            gameState.noSpawnThisDie = false;
            gameState.phase = 'select';
            hideDieChoice();
            clearHighlights();
            setDieValue(dice, d1);
            setDieValue(dice2, d2);
            document.getElementById('diceResult').textContent = ` ${d1} & ${d2}`;
            updateTurnDisplay();
        }

        function handlePeerData(data) {
            const { action, payload } = data;

            switch (action) {
                case 'startGame':
                    gameMode = 'online';
                    gameState.players = payload.players || [];
                    gameState.currentPlayer = payload.currentPlayer || 0;
                    gameState.dice = { d1: 0, d2: 0 };
                    gameState.pendingDice = [];
                    gameState.currentDieValue = 0;
                    gameState.doubleSixBonus = false;
                    gameState.captureBonus = false;
                    gameState.phase = 'roll';
                    gameState.bonusStreak = 0;
                    gameState.gameStarted = true;
                    gameState.winner = null;
                    gameState.awaitingDieChoice = false;
                    gameState.dieChoiceMode = null;
                    gameState.confirmedDieValue = null;

                    createAllTokens();
                    updatePlayerPanel();
                    updateTurnDisplay();
                    hideModal('onlineLobby');
                    hideModal('startMenu');
                    const mainMenu = document.getElementById('mainMenuScreen');
                    if (mainMenu) mainMenu.classList.remove('active');
                    startTurnTimer();
                    break;

                case 'diceRoll':
                    applyRemoteDiceRoll(payload.d1, payload.d2);
                    break;

                case 'tokenMove':
                    const token = tokens.find(t =>
                        t.userData.playerIndex === payload.playerIndex &&
                        t.userData.tokenIndex === payload.tokenIndex
                    );
                    if (token) {
                        gameState.currentPlayer = payload.playerIndex;
                        gameState.currentDieValue = payload.dieValue || 0;
                        executeMove(token, payload.newPosition, payload.moveType || 'move', payload.dieValue || 0, true, false);
                    }
                    break;

                case 'nextTurn':
                    gameState.currentPlayer = payload.currentPlayer;
                    gameState.phase = 'roll';
                    gameState.pendingDice = [];
                    gameState.currentDieValue = 0;
                    gameState.doubleSixBonus = false;
                    gameState.captureBonus = false;
                    gameState.awaitingDieChoice = false;
                    gameState.dieChoiceMode = null;
                    gameState.confirmedDieValue = null;
                    document.getElementById('diceResult').textContent = '';
                    hideDieChoice();
                    clearHighlights();
                    stopTurnTimer();
                    updateTurnDisplay();
                    startTurnTimer();
                    break;

                case 'gameOver':
                    gameWon(payload.winner, true);
                    break;
            }
        }

        function showLobbyError(message) {
            const statusEl = document.getElementById('joinStatus');
            statusEl.textContent = message;
            statusEl.className = 'lobby-status error';
            statusEl.style.display = 'block';
        }

        function resetLobby() {
            document.getElementById('lobbyInitial').classList.add('active');
            document.getElementById('lobbyCreate').classList.remove('active');
            document.getElementById('lobbyJoin').classList.remove('active');
            document.getElementById('roomCodeInput').value = '';
            document.getElementById('joinStatus').style.display = 'none';
            if (connection) {
                connection.close();
                connection = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            isHost = false;
            myPlayerIndex = 0;
            refreshStartButton();
        }

        // ==================== INITIALIZATION ====================
        function enhanceRollDiceButtonUI() {
            const btn = document.getElementById('rollDiceBtn');
            if (!btn) return;

            // Replace legacy inner HTML with a richer layout (keeps the same button + listeners)
            if (!btn.querySelector('.dice-cube')) {
                btn.innerHTML = `
                    <span class="dice-cube" aria-hidden="true"></span>
                    <span class="rollDiceBtn__text">
                        <span class="rollDiceBtn__title">Roll Dice</span>
                        <span class="rollDiceBtn__hint">Tap / Space</span>
                    </span>
                    <span class="rollDiceBtn__chev" aria-hidden="true"></span>
                `.trim();
            }
            btn.setAttribute('aria-label', 'Roll Dice');
        }

        function init() {
            initDebugOverlay();
            initCoachOverlay();
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 15, 35);
            buildDieMaterials();

            // Camera
            const vp0 = getViewportSize();
            camera = new THREE.PerspectiveCamera(50, vp0.width / vp0.height, 0.1, 1000);
            camera.position.set(0, 18, 14);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(vp0.width, vp0.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.domElement.style.touchAction = 'none';
            // Prevent iOS Safari page-zoom/scroll gestures from hijacking the canvas.
            const preventGesture = (e) => { if (e && e.cancelable) e.preventDefault(); };
            renderer.domElement.addEventListener('touchstart', preventGesture, { passive: false });
            renderer.domElement.addEventListener('touchmove', preventGesture, { passive: false });
            renderer.domElement.addEventListener('gesturestart', preventGesture, { passive: false });
            renderer.domElement.addEventListener('gesturechange', preventGesture, { passive: false });
            renderer.domElement.addEventListener('gestureend', preventGesture, { passive: false });
            renderer.domElement.addEventListener('click', resumeAudioIfNeeded, { passive: true });
            renderer.domElement.addEventListener('touchstart', resumeAudioIfNeeded, { passive: true });

            // Orbit controls for 3D rotation
            if (THREE.OrbitControls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 0, 0);
                controls.enableDamping = true;
                controls.dampingFactor = 0.08;
                controls.rotateSpeed = 0.45;
                controls.enableZoom = true;
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.minDistance = 10;
                controls.maxDistance = 40;
                if (typeof controls.addEventListener === 'function') {
                    controls.addEventListener('start', () => { controlsUserInteracted = true; });
                }
            } else {
                controls = null;
            }

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -15;
            mainLight.shadow.camera.right = 15;
            mainLight.shadow.camera.top = 15;
            mainLight.shadow.camera.bottom = -15;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x6666ff, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            // Raycaster for token selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create board
            loadBasePhotos();
            createBoard();

            // Create dice pair
            createDicePair();

            // Audio
            AudioManager.init();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', onWindowResize);
            }
            document.getElementById('gameCanvas').addEventListener('click', onCanvasClick);
            document.getElementById('gameCanvas').addEventListener('touchend', onCanvasTouch, { passive: false });
            document.getElementById('rollDiceBtn').addEventListener('click', rollDice);
            enhanceRollDiceButtonUI();
            document.getElementById('rulesBtn').addEventListener('click', () => showModal('rulesModal'));
            document.getElementById('closeRules').addEventListener('click', () => hideModal('rulesModal'));
            document.getElementById('resetBtn').addEventListener('click', () => showModal('startMenu'));
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            function openMainMenuFromTitle() {
                document.getElementById('titleScreen').classList.remove('active');
                document.getElementById('mainMenuScreen').classList.add('active');
            }

            function showTitleRulesGate() {
                const modal = document.getElementById('titleRulesModal');
                if (!modal) return false;
                modal.classList.remove('hidden');
                return true;
            }

            function hideTitleRulesGate() {
                const modal = document.getElementById('titleRulesModal');
                if (!modal) return;
                modal.classList.add('hidden');
            }

            function titleRulesGateAcknowledged() {
                try {
                    return localStorage.getItem('titleRulesAck') === '1';
                } catch (_) {
                    return false;
                }
            }

            function setTitleRulesGateAcknowledged(ack) {
                try {
                    localStorage.setItem('titleRulesAck', ack ? '1' : '0');
                } catch (_) {}
            }

            document.getElementById('titleContinueBtn').addEventListener('click', () => {
                if (titleRulesGateAcknowledged()) {
                    openMainMenuFromTitle();
                    return;
                }
                showTitleRulesGate();
            });

            const titleRulesBackBtn = document.getElementById('titleRulesBackBtn');
            if (titleRulesBackBtn) {
                titleRulesBackBtn.addEventListener('click', () => hideTitleRulesGate());
            }

            const titleRulesContinueBtn = document.getElementById('titleRulesContinueBtn');
            if (titleRulesContinueBtn) {
                titleRulesContinueBtn.addEventListener('click', () => {
                    const dontShow = document.getElementById('titleRulesDontShow');
                    if (dontShow && dontShow.checked) setTitleRulesGateAcknowledged(true);
                    hideTitleRulesGate();
                    openMainMenuFromTitle();
                });
            }

            // Main menu buttons
            document.getElementById('playOnlineBtn').addEventListener('click', () => {
                showNotification('Online multiplayer coming soon!');
            });

            document.getElementById('playVsAIBtn').addEventListener('click', () => {
                document.getElementById('mainMenuScreen').classList.remove('active');
                gameMode = 'vsAI';
                showModal('startMenu');
                refreshStartButton();
            });

            document.getElementById('playLocalBtn').addEventListener('click', () => {
                document.getElementById('mainMenuScreen').classList.remove('active');
                gameMode = 'local';
                showModal('startMenu');
                refreshStartButton();
            });

            document.getElementById('playAgainBtn').addEventListener('click', () => {
                hideModal('winnerModal');
                showModal('startMenu');
                refreshStartButton();
            });
            document.getElementById('soundBtn').addEventListener('click', toggleSound);
            document.getElementById('chooseDie1').addEventListener('click', () => chooseDieOrder(0));
            document.getElementById('chooseDie2').addEventListener('click', () => chooseDieOrder(1));
            document.getElementById('skipDie').addEventListener('click', skipCurrentDie);
            document.addEventListener('keydown', handleKeyboardShortcuts);

            // Player type selection
            document.querySelectorAll('.player-type-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const playerIdx = parseInt(e.target.dataset.player);
                    const option = e.target.closest('.player-option');
                    if (e.target.value === 'none') {
                        option.classList.remove('selected');
                    } else {
                        option.classList.add('selected');
                    }
                });
            });

            // Player count selection - disable 2-player mode for 3 or 4 players
            document.querySelectorAll('input[name="playerCount"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const playerCount = e.target.value;
                    const twoPlayerContainer = document.getElementById('twoPlayerModeContainer');
                    const twoPlayerHalf = document.getElementById('twoPlayerHalf');
                    const twoPlayerFull = document.getElementById('twoPlayerFull');
                    const label1 = document.getElementById('twoPlayerModeLabel1');
                    const label2 = document.getElementById('twoPlayerModeLabel2');

                    if (playerCount === '3' || playerCount === '4') {
                        // Disable 2-player mode options
                        twoPlayerHalf.disabled = true;
                        twoPlayerFull.disabled = true;
                        twoPlayerContainer.style.opacity = '0.4';
                        label1.style.cursor = 'not-allowed';
                        label2.style.cursor = 'not-allowed';
                    } else {
                        // Enable 2-player mode options
                        twoPlayerHalf.disabled = false;
                        twoPlayerFull.disabled = false;
                        twoPlayerContainer.style.opacity = '1';
                        label1.style.cursor = 'pointer';
                        label2.style.cursor = 'pointer';
                    }
                });
            });

            // Intro sequence
            runIntroSequence();

            // Start animation loop
            applyResponsiveCamera();
            animate();
        }

        function runIntroSequence() {
            // Initialize splash particles immediately
            initSplashParticles();
            // Title screen is already active in HTML, no need to show it
        }

        function initSplashParticles() {
            const particlesContainer = document.querySelector('.splash-particles');
            const particleCount = 30;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';

                const size = Math.random() * 6 + 3;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (Math.random() * 2 + 2) + 's';

                particlesContainer.appendChild(particle);
            }
        }

        function showDieChoice(d1, d2, opts = {}) {
            const { singleMode = false, allowSkip = false, singleValue = null } = opts;
            const wrap = document.getElementById('dieChoice');
            const b1 = document.getElementById('chooseDie1');
            const b2 = document.getElementById('chooseDie2');
            const skipBtn = document.getElementById('skipDie');

            if (singleMode) {
                b1.textContent = `Use: ${singleValue ?? d1}`;
                b2.classList.add('hidden');
            } else {
                b1.textContent = `First: ${d1}`;
                b2.textContent = `First: ${d2}`;
                b2.classList.remove('hidden');
            }

            wrap.classList.remove('hidden');
            b1.disabled = false;
            b2.disabled = false;

            if (allowSkip) {
                skipBtn.classList.remove('hidden');
                skipBtn.disabled = false;
            } else {
                skipBtn.classList.add('hidden');
            }
        }

        function hideDieChoice() {
            const wrap = document.getElementById('dieChoice');
            if (wrap) wrap.classList.add('hidden');
        }

        function chooseDieOrder(index) {
            if (!gameState.awaitingDieChoice) return;

            // Single-die confirmation mode (used for home-lane "use or skip" luxury)
            if (gameState.dieChoiceMode === 'single') {
                gameState.awaitingDieChoice = false;
                gameState.confirmedDieValue = Array.isArray(gameState.pendingDice) && gameState.pendingDice.length ? gameState.pendingDice[0] : null;
                gameState.dieChoiceMode = null;
                hideDieChoice();
                processNextDie();
                return;
            }

            if (gameState.pendingDice.length < 2) return;
            const d1 = gameState.dice.d1;
            const d2 = gameState.dice.d2;
            gameState.pendingDice = index === 0 ? [d1, d2] : [d2, d1];
            gameState.awaitingDieChoice = false;
            gameState.confirmedDieValue = Array.isArray(gameState.pendingDice) && gameState.pendingDice.length ? gameState.pendingDice[0] : null;
            gameState.dieChoiceMode = null;
            hideDieChoice();
            processNextDie();
        }

        function skipCurrentDie() {
            if (!gameState.awaitingDieChoice) return;
            gameState.pendingDice.shift();
            gameState.awaitingDieChoice = false;
            gameState.confirmedDieValue = null;
            gameState.dieChoiceMode = null;
            hideDieChoice();
            processNextDie();
        }

        // ==================== BOARD CREATION ====================
        function createBoard() {
            const boardGroup = new THREE.Group();
            const size = CONFIG.BOARD_SIZE;
            const cellSize = CONFIG.CELL_SIZE;
            const offset = (size - 1) / 2;
            const safeCoordSet = new Set(SAFE_SQUARES.map(idx => {
                const pos = MAIN_TRACK[idx];
                return `${pos.x},${pos.y}`;
            }));

            // Main board base
            const boardGeometry = new THREE.BoxGeometry(size + 0.5, 0.3, size + 0.5);
            const boardMaterial = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.BOARD,
                roughness: 0.8
            });
            const boardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
            boardMesh.position.y = -0.15;
            boardMesh.receiveShadow = true;
            boardGroup.add(boardMesh);

            // Wooden border frame (walnut-like), built as a single rectangular frame (no corner overlaps/gaps)
            const outerBorderSize = size + 1.05;
            const innerBorderSize = size + 0.45; // tighter to the board so there isn't a visible "hole"
            const borderHeight = 0.42;
            const halfOuter = outerBorderSize / 2;
            const halfInner = innerBorderSize / 2;

            const woodTex = getWoodTexture();
            if (woodTex && renderer) {
                woodTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            }
            const borderMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a3a26, // walnut base tint
                map: woodTex,
                roughness: 0.65,
                metalness: 0.0
            });
            const topAboveBoard = 0.08; // wood top slightly above the board surface (0)
            const borderBottomY = topAboveBoard - borderHeight;

            const frameShape = new THREE.Shape();
            frameShape.moveTo(-halfOuter, -halfOuter);
            frameShape.lineTo(halfOuter, -halfOuter);
            frameShape.lineTo(halfOuter, halfOuter);
            frameShape.lineTo(-halfOuter, halfOuter);
            frameShape.lineTo(-halfOuter, -halfOuter);

            const hole = new THREE.Path();
            hole.moveTo(-halfInner, -halfInner);
            hole.lineTo(-halfInner, halfInner);
            hole.lineTo(halfInner, halfInner);
            hole.lineTo(halfInner, -halfInner);
            hole.lineTo(-halfInner, -halfInner);
            frameShape.holes.push(hole);

            const frameGeom = new THREE.ExtrudeGeometry(frameShape, { depth: borderHeight, bevelEnabled: false });
            const frameMesh = new THREE.Mesh(frameGeom, borderMaterial);
            frameMesh.rotation.x = -Math.PI / 2;
            frameMesh.position.y = borderBottomY;
            frameMesh.receiveShadow = true;
            boardGroup.add(frameMesh);

            // Create cells
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    const cellColor = getCellColor(x, y);
                    if (cellColor !== null) {
                        const coordKey = `${x},${y}`;
                        const finalColor = (cellColor === 0xffffff && safeCoordSet.has(coordKey)) ? 0xdedede : cellColor;
                        const cellGeometry = new THREE.BoxGeometry(cellSize * 0.95, 0.1, cellSize * 0.95);
                        const cellMaterial = new THREE.MeshStandardMaterial({
                            color: finalColor,
                            roughness: 0.7
                        });
                        const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                        cell.position.set(x - offset, 0.05, y - offset);
                        cell.receiveShadow = true;
                        boardGroup.add(cell);
                    }
                }
            }

            // Explicitly tint starting squares for each player (covers green/blue visibility)
            const explicitStarts = [
                { pos: { x: 1, y: 6 }, color: PLAYER_HEX[0] },  // Red
                { pos: { x: 8, y: 1 }, color: PLAYER_HEX[1] },  // Green (top)
                { pos: { x: 13, y: 8 }, color: PLAYER_HEX[2] }, // Yellow
                { pos: { x: 6, y: 13 }, color: PLAYER_HEX[3] }  // Blue (bottom)
            ];
            explicitStarts.forEach(({ pos, color }) => {
                const tileGeometry = new THREE.BoxGeometry(cellSize * 0.95, 0.14, cellSize * 0.95);
                const tileMaterial = new THREE.MeshStandardMaterial({
                    color,
                    roughness: 0.45,
                    metalness: 0.1
                });
                const tile = new THREE.Mesh(tileGeometry, tileMaterial);
                tile.position.set(pos.x - offset, 0.09, pos.y - offset);
                tile.receiveShadow = true;
                boardGroup.add(tile);
            });

            // Nigerian-inspired emblems in home boxes
            addBaseEmblems(boardGroup, offset);

            // Nigerian Ludo: No star decorations on the board
            // SAFE_SQUARES only contains start positions [0, 13, 26, 39] which are already
            // colored differently, so no additional markers are needed
            // (Old versions had decorative stars at positions 8, 21, 34, 47 but those are
            // regular squares in Nigerian Ludo - you CAN capture there)

            // Reinforce home lane colors visually
            HOME_PATHS.forEach((path, playerIndex) => {
                path.forEach(pos => {
                    const tileGeometry = new THREE.BoxGeometry(cellSize * 0.95, 0.11, cellSize * 0.95);
                    const tileMaterial = new THREE.MeshStandardMaterial({
                        color: PLAYER_HEX[playerIndex],
                        roughness: 0.5
                    });
                    const tile = new THREE.Mesh(tileGeometry, tileMaterial);
                    tile.position.set(pos.x - offset, 0.055, pos.y - offset);
                    tile.receiveShadow = true;
                    boardGroup.add(tile);
                });
            });

            // Center finish area split into four triangular diagonals (red, blue, green, yellow)
            const centerGroup = new THREE.Group();
            const shapes = [
                // Top (green)
                { color: PLAYER_HEX[1], points: [[-1.5, -1.5], [1.5, -1.5], [0, 0]] },
                // Left (red)
                { color: PLAYER_HEX[0], points: [[-1.5, -1.5], [0, 0], [-1.5, 1.5]] },
                // Bottom (blue)
                { color: PLAYER_HEX[3], points: [[0, 0], [1.5, 1.5], [-1.5, 1.5]] },
                // Right (yellow)
                { color: PLAYER_HEX[2], points: [[1.5, -1.5], [1.5, 1.5], [0, 0]] }
            ];
            shapes.forEach(cfg => {
                const shape = new THREE.Shape();
                shape.moveTo(cfg.points[0][0], cfg.points[0][1]);
                shape.lineTo(cfg.points[1][0], cfg.points[1][1]);
                shape.lineTo(cfg.points[2][0], cfg.points[2][1]);
                shape.lineTo(cfg.points[0][0], cfg.points[0][1]);
                const geom = new THREE.ExtrudeGeometry(shape, { depth: 0.08, bevelEnabled: false });
                const mat = new THREE.MeshStandardMaterial({
                    color: cfg.color,
                    roughness: 0.35,
                    metalness: 0.35
                });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(0, 0.04, 0);
                mesh.receiveShadow = true;
                centerGroup.add(mesh);
            });
            boardGroup.add(centerGroup);

            scene.add(boardGroup);

            board = boardGroup;
        }

        function getCellColor(x, y) {
            const size = CONFIG.BOARD_SIZE;

            // Red base (top-left 6x6)
            if (x < 6 && y < 6) {
                if (x >= 1 && x <= 4 && y >= 1 && y <= 4) {
                    return (x === 1 || x === 4) && (y === 1 || y === 4) ? 0xffffff : null;
                }
                return CONFIG.COLORS.RED;
            }

            // Blue base (bottom-left 6x6)
            if (x < 6 && y > 8) {
                if (x >= 1 && x <= 4 && y >= 10 && y <= 13) {
                    return (x === 1 || x === 4) && (y === 10 || y === 13) ? 0xffffff : null;
                }
                return CONFIG.COLORS.BLUE;
            }

            // Yellow base (bottom-right 6x6)
            if (x > 8 && y > 8) {
                if (x >= 10 && x <= 13 && y >= 10 && y <= 13) {
                    return (x === 10 || x === 13) && (y === 10 || y === 13) ? 0xffffff : null;
                }
                return CONFIG.COLORS.YELLOW;
            }

            // Green base (top-right 6x6)
            if (x > 8 && y < 6) {
                if (x >= 10 && x <= 13 && y >= 1 && y <= 4) {
                    return (x === 10 || x === 13) && (y === 1 || y === 4) ? 0xffffff : null;
                }
                return CONFIG.COLORS.GREEN;
            }

            // Home columns (top=green, bottom=blue)
            if (x === 7 && y >= 1 && y <= 6) return CONFIG.COLORS.GREEN; // Green path to center (top side)
            if (x === 7 && y >= 8 && y <= 13) return CONFIG.COLORS.BLUE; // Blue path to center (bottom side)
            if (y === 7 && x >= 1 && x <= 6) return CONFIG.COLORS.RED; // Red home (left to center)
            if (y === 7 && x >= 8 && x <= 13) return CONFIG.COLORS.YELLOW; // Yellow home (right to center)

            // Starting squares (colored)
            if (x === 1 && y === 6) return CONFIG.COLORS.RED;
            if (x === 8 && y === 1) return CONFIG.COLORS.GREEN;
            if (x === 13 && y === 8) return CONFIG.COLORS.YELLOW;
            if (x === 6 && y === 13) return CONFIG.COLORS.BLUE;

            // Main path (white/cream)
            if ((x === 6 || x === 7 || x === 8) || (y === 6 || y === 7 || y === 8)) {
                if (x >= 0 && x < size && y >= 0 && y < size) {
                    if (!((x === 7 && y === 7))) { // Skip very center
                        return 0xffffff;
                    }
                }
            }

            return null;
        }

        // Add Nigerian-inspired emblems to each player's home box (fills the blank white corners)
        function addBaseEmblems(boardGroup, offset) {
            const emblemDefs = [
                { pos: { x: 2.5, y: 2.5 }, rot: 0 },   // Red box
                { pos: { x: 11.5, y: 2.5 }, rot: 0 }, // Green box
                { pos: { x: 11.5, y: 11.5 }, rot: 0 }, // Yellow box
                { pos: { x: 2.5, y: 11.5 }, rot: 0 }  // Blue box
            ];

            const fallbackTexture = createNaijaTexture();
            const getMat = (idx) => {
                let tex = fallbackTexture;
                if (idx === 0 && BASE_PHOTOS.red) tex = BASE_PHOTOS.red;
                if (idx === 1 && BASE_PHOTOS.green) tex = BASE_PHOTOS.green;
                if (idx === 2 && BASE_PHOTOS.yellow) tex = BASE_PHOTOS.yellow;
                if (idx === 3 && BASE_PHOTOS.blue) tex = BASE_PHOTOS.blue;
                return new THREE.MeshStandardMaterial({
                    map: tex,
                    transparent: true,
                    roughness: 0.55,
                    metalness: 0.1
                });
            };

            emblemDefs.forEach((def, idx) => {
                const geom = new THREE.PlaneGeometry(4.2, 4.2); // fill the white inset fully
                const mesh = new THREE.Mesh(geom, getMat(idx));
                mesh.rotation.x = -Math.PI / 2;
                mesh.rotation.z = def.rot;
                mesh.position.set(def.pos.x - offset, 0.13, def.pos.y - offset);
                mesh.receiveShadow = true;
                boardGroup.add(mesh);
            });
        }

        function createNaijaTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Background split in flag colors
            ctx.fillStyle = '#0a3b1e';
            ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(90, 0, 76, 256);

            // Subtle diagonal bands
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 6;
            for (let i = -64; i < 320; i += 48) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i + 120, 256);
                ctx.stroke();
            }

            // Abstract crest (circle + star)
            ctx.beginPath();
            ctx.arc(128, 128, 46, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(10,59,30,0.85)';
            ctx.fill();
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = -Math.PI / 2 + i * (Math.PI * 2 / 5);
                const x = 128 + Math.cos(angle) * 22;
                const y = 128 + Math.sin(angle) * 22;
                ctx.lineTo(x, y);
                const angle2 = angle + Math.PI / 5;
                ctx.lineTo(128 + Math.cos(angle2) * 9, 128 + Math.sin(angle2) * 9);
            }
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function getWoodTexture() {
            if (WOOD_TEXTURE) return WOOD_TEXTURE;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Walnut base stain
            ctx.fillStyle = '#5a3a26';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grain (thin bands)
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(-0.18);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            for (let i = 0; i < 2600; i++) {
                const y = Math.random() * canvas.height;
                const w = canvas.width * (0.6 + Math.random() * 0.8);
                const x = (canvas.width - w) / 2 + (Math.random() - 0.5) * 30;
                const alpha = 0.03 + Math.random() * 0.08;
                const light = Math.random() > 0.5;
                ctx.strokeStyle = light ? `rgba(240,210,175,${alpha})` : `rgba(25,12,6,${alpha})`;
                ctx.lineWidth = 1 + Math.random() * 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y + (Math.random() - 0.5) * 10);
                ctx.stroke();
            }

            // A few knots
            for (let k = 0; k < 10; k++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const r = 10 + Math.random() * 28;
                const grad = ctx.createRadialGradient(x, y, 2, x, y, r);
                grad.addColorStop(0, 'rgba(18,9,5,0.35)');
                grad.addColorStop(0.6, 'rgba(120,70,35,0.14)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Subtle vignette for depth
            const vignette = ctx.createRadialGradient(256, 256, 40, 256, 256, 360);
            vignette.addColorStop(0, 'rgba(255,255,255,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.18)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1.8, 1.8);
            WOOD_TEXTURE = tex;
            return WOOD_TEXTURE;
        }

        function loadBasePhotos() {
            const loader = new THREE.TextureLoader();
            // Photos (place in project root)
            BASE_PHOTOS.red = loader.load('red.jpg');
            BASE_PHOTOS.green = loader.load('green.jpg');
            BASE_PHOTOS.yellow = loader.load('yellow.png');
            BASE_PHOTOS.blue = loader.load('blue.png');
        }

        // ==================== DICE CREATION ====================
        function buildDieMaterials() {
            for (let face = 1; face <= 6; face++) {
                const tex = new THREE.CanvasTexture(createDiceFaceCanvas(face));
                DIE_MATERIALS[face] = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.3 });
            }
        }

        function getDieMaterialSet() {
            // Material order for BoxGeometry: +x, -x, +y, -y, +z, -z
            // Opposite faces sum to 7 for a standard die layout.
            return [
                DIE_MATERIALS[3], // right
                DIE_MATERIALS[4], // left
                DIE_MATERIALS[1], // top
                DIE_MATERIALS[6], // bottom
                DIE_MATERIALS[2], // front
                DIE_MATERIALS[5]  // back
            ];
        }

        function setDieValue(mesh, value) {
            mesh.userData.value = value;
        }

        function createDice() {
            const size = CONFIG.DICE_SIZE;
            const geometry = new THREE.BoxGeometry(size, size, size);
            dice = new THREE.Mesh(geometry, getDieMaterialSet());
            // Rest position on the board center square
            const restY = CONFIG.DICE_SIZE / 2 + 0.12; // slightly above board top
            dice.position.set(-0.6, restY, 0);
            dice.castShadow = true;
            dice.userData.rolling = false;
            dice.userData.targetRotation = { x: 0, y: 0, z: 0 };
            dice.userData.restPosition = { x: dice.position.x, y: restY, z: dice.position.z };
            dice.userData.value = 1;
            scene.add(dice);
        }

        function createDicePair() {
            createDice();
            // Clone materials for second die
            const size = CONFIG.DICE_SIZE;
            const geometry = new THREE.BoxGeometry(size, size, size);
            dice2 = new THREE.Mesh(geometry, getDieMaterialSet());
            const restY = CONFIG.DICE_SIZE / 2 + 0.12;
            dice2.position.set(0.6, restY, 0);
            dice2.castShadow = true;
            dice2.userData.rolling = false;
            dice2.userData.targetRotation = { x: 0, y: 0, z: 0 };
            dice2.userData.restPosition = { x: dice2.position.x, y: restY, z: dice2.position.z };
            dice2.userData.value = 1;
            scene.add(dice2);
        }

        function createDiceFaceCanvas(face) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 128, 128);

            // Border
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, 124, 124);

            // Dots
            ctx.fillStyle = '#e74c3c';

            const dotPositions = {
                1: [[64, 64]],
                2: [[96, 32], [32, 96]],
                3: [[96, 32], [64, 64], [32, 96]],
                4: [[32, 32], [96, 32], [32, 96], [96, 96]],
                5: [[32, 32], [96, 32], [64, 64], [32, 96], [96, 96]],
                6: [[32, 32], [96, 32], [32, 64], [96, 64], [32, 96], [96, 96]]
            };

            dotPositions[face].forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(x, y, 14, 0, Math.PI * 2);
                ctx.fill();
            });

            return canvas;
        }

        // ==================== TOKEN CREATION ====================
        function createToken(playerIndex, tokenIndex) {
            const color = PLAYER_HEX[playerIndex];

            // Token body (flat plastic disc)
            const group = new THREE.Group();

            // Disc
            const discGeometry = new THREE.CylinderGeometry(CONFIG.TOKEN_RADIUS * 1.1, CONFIG.TOKEN_RADIUS * 1.1, 0.2, 48);
            const discMaterial = new THREE.MeshStandardMaterial({ color: color, roughness: 0.25, metalness: 0.15 });
            const disc = new THREE.Mesh(discGeometry, discMaterial);
            disc.position.y = 0.1;
            disc.castShadow = true;
            disc.receiveShadow = true;
            group.add(disc);

            // Rim highlight
            const rimGeometry = new THREE.TorusGeometry(CONFIG.TOKEN_RADIUS * 1.05, 0.05, 12, 32);
            const rimMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.12,
                roughness: 0.2,
                metalness: 0.3
            });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.y = 0.2;
            group.add(rim);

            // Highlight ring (for selection)
            const ringGeometry = new THREE.TorusGeometry(CONFIG.TOKEN_RADIUS * 1.2, 0.05, 16, 32);
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.02;
            group.add(ring);
            group.userData.ring = ring;

            // Token data
            group.userData.playerIndex = playerIndex;
            group.userData.tokenIndex = tokenIndex;
            group.userData.position = -1; // -1 = in base, 0-51 = on track, 52-57 = home column, 58 = finished
            group.userData.isSelectable = false;
            group.userData.animating = false;
            group.userData.lastMovedAt = 0;

            // Set initial position in base
            const basePos = BASE_POSITIONS[playerIndex][tokenIndex];
            const offset = (CONFIG.BOARD_SIZE - 1) / 2;
            group.position.set(basePos.x - offset, 0, basePos.y - offset);

            scene.add(group);
            tokens.push(group);

            return group;
        }

        function disposeObject3D(obj) {
            if (!obj) return;
            removeDebugLabel(obj);
            obj.traverse(child => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m && m.dispose && m.dispose());
                    } else if (child.material.dispose) {
                        child.material.dispose();
                    }
                }
            });
        }

        function createAllTokens() {
            tokens.forEach(t => {
                scene.remove(t);
                disposeObject3D(t);
            });
            tokens = [];

            gameState.players.forEach((player, playerIndex) => {
                if (player.active) {
                    for (let i = 0; i < 4; i++) {
                        createToken(playerIndex, i);
                    }
                }
            });
        }

        // ==================== GAME LOGIC ====================
        function startGame() {
            if (gameMode === 'online' && !isHost) {
                showNotification('Only the host can start the online game.');
                return;
            }

            // Read player configurations
            const playerConfigs = [];
            document.querySelectorAll('.player-type-select').forEach((select, idx) => {
                const nameInput = document.querySelector(`.player-name-input[data-player="${idx}"]`);
                const defaultName = PLAYER_COLORS[idx].charAt(0).toUpperCase() + PLAYER_COLORS[idx].slice(1);
                const chosenName = nameInput && nameInput.value.trim() ? nameInput.value.trim() : defaultName;
                playerConfigs.push({
                    active: select.value !== 'none',
                    type: select.value,
                    name: chosenName,
                    tokensHome: 0,
                    tokensExited: 0
                });
            });

            let selectedCount = parseInt(document.querySelector('input[name="playerCount"]:checked')?.value || '2', 10);
            let twoPlayerMode = document.querySelector('input[name="twoPlayerMode"]:checked')?.value || 'half';

            if (gameMode === 'online') {
                selectedCount = 2;
                twoPlayerMode = 'half';
                // Force head-to-head humans
                playerConfigs.forEach((cfg, idx) => {
                    if (idx === 0 || idx === 1) {
                        cfg.active = true;
                        cfg.type = 'human';
                    } else {
                        cfg.active = false;
                        cfg.type = 'none';
                    }
                });
            }

            // Enforce modes
            if (selectedCount === 2) {
                if (twoPlayerMode === 'half') {
                    // P1 = Red, P2 = Green; disable Yellow/Blue
                    const p1Type = playerConfigs[0].type === 'none' ? 'human' : playerConfigs[0].type;
                    const p2Type = playerConfigs[1].type === 'none' ? 'human' : playerConfigs[1].type;
                    playerConfigs[0].active = true; playerConfigs[0].type = p1Type;
                    playerConfigs[1].active = true; playerConfigs[1].type = p2Type;
                    playerConfigs[2].active = false; playerConfigs[2].type = 'none';
                    playerConfigs[3].active = false; playerConfigs[3].type = 'none';
                } else {
                    // Full: P1 = Red+Green, P2 = Yellow+Blue
                    const p1Type = playerConfigs[0].type === 'none' ? 'human' : playerConfigs[0].type;
                    const p2Type = playerConfigs[3].type === 'none' ? 'human' : playerConfigs[3].type;
                    playerConfigs[0].active = true; playerConfigs[0].type = p1Type;
                    playerConfigs[1].active = true; playerConfigs[1].type = p1Type;
                    playerConfigs[2].active = true; playerConfigs[2].type = p2Type;
                    playerConfigs[3].active = true; playerConfigs[3].type = p2Type;

                    // Set names for 2-player full mode
                    if (gameMode !== 'online') {
                        const p1NameInput = document.querySelector('.player-name-input[data-player="0"]');
                        const p2NameInput = document.querySelector('.player-name-input[data-player="3"]');
                        const p1CustomName = p1NameInput?.value?.trim() || '';
                        const p2CustomName = p2NameInput?.value?.trim() || '';

                        // Check if user provided custom names (not empty and not default color names)
                        const defaults = new Set(['red', 'green', 'yellow', 'blue']);
                        const p1HasCustomName = p1CustomName && !defaults.has(p1CustomName.toLowerCase());
                        const p2HasCustomName = p2CustomName && !defaults.has(p2CustomName.toLowerCase());

                        // Set Player 1 name (Red + Green)
                        const player1Name = p1HasCustomName ? p1CustomName : 'Player 1';
                        playerConfigs[0].name = player1Name;
                        playerConfigs[1].name = player1Name;

                        // Set Player 2 name (Blue + Yellow)
                        const player2Name = p2HasCustomName ? p2CustomName : 'Player 2';
                        playerConfigs[3].name = player2Name;
                        playerConfigs[2].name = player2Name;
                    } else {
                        // For online mode, just copy names
                        playerConfigs[1].name = playerConfigs[0].name;
                        playerConfigs[2].name = playerConfigs[3].name;
                    }
                }
            } else if (selectedCount === 3) {
                // Enable Red, Green, Yellow; disable Blue
                ['type','active'].forEach(() => {});
                if (playerConfigs[0].type === 'none') playerConfigs[0].type = 'human';
                if (playerConfigs[1].type === 'none') playerConfigs[1].type = 'human';
                if (playerConfigs[2].type === 'none') playerConfigs[2].type = 'human';
                playerConfigs[0].active = true;
                playerConfigs[1].active = true;
                playerConfigs[2].active = true;
                playerConfigs[3].active = false; playerConfigs[3].type = 'none';
            } else {
                // 4 players: all active, one each
                for (let i = 0; i < 4; i++) {
                    if (playerConfigs[i].type === 'none') playerConfigs[i].type = 'human';
                    playerConfigs[i].active = true;
                }
            }

            const expectedActivePlayers = (selectedCount === 2 && twoPlayerMode === 'full') ? 4 : selectedCount;
            const activePlayers = playerConfigs.filter(p => p.active).length;
            if (activePlayers !== expectedActivePlayers) {
                showNotification(`Adjust selections for ${selectedCount} players.`);
                return;
            }

            // Initialize game state
            gameState.players = playerConfigs;
            gameState.currentOwner = 0;
            if (selectedCount === 2 && twoPlayerMode === 'full') {
                // 2-player full: one roll per owner, controlling two colors each
                setTurnToOwner(0);
            } else {
                gameState.currentPlayer = playerConfigs.findIndex(p => p.active);
            }
            gameState.dice = { d1: 0, d2: 0 };
            gameState.pendingDice = [];
            gameState.currentDieValue = 0;
            gameState.doubleSixBonus = false;
            gameState.captureBonus = false;
            gameState.phase = 'roll';
            gameState.bonusStreak = 0;
            gameState.gameStarted = true;
            gameState.winner = null;
            gameState.awaitingDieChoice = false;
            gameState.dieChoiceMode = null;
            gameState.confirmedDieValue = null;
            gameState.noSpawnThisDie = false;

            // Create tokens
            createAllTokens();

            // Broadcast start to peer
            if (isOnlineGame() && isHost) {
                sendGameState('startGame', {
                    players: gameState.players,
                    currentPlayer: gameState.currentPlayer
                });
            }

            // Update UI
            updatePlayerPanel();
            updateTurnDisplay();
            startTurnTimer();

            hideModal('startMenu');

            // If first player is AI, trigger their turn
            if (getCurrentPlayer().type !== 'human') {
                setTimeout(aiTurn, CONFIG.AI_DELAY);
            }
        }

        function isFullMode() {
            if (gameMode === 'online') return false;
            const selectedCount = parseInt(document.querySelector('input[name="playerCount"]:checked')?.value || '2', 10);
            const twoPlayerMode = document.querySelector('input[name="twoPlayerMode"]:checked')?.value || 'half';
            return selectedCount === 2 && twoPlayerMode === 'full';
        }

        function ownerForColor(colorIdx) {
            if (!isFullMode()) return colorIdx;
            // 2-player full: Owner 0 controls Red+Green, Owner 1 controls Yellow+Blue
            return (colorIdx === 0 || colorIdx === 1) ? 0 : 1;
        }

        function primaryColorForOwner(ownerIdx) {
            return ownerIdx === 0 ? 0 : 3; // Owner0 = Red, Owner1 = Blue
        }

        function getColorOutCount(colorIdx) {
            const p = gameState.players[colorIdx];
            if (!p) return 0;
            return (p.tokensHome || 0) + (p.tokensExited || 0);
        }

        function getOwnerOutCount(ownerIdx) {
            let total = 0;
            for (let colorIdx = 0; colorIdx < 4; colorIdx++) {
                if (ownerForColor(colorIdx) === ownerIdx) {
                    total += getColorOutCount(colorIdx);
                }
            }
            return total;
        }

        function getWinnerColorIfAny(colorIdx) {
            const requiredOut = calculateRequiredOut();
            if (isFullMode()) {
                const ownerIdx = ownerForColor(colorIdx);
                if (getOwnerOutCount(ownerIdx) >= requiredOut) return primaryColorForOwner(ownerIdx);
                return null;
            }
            return getColorOutCount(colorIdx) >= requiredOut ? colorIdx : null;
        }

        function getCurrentPlayer() {
            return gameState.players[gameState.currentPlayer];
        }

        function getCurrentOwner() {
            return isFullMode() ? (gameState.currentOwner || 0) : ownerForColor(gameState.currentPlayer);
        }

        function getOwnerDisplayName(ownerIdx) {
            if (!isFullMode()) return null;

            const primaryColor = primaryColorForOwner(ownerIdx);
            const player = gameState.players[primaryColor];
            if (!player) return ownerIdx === 0 ? 'Player 1' : 'Player 2';

            // Check if the name is a default color name
            const colorNames = ['red', 'green', 'yellow', 'blue'];
            const playerNameLower = String(player.name || '').trim().toLowerCase();

            // If it's a default color name or empty, use Player 1/Player 2
            if (!player.name || colorNames.includes(playerNameLower)) {
                return ownerIdx === 0 ? 'Player 1' : 'Player 2';
            }

            // Otherwise use the custom name
            return player.name;
        }

        function setTurnToOwner(ownerIdx) {
            gameState.currentOwner = ownerIdx;
            gameState.currentPlayer = primaryColorForOwner(ownerIdx);
        }

        function getPlayerTokensForTurn(playerIndex) {
            if (!isFullMode()) return tokens.filter(t => t.userData.playerIndex === playerIndex);
            const owner = ownerForColor(playerIndex);
            return tokens.filter(t => ownerForColor(t.userData.playerIndex) === owner);
        }

        function getPlayerTokens(playerIndex) {
            return getPlayerTokensForTurn(playerIndex);
        }

        function getActiveTokenCount(playerIndex) {
            return getPlayerTokens(playerIndex).filter(t => t.userData.position >= 0 && t.userData.position < 58).length;
        }

        function dieHasMove(dieValue) {
            const spawnAllowed = dieValue === 6;
            return getValidMoves(gameState.currentPlayer, dieValue, spawnAllowed).length > 0;
        }

        function restackTokens() {
            const groups = new Map();
            tokens.forEach(token => {
                const pos = token.userData.position;
                if (pos < 0 || pos >= 58) return; // ignore base and finished tokens (keep them fixed on exit pads)
                const key = `pos-${pos}`;
                if (!groups.has(key)) groups.set(key, []);
                groups.get(key).push(token);
            });

            groups.forEach(list => {
                if (list.length <= 1) return;
                // Stack older moves on the bottom and the most recent on top
                list.sort((a, b) => {
                    const aTime = a.userData.lastMovedAt || 0;
                    const bTime = b.userData.lastMovedAt || 0;
                    if (aTime !== bTime) return aTime - bTime;
                    return (a.userData.playerIndex - b.userData.playerIndex) || (a.userData.tokenIndex - b.userData.tokenIndex);
                });
                const centerToken = list[0];
                const center = getWorldPosition(
                    centerToken.userData.playerIndex,
                    centerToken.userData.position,
                    centerToken.userData.exitSlot || 0
                );
                list.forEach((t, idx) => {
                    t.position.x = center.x;
                    t.position.z = center.z;
                    t.position.y = center.y + idx * 0.22; // slight vertical separation
                });
            });
        }

        function rollDice() {
            if (gameState.phase !== 'roll' || dice.userData.rolling || dice2.userData.rolling) return;
            if (isOnlineGame() && !isMyTurn()) {
                showNotification('Waiting for your opponent\'s turn.');
                return;
            }
            dice2.userData.rolling = true;

            // Stop the turn timer when dice is rolled
            stopTurnTimer();

            AudioManager.play('roll');

            dice.userData.rolling = true;
            gameState.phase = 'animating';
            document.getElementById('rollDiceBtn').disabled = true;
            gameState.awaitingDieChoice = false;
            gameState.dieChoiceMode = null;
            gameState.confirmedDieValue = null;
            gameState.noSpawnThisDie = false;
            hideDieChoice();

            // Random results (two dice)
            const d1 = Math.floor(Math.random() * 6) + 1;
            const d2 = Math.floor(Math.random() * 6) + 1;
            gameState.dice = { d1, d2 };
            gameState.pendingDice = [d1, d2];
            gameState.currentDieValue = 0;
            gameState.doubleSixBonus = (d1 === 6 && d2 === 6);
            // rollCount no longer displayed

            // Animate dice
            const duration = 1000;
            const startTime = Date.now();
            const startRotation1 = { x: dice.rotation.x, y: dice.rotation.y, z: dice.rotation.z };
            const startRotation2 = { x: dice2.rotation.x, y: dice2.rotation.y, z: dice2.rotation.z };

            // Calculate final rotation for each die face
            const faceRotations = {
                1: { x: 0, z: 0 },                    // 1 is on top by default
                2: { x: -Math.PI / 2, z: 0 },         // bring front face up
                3: { x: 0, z: Math.PI / 2 },          // bring right face up
                4: { x: 0, z: -Math.PI / 2 },         // bring left face up
                5: { x: Math.PI / 2, z: 0 },          // bring back face up
                6: { x: Math.PI, z: 0 }               // flip upside down
            };

            const targetRot1 = faceRotations[d1];
            const targetRot2 = faceRotations[d2];
            const spins = 3;
            const restY1 = dice.userData.restPosition ? dice.userData.restPosition.y : (CONFIG.DICE_SIZE / 2 + 0.12);
            const restY2 = dice2.userData.restPosition ? dice2.userData.restPosition.y : (CONFIG.DICE_SIZE / 2 + 0.12);

            function animateDice() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                dice.rotation.x = startRotation1.x + (targetRot1.x + Math.PI * 2 * spins - startRotation1.x) * eased;
                dice.rotation.y = startRotation1.y + Math.PI * 4 * eased;
                dice.rotation.z = startRotation1.z + (targetRot1.z - startRotation1.z) * eased;

                dice2.rotation.x = startRotation2.x + (targetRot2.x + Math.PI * 2 * spins - startRotation2.x) * eased;
                dice2.rotation.y = startRotation2.y + Math.PI * 4 * eased;
                dice2.rotation.z = startRotation2.z + (targetRot2.z - startRotation2.z) * eased;

                // Bounce effect
                const bounce = Math.sin(progress * Math.PI * 3) * (1 - progress) * 0.6;
                dice.position.y = restY1 + bounce;
                dice2.position.y = restY2 + bounce;
                dice.position.x = dice.userData.restPosition.x;
                dice.position.z = dice.userData.restPosition.z;
                dice2.position.x = dice2.userData.restPosition.x;
                dice2.position.z = dice2.userData.restPosition.z;

                if (progress < 1) {
                    requestAnimationFrame(animateDice);
                } else {
                    dice.position.y = restY1;
                    dice2.position.y = restY2;
                    dice.userData.rolling = false;
                    dice2.userData.rolling = false;
                    setDieValue(dice, d1);
                    setDieValue(dice2, d2);
                    onDiceRollComplete(d1, d2);
                }
            }

            animateDice();
        }

        function onDiceRollComplete(d1, d2) {
            document.getElementById('diceResult').textContent = ` ${d1} & ${d2}`;

            // Sync dice roll in online mode
            if (isOnlineGame() && isMyTurn()) {
                sendGameState('diceRoll', { d1, d2 });
            }

            const isHuman = getCurrentPlayer().type === 'human';
            const hasChoice = gameState.pendingDice.length === 2 && isHuman;

            // If no tokens are active on the board, auto-apply order (6 first when present) and skip choice UI
            const playerTokens = getPlayerTokensForTurn(gameState.currentPlayer);
            const allInBase = playerTokens.length > 0 && playerTokens.every(t => t.userData.position === -1);
            const activeTokens = playerTokens.filter(t => t.userData.position >= 0 && t.userData.position < 58);
            const noneActiveOnBoard = activeTokens.length === 0;
            const hasBaseTokens = playerTokens.some(t => t.userData.position === -1);

            const activeCount = getActiveTokenCount(gameState.currentPlayer);
            const bothDiceSame = gameState.pendingDice.length === 2 && gameState.pendingDice[0] === gameState.pendingDice[1];
            const onlyOneAfterSpawn = noneActiveOnBoard && gameState.pendingDice.length === 2 && gameState.pendingDice.includes(6) && !gameState.pendingDice.every(v => v === 6);
            const includesSix = gameState.pendingDice.includes(6);

            // If only one token is in play and there are no base tokens to spawn,
            // auto-play dice without prompting for order (outside home lane).
            const singleToken = activeTokens.length === 1 ? activeTokens[0] : null;
            const singleInHomeLane = singleToken && singleToken.userData.position >= 52 && singleToken.userData.position < 58;
            const forceAutoSingleNoSpawnChoice = activeCount <= 1 && !hasBaseTokens && !singleInHomeLane;

            const forceAutoSingleNoSix = activeCount <= 1 && !includesSix;
            const forceAutoIdenticalDice = bothDiceSame && activeCount <= 1;
            const forceAuto = forceAutoSingleNoSpawnChoice || forceAutoSingleNoSix || forceAutoIdenticalDice || onlyOneAfterSpawn || (!hasChoice);

            const movesD1 = dieHasMove(d1);
            const movesD2 = dieHasMove(d2);

            // UX rule: If the player has exactly one token in play (others are base/finished) and no 6 is present,
            // auto-apply both dice as a single combined move when possible (prevents "mid-way" captures on the first die).
            if (isHuman &&
                singleToken &&
                !includesSix &&
                singleToken.userData.position >= 0 &&
                singleToken.userData.position < 52 &&
                movesD1 && movesD2) {
                const combined = d1 + d2;
                const combinedMoves = getValidMoves(gameState.currentPlayer, combined, false).filter(m => m.token === singleToken);
                if (combinedMoves.length === 1) {
                    gameState.pendingDice = [combined];
                    // Important: combined sum must NOT enable spawning from base, even if combined == 6.
                    gameState.noSpawnThisDie = true;
                    processNextDie();
                    return;
                }
            }

            // Special: all tokens in base, one 6 present  force order [6, other] and keep both dice
            if (noneActiveOnBoard && gameState.pendingDice.length === 2 && includesSix) {
                const other = gameState.pendingDice[0] === 6 ? gameState.pendingDice[1] : gameState.pendingDice[0];
                gameState.pendingDice = [6, other];
                processNextDie();
                return;
            }

            // Single-token in home lane: give the player the luxury to "use or skip" dice
            // ONLY when there are no tokens left in base and no other token in play.
            // (AI still auto-plays.)
            const allowHomeLaneSkipLuxury = singleInHomeLane && isHuman && !hasBaseTokens && activeTokens.length === 1;
            if (allowHomeLaneSkipLuxury) {
                if (!movesD1 && !movesD2) {
                    gameState.pendingDice = [];
                    processNextDie();
                    return;
                }

                if (movesD1 && movesD2) {
                    gameState.pendingDice = [d1, d2];
                    gameState.awaitingDieChoice = true;
                    gameState.dieChoiceMode = 'order';
                    showDieChoice(d1, d2, { singleMode: false, allowSkip: true });
                    return;
                }

                const only = movesD1 ? d1 : d2;
                gameState.pendingDice = [only];
                gameState.awaitingDieChoice = true;
                gameState.dieChoiceMode = 'single';
                showDieChoice(only, only, { singleMode: true, allowSkip: true, singleValue: only });
                return;
            }

            // General handling
            if (!movesD1 && !movesD2) {
                gameState.pendingDice = [];
                processNextDie();
                return;
            }

            if (movesD1 && !movesD2) {
                gameState.pendingDice = [d1];
                processNextDie();
                return;
            }
            if (!movesD1 && movesD2) {
                gameState.pendingDice = [d2];
                processNextDie();
                return;
            }

            const shouldPrompt = hasChoice && !noneActiveOnBoard && !allInBase && !forceAuto && (includesSix || activeCount > 1);

            if (shouldPrompt) {
                gameState.awaitingDieChoice = true;
                gameState.dieChoiceMode = 'order';
                showDieChoice(d1, d2, { singleMode: false, allowSkip: false });
            } else {
                gameState.dieChoiceMode = null;
                if (allInBase && gameState.pendingDice.length === 2) {
                    // Put a single 6 first when exiting base; otherwise keep original order
                    if (gameState.pendingDice.includes(6)) {
                        const other = gameState.pendingDice[0] === 6 ? gameState.pendingDice[1] : gameState.pendingDice[0];
                        gameState.pendingDice = [6, other];
                    }
                }
                processNextDie();
            }
        }

        function getValidMoves(playerIndex, diceValue, spawnAllowed = false) {
            const playerTokens = getPlayerTokensForTurn(playerIndex);
            const validMoves = [];
            const occupancy = buildOccupancyMap();

            playerTokens.forEach(token => {
                const currentPos = token.userData.position;

                // Token in base
                if (currentPos === -1) {
                    if (spawnAllowed) {
                        const colorIdx = token.userData.playerIndex;
                        const startPos = START_POSITIONS[colorIdx];
                        // Spawn uses only the spawning die; no extra movement
                        const path = [startPos];
                        if (isPathClear(occupancy, path, -1, colorIdx) && canLand(occupancy, startPos, colorIdx)) {
                            validMoves.push({
                                token,
                                newPosition: startPos,
                                type: 'exit'
                            });
                        }
                    }
                }
                // Token on track or home column
                else if (currentPos >= 0 && currentPos < 58) {
                    const colorIdx = token.userData.playerIndex;

                    // Home lane exact-count rule: cannot overshoot the center.
                    // In this ruleset, landing on 57 finishes and exits the token.
                    // Positions 52..56 are consecutive toward 57, so remaining steps is (57 - currentPos).
                    if (currentPos >= 52 && diceValue > (57 - currentPos)) {
                        return;
                    }

                    const path = getPathPositions(colorIdx, currentPos, diceValue);
                    if (path && path.length) {
                        const dest = path[path.length - 1];
                        if (isPathClear(occupancy, path, currentPos, colorIdx) && canLand(occupancy, dest, colorIdx)) {
                            const moveType = dest === 57 ? 'finish' : (dest > 51 ? 'home' : 'move');

                            validMoves.push({
                                token,
                                newPosition: dest,
                                type: moveType
                            });
                        }
                    }
                }
            });

            return validMoves;
        }

        function isOpponent(myPlayerIndex, theirPlayerIndex) {
            // In 2-player full mode, check if they belong to different owners
            // In regular mode, just check if they're different player indices
            if (isFullMode()) {
                return ownerForColor(myPlayerIndex) !== ownerForColor(theirPlayerIndex);
            }
            return myPlayerIndex !== theirPlayerIndex;
        }

        function wouldCaptureOpponent(playerIndex, position, dieValue) {
            // Check if landing at this position would ACTUALLY result in a capture
            // considering all Nigerian Ludo rules

            // No captures in home lane or beyond
            if (position >= 52) return false;

            // Check if there's an opponent token at this position
            const opponentTokens = tokens.filter(t =>
                isOpponent(playerIndex, t.userData.playerIndex) &&
                t.userData.position === position &&
                t.userData.position >= 0 &&
                t.userData.position < 52
            );

            if (opponentTokens.length === 0) return false; // No opponent present

            // Nigerian Ludo start square rules
            if (START_POS_SET.has(position)) {
                const startOwner = START_POSITIONS.indexOf(position);

                // Rule 1: Cannot capture opponent on THEIR start square
                if (startOwner !== playerIndex) {
                    return false; // Opponent is protected on their own start
                }

                // Rule 2: Can capture on YOUR start square ONLY with a 6
                if (startOwner === playerIndex && dieValue !== 6) {
                    return false; // Need a 6 to capture on your own start
                }
            }

            // If we get here, capture would actually happen
            return true;
        }

        function processNextDie() {
            if (!gameState.pendingDice || gameState.pendingDice.length === 0) {
                // No more dice; resolve bonuses and next turn
                if (gameState.doubleSixBonus) {
                    gameState.doubleSixBonus = false;
                    gameState.phase = 'roll';
                    const rollBtn = document.getElementById('rollDiceBtn');
                    if (rollBtn) rollBtn.disabled = !isMyTurn();
                    // Clear dice result to prevent overlap
                    document.getElementById('diceResult').textContent = '';
                    showNotification(' Bonus roll! Roll again!');
                    // Restart turn timer for the bonus roll
                    startTurnTimer();
                    if (getCurrentPlayer().type !== 'human') {
                        setTimeout(aiTurn, CONFIG.AI_DELAY);
                    }
                } else {
                    nextTurn();
                }
                return;
            }

            const die = gameState.pendingDice[0];
            gameState.currentDieValue = die;

            const diceResultEl = document.getElementById('diceResult');
            if (diceResultEl) {
                const { d1 = '?', d2 = '?' } = gameState.dice || {};
                diceResultEl.textContent = ` ${d1} & ${d2}`;
                diceResultEl.classList.add('counting');
                setTimeout(() => diceResultEl.classList.remove('counting'), 800);
            }

            const spawnAllowed = die === 6 && !gameState.noSpawnThisDie;
            const validMoves = getValidMoves(gameState.currentPlayer, die, spawnAllowed);
            const activeCount = getActiveTokenCount(gameState.currentPlayer);

            if (validMoves.length === 0) {
                // Consume this die and move on
                gameState.confirmedDieValue = null;
                gameState.noSpawnThisDie = false;
                gameState.pendingDice.shift();
                processNextDie();
                return;
            }

            // Home-lane luxury: when a single token is in the home lane and it is the only move available,
            // allow the human player to choose whether to use or skip the current die.
            if (getCurrentPlayer().type === 'human' &&
                activeCount <= 1 &&
                validMoves.length === 1) {
                const onlyToken = validMoves[0].token;
                const pos = onlyToken?.userData?.position;
                const isHomeLane = typeof pos === 'number' && pos >= 52 && pos < 57;
                const hasBaseTokens = getPlayerTokensForTurn(gameState.currentPlayer).some(t => t.userData.position === -1);
                if (isHomeLane && !hasBaseTokens && gameState.confirmedDieValue !== die) {
                    gameState.awaitingDieChoice = true;
                    gameState.dieChoiceMode = 'single';
                    showDieChoice(die, die, { singleMode: true, allowSkip: true, singleValue: die });
                    return;
                }
                if (gameState.confirmedDieValue === die) {
                    gameState.confirmedDieValue = null;
                }
            }

            const playerTokens = getPlayerTokens(gameState.currentPlayer);
            const hasActive = playerTokens.some(t => t.userData.position >= 0 && t.userData.position < 58);
            if (!hasActive && spawnAllowed) {
                const spawnMoves = validMoves.filter(m => m.type === 'exit');

                // Rule/UX: If there are NO tokens in play and the roll is 6 + (non-6),
                // spawn one token and continue counting with the other die (no stopping mid-way to capture on start).
                // Double-six keeps player/AI choice.
                const otherDie = (Array.isArray(gameState.pendingDice) && gameState.pendingDice.length >= 2) ? gameState.pendingDice[1] : null;
                const forceSpawnAndContinue = !isFullMode() && otherDie && otherDie !== 6;
                if (forceSpawnAndContinue && spawnMoves.length > 0) {
                    const chosen = spawnMoves
                        .slice()
                        .sort((a, b) => (a.token.userData.tokenIndex - b.token.userData.tokenIndex))[0];
                    if (chosen) {
                        gameState.suppressCaptureThisMove = true;
                        executeMove(chosen.token, chosen.newPosition, chosen.type, die);
                        return;
                    }
                }

                if (spawnMoves.length === 1) {
                    const spawnOnly = spawnMoves[0];
                    executeMove(spawnOnly.token, spawnOnly.newPosition, spawnOnly.type, die);
                    return;
                }
                // When multiple exits are available (notably in 2-player full mode),
                // require the player/AI to choose which token/color to bring out first.
            }

            // UX: If only one token is in play, auto-apply moves for each die (no need to tap the token).
            if (getCurrentPlayer().type === 'human' &&
                activeCount <= 1 &&
                validMoves.length === 1) {
                const move = validMoves[0];
                executeMove(move.token, move.newPosition, move.type, die);
                return;
            }

            // Highlight valid tokens
            highlightValidTokens(validMoves);
            gameState.phase = 'select';
            document.getElementById('tokenHint').classList.add('show');

            // If AI, make move
            if (getCurrentPlayer().type !== 'human') {
                setTimeout(() => {
                    const move = selectAIMove(validMoves, getCurrentPlayer().type);
                    executeMove(move.token, move.newPosition, move.type, die);
                }, CONFIG.AI_DELAY);
            }
        }

        function getPathPositions(playerIndex, currentPos, diceValue) {
            const path = [];
            const startPos = START_POSITIONS[playerIndex];
            const homeEntryPos = (startPos + 50) % 52; // 2 squares before the start square on this board layout
            let pos = currentPos;

            // Move step-by-step for accurate blockade checks
            for (let step = 0; step < diceValue; step++) {
                if (pos === -1) {
                    // Leaving base not handled here (spawn handled separately)
                    return null;
                } else if (pos >= 58) {
                    // Already finished - any additional steps are an overshoot
                    return null;
                } else if (pos < 52) {
                    // Main track advance (enter home lane only from the home-entry square)
                    if (pos === homeEntryPos) {
                        pos = 52; // first home-lane cell for this color
                    } else {
                        pos = (pos + 1) % 52;
                    }
                } else if (pos < 58) {
                    // Home column
                    const homeIndex = pos - 52;
                    const nextHome = homeIndex + 1;
                    // 52..56 are home cells; landing on 57 finishes/exits.
                    if (nextHome > 5) return null; // overshoot beyond finish
                    pos = nextHome === 5 ? 57 : 52 + nextHome;
                }
                path.push(pos);
            }

            return path;
        }

        function buildOccupancyMap() {
            const map = {};
            tokens.forEach(t => {
                const p = t.userData.position;
                if (p >= 0 && p < 58) {
                    if (!map[p]) {
                        map[p] = { total: 0, per: [0, 0, 0, 0], owner: null, block: false };
                    }
                    map[p].total += 1;
                    map[p].per[t.userData.playerIndex] += 1;
                }
            });
            Object.values(map).forEach(entry => {
                const ownerIdx = entry.per.findIndex(c => c >= 2);
                entry.owner = ownerIdx >= 0 ? ownerIdx : null;
                // Opponent block only applies to landing; no mid-path blocking
                entry.block = entry.owner !== null;
            });
            return map;
        }

        function isPathClear(occupancy, path, startPos, playerIndex) {
            // No mid-path blocking; only landing rules apply
            return true;
        }

        function canLand(occupancy, dest, playerIndex) {
            if (dest === 57) return true; // Landing on 57 finishes/exits

            const occ = occupancy[dest];
            if (!occ) return true;

            const ownCount = occ.per[playerIndex];

            // Cannot exceed 4 on a single square
            if (ownCount >= 4) return false;

            // Landing is allowed; capture logic will resolve opponents
            return true;
        }

        function highlightValidTokens(validMoves) {
            selectableTokens = [];

            tokens.forEach(token => {
                const move = validMoves.find(m => m.token === token);
                if (move) {
                    token.userData.isSelectable = true;
                    token.userData.pendingMove = move;
                    selectableTokens.push(token);

                    // Show highlight ring
                    token.userData.ring.material.opacity = 1;
                    token.userData.ring.material.emissiveIntensity = 1;
                } else {
                    token.userData.isSelectable = false;
                    token.userData.ring.material.opacity = 0;
                    token.scale.set(1, 1, 1);
                }
            });

            // Default keyboard selection to the first selectable token (if any)
            if (selectableTokens.length > 0) {
                keyboardSelectedTokenIndex = 0;
                updateKeyboardTokenHighlight();
            } else {
                keyboardSelectedTokenIndex = -1;
            }
        }

        function clearHighlights() {
            tokens.forEach(token => {
                token.userData.isSelectable = false;
                token.userData.ring.material.opacity = 0;
                token.scale.set(1, 1, 1);
            });
            selectableTokens = [];
            keyboardSelectedTokenIndex = -1;
            document.getElementById('tokenHint').classList.remove('show');
        }

        function updateKeyboardTokenHighlight() {
            if (!Array.isArray(selectableTokens) || selectableTokens.length === 0) return;
            selectableTokens.forEach((token, idx) => {
                const ring = token?.userData?.ring;
                if (!ring || !ring.material) return;
                if (idx === keyboardSelectedTokenIndex) {
                    ring.material.opacity = 1;
                    ring.material.emissiveIntensity = 1.8;
                    ring.scale.set(1.25, 1.25, 1.25);
                } else {
                    ring.material.opacity = 1;
                    ring.material.emissiveIntensity = 1;
                    ring.scale.set(1, 1, 1);
                }
            });
        }

        function executeMove(token, newPosition, moveType = 'move', dieValue = 0, fromNetwork = false, advanceTurn = true) {
            clearHighlights();
            gameState.phase = 'animating';

            const playerIndex = token.userData.playerIndex;
            const oldPosition = token.userData.position;
            const suppressCapture = !!gameState.suppressCaptureThisMove;
            gameState.suppressCaptureThisMove = false;

            // Sync token move in online mode (only if not received from network)
            if (isOnlineGame() && isMyTurn() && !fromNetwork) {
                sendGameState('tokenMove', {
                    playerIndex,
                    tokenIndex: token.userData.tokenIndex,
                    newPosition,
                    moveType,
                    dieValue
                });
            }

            // Calculate world position for new position
            let targetWorldPos;
            let finishExitSlot = null;
            if (newPosition === 57) {
                const player = gameState.players[playerIndex];
                const slot = (player.tokensHome || 0) + (player.tokensExited || 0);
                finishExitSlot = Math.min(slot, 3);
                targetWorldPos = getWorldPosition(playerIndex, 58, finishExitSlot);
            } else {
                targetWorldPos = getWorldPosition(playerIndex, newPosition);
            }

            // Animate token movement
            const preActiveCount = getActiveTokenCount(playerIndex) - ((oldPosition >= 0 && oldPosition < 58) ? 1 : 0);

            animateTokenMove(token, targetWorldPos, () => {
                if (newPosition === 57) {
                    gameState.players[playerIndex].tokensHome++;
                    token.userData.position = 58;
                    token.userData.exitSlot = finishExitSlot || 0;
                } else {
                    token.userData.position = newPosition;
                }

                // Check for capture
                let captured = false;
                if (!suppressCapture && newPosition >= 0 && newPosition < 52) {
                    const allowSafeCapture = (moveType === 'exit'); // allow capture on start square when exiting base
                    captured = checkCapture(playerIndex, newPosition, allowSafeCapture, dieValue, preActiveCount > 0);
                }

                // Check for finish
                if (newPosition === 57) {
                    AudioManager.play('home');
                    showNotification('Token home!');

                    // Ensure final position stays on exit pad
                    if (finishExitSlot !== null) {
                        token.position.copy(getWorldPosition(playerIndex, 58, finishExitSlot));
                    }

                    // Check for win
                    const winnerColor = getWinnerColorIfAny(playerIndex);
                    if (winnerColor !== null) {
                        gameWon(winnerColor);
                        return;
                    }
                }

                updatePlayerPanel();
                token.userData.lastMovedAt = Date.now();
                restackTokens();

                // If capture happened, exit this token off-board and count it
                if (captured) {
                    exitToken(token);
                }

                // Consume this die and move to next
                if (!Array.isArray(gameState.pendingDice)) gameState.pendingDice = [];
                let consumeIndex = 0;
                if (fromNetwork && dieValue) {
                    const matchIdx = gameState.pendingDice.findIndex(v => v === dieValue);
                    if (matchIdx >= 0) consumeIndex = matchIdx;
                }
                if (gameState.pendingDice.length > 0) {
                    gameState.pendingDice.splice(consumeIndex, 1);
                }
                gameState.noSpawnThisDie = false;
                if (advanceTurn) {
                    processNextDie();
                } else {
                    gameState.phase = gameState.pendingDice.length > 0 ? 'select' : 'roll';
                    updateTurnDisplay();
                }
            });
        }

        function exitToken(token) {
            const playerIndex = token.userData.playerIndex;
            const player = gameState.players[playerIndex];
            if (player.tokensExited === undefined) player.tokensExited = 0;

            // Assign an exit slot and move token there
            const slot = Math.min(player.tokensExited + player.tokensHome, 3);
            token.userData.exitSlot = slot;
            player.tokensExited += 1;
            moveTokenToExit(token, playerIndex, slot);
        }

        function placeOnExitPad(token, playerIndex) {
            const player = gameState.players[playerIndex];
            if (player.tokensExited === undefined) player.tokensExited = 0;
            const slot = Math.min(player.tokensExited + player.tokensHome - 1, 3);
            moveTokenToExit(token, playerIndex, slot);
        }

        function moveTokenToExit(token, playerIndex, slot) {
            const posList = EXIT_POSITIONS[playerIndex];
            const pos = posList[Math.min(slot, posList.length - 1)] || posList[0];
            token.userData.position = 59;
            token.userData.exitSlot = slot;
            animateTokenMove(token, getWorldPosition(playerIndex, 59, slot), () => {
                updatePlayerPanel();
                const winnerColor = getWinnerColorIfAny(playerIndex);
                if (winnerColor !== null) {
                    gameWon(winnerColor);
                }
            });
        }

        function calculateRequiredOut() {
            const selectedCount = parseInt(document.querySelector('input[name="playerCount"]:checked')?.value || '2', 10);
            const twoPlayerMode = document.querySelector('input[name="twoPlayerMode"]:checked')?.value || 'half';
            if (selectedCount === 2 && twoPlayerMode === 'full') return 8;
            return 4;
        }

        function getWorldPosition(playerIndex, position, exitSlot = 0) {
            const offset = (CONFIG.BOARD_SIZE - 1) / 2;
            let gridPos;

            if (position === -1) {
                // Base position
                gridPos = BASE_POSITIONS[playerIndex][0]; // Default to first base spot
            } else if (position < 52) {
                // Main track
                gridPos = MAIN_TRACK[position];
            } else if (position < 58) {
                // Home column
                gridPos = HOME_PATHS[playerIndex][position - 52];
            } else {
                // Exit pads (finished or captured)
                const posList = EXIT_POSITIONS[playerIndex];
                const slot = Math.min(exitSlot, posList.length - 1);
                const pos = posList[slot] || posList[0];
                return new THREE.Vector3(pos.x, 0, pos.z);
            }

            return new THREE.Vector3(gridPos.x - offset, 0, gridPos.y - offset);
        }

        function animateTokenMove(token, targetPos, callback) {
            AudioManager.play('move');

            const startPos = token.position.clone();
            const duration = 300;
            const height = 1;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 2);

                token.position.x = startPos.x + (targetPos.x - startPos.x) * eased;
                token.position.z = startPos.z + (targetPos.z - startPos.z) * eased;
                token.position.y = startPos.y + Math.sin(progress * Math.PI) * height;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    token.position.copy(targetPos);
                    token.position.y = targetPos.y || 0;
                    if (callback) callback();
                }
            }

            animate();
        }

        function checkCapture(playerIndex, position, allowSafeCapture = false, dieValue = 0, hadOtherActive = false) {
            // Capture only if opponent and not a block of theirs
            const occupancy = buildOccupancyMap();
            const occ = occupancy[position];
            if (!occ) return false;
            const owner = occ.owner;
            // Starting squares: Nigerian Ludo rules
            if (START_POS_SET.has(position)) {
                const startOwner = START_POSITIONS.indexOf(position);

                // Rule 1: CANNOT capture opponent on THEIR start square
                if (startOwner >= 0 && startOwner !== playerIndex && gameState.players[startOwner].active) {
                    return false;
                }

                // Rule 2: CAN capture opponent on YOUR start square ONLY with a 6
                // (or when exiting base, which requires a 6 anyway)
                if (startOwner === playerIndex) {
                    // Check if we rolled a 6 or if this is an exit move (which requires 6)
                    if (dieValue !== 6 && !allowSafeCapture) {
                        return false; // Need a 6 to capture on your own start square
                    }
                }
            }

            const capturedCandidates = tokens.filter(t =>
                isOpponent(playerIndex, t.userData.playerIndex) &&
                t.userData.position === position &&
                t.userData.position >= 0 &&
                t.userData.position < 52
            );

            if (capturedCandidates.length > 0) {
                const captured = capturedCandidates[capturedCandidates.length - 1]; // topmost
                AudioManager.play('capture');
                captured.userData.position = -1;
                const basePos = getNextBasePosition(captured.userData.playerIndex, captured.userData.tokenIndex);
                animateTokenMove(captured, basePos, null);
                return true;
            }
            return false;
        }

        function getNextBasePosition(playerIndex, tokenIndex) {
            const offset = (CONFIG.BOARD_SIZE - 1) / 2;
            const basePos = BASE_POSITIONS[playerIndex][tokenIndex];
            return new THREE.Vector3(basePos.x - offset, 0, basePos.y - offset);
        }

        function nextTurn(fromNetwork = false) {
            if (isFullMode()) {
                const nextOwner = getCurrentOwner() === 0 ? 1 : 0;
                setTurnToOwner(nextOwner);

            gameState.dice = { d1: 0, d2: 0, sum: 0 };
            gameState.pendingDice = [];
            gameState.currentDieValue = 0;
            gameState.phase = 'roll';
            gameState.bonusStreak = 0;
            gameState.awaitingDieChoice = false;
            gameState.dieChoiceMode = null;
            gameState.confirmedDieValue = null;
            gameState.noSpawnThisDie = false;

                updatePlayerPanel();
                updateTurnDisplay();

                const rollBtn = document.getElementById('rollDiceBtn');
                if (rollBtn) rollBtn.disabled = !isMyTurn();
                document.getElementById('diceResult').textContent = '';
                hideDieChoice();
                clearHighlights();

                startTurnTimer();

                if (getCurrentPlayer().type !== 'human') {
                    setTimeout(aiTurn, CONFIG.AI_DELAY);
                }
                return;
            }

            // Find next active player
            let nextPlayer = (gameState.currentPlayer + 1) % 4;
            let attempts = 0;
            while (!gameState.players[nextPlayer].active && attempts < 4) {
                nextPlayer = (nextPlayer + 1) % 4;
                attempts++;
            }

            if (attempts >= 4) return; // No active players

            gameState.currentPlayer = nextPlayer;
            gameState.dice = { d1: 0, d2: 0, sum: 0 };
            gameState.phase = 'roll';
            gameState.bonusStreak = 0;
            gameState.awaitingDieChoice = false;
            gameState.dieChoiceMode = null;
            gameState.confirmedDieValue = null;

            if (isOnlineGame() && !fromNetwork && isMyTurn()) {
                sendGameState('nextTurn', { currentPlayer: nextPlayer });
            }

            updatePlayerPanel();
            updateTurnDisplay();

            const rollBtn = document.getElementById('rollDiceBtn');
            if (rollBtn) rollBtn.disabled = !isMyTurn();
            document.getElementById('diceResult').textContent = '';
            hideDieChoice();

            // Start turn timer
            startTurnTimer();

            // If AI, trigger their turn
            if (getCurrentPlayer().type !== 'human') {
                setTimeout(aiTurn, CONFIG.AI_DELAY);
            }
        }

        function aiTurn() {
            if (isOnlineGame() && !isMyTurn()) return;
            if (gameState.phase === 'roll') {
                rollDice();
            }
        }

        function selectAIMove(validMoves, aiType) {
            // Score each move (using medium AI logic)
            const scoredMoves = validMoves.map(move => {
                let score = 0;
                const playerIndex = move.token.userData.playerIndex;

                // Finishing is best
                if (move.type === 'finish') score += 1000;

                // Entering home column is good
                if (move.type === 'home') score += 500;

                // Exiting base
                if (move.type === 'exit') score += 200;

                // Check for capture potential
                if (move.newPosition >= 0 && move.newPosition < 52) {
                    const capturable = tokens.filter(t =>
                        isOpponent(playerIndex, t.userData.playerIndex) &&
                        t.userData.position === move.newPosition &&
                        !SAFE_SQUARES.includes(move.newPosition)
                    );
                    if (capturable.length > 0) score += 300;
                }

                // Moving to safe square
                if (SAFE_SQUARES.includes(move.newPosition)) score += 50;

                // Progress toward home
                if (move.newPosition >= 0 && move.newPosition < 52) {
                    const startPos = START_POSITIONS[playerIndex];
                    const distance = (move.newPosition - startPos + 52) % 52;
                    score += distance * 2;
                }

                return { ...move, score };
            });

            // Sort by score and pick best (with some randomness)
            scoredMoves.sort((a, b) => b.score - a.score);

            // 20% chance of random move to add variety
            if (Math.random() < 0.2) {
                return scoredMoves[Math.floor(Math.random() * scoredMoves.length)];
            }

            return scoredMoves[0];
        }

        function gameWon(playerIndex, fromNetwork = false) {
            gameState.winner = playerIndex;
            gameState.gameStarted = false;
            gameState.phase = 'ended';
            if (turnTimer) {
                clearInterval(turnTimer);
                turnTimer = null;
            }

            if (isOnlineGame() && !fromNetwork) {
                sendGameState('gameOver', { winner: playerIndex });
            }

            stopTurnTimer();
            AudioManager.play('win');

            const winnerName = document.getElementById('winnerName');
            // In 2-player full mode, use the owner display name
            let displayName = gameState.players[playerIndex].name;
            if (isFullMode()) {
                const ownerIdx = ownerForColor(playerIndex);
                displayName = getOwnerDisplayName(ownerIdx);
            }
            winnerName.textContent = displayName;
            winnerName.className = 'winner-name ' + PLAYER_COLORS[playerIndex];

            showModal('winnerModal');
        }

        // ==================== UI FUNCTIONS ====================
        function updatePlayerPanel() {
            const panel = document.getElementById('playerPanel');
            panel.innerHTML = '';

            const requiredOut = calculateRequiredOut();

            // If game is ended, show winner info and stop updating tokens
            if (gameState.phase === 'ended' && gameState.winner !== null) {
                const winnerIdx = gameState.winner;
                const winnerName = isFullMode()
                    ? getOwnerDisplayName(ownerForColor(winnerIdx))
                    : (gameState.players[winnerIdx]?.name || 'Winner');
                const card = document.createElement('div');
                card.className = `player-card ${PLAYER_COLORS[winnerIdx]} active`;
                card.innerHTML = `
                    <div class="player-icon">${getPlayerEmoji(winnerIdx)}</div>
                    <div class="player-info">
                        <div class="player-name">${winnerName}</div>
                        <div class="player-status">Winner</div>
                    </div>
                `;
                panel.appendChild(card);
                return;
            }

            if (isFullMode()) {
                const owners = [
                    { ownerIdx: 0, displayColor: 0, colors: [0, 1] },
                    { ownerIdx: 1, displayColor: 3, colors: [3, 2] }
                ];

                owners.forEach(({ ownerIdx, displayColor, colors }) => {
                    const player = gameState.players[primaryColorForOwner(ownerIdx)];
                    if (!player || !player.active) return;

                    const outCount = getOwnerOutCount(ownerIdx);

                    // Determine display name with explicit fallback
                    const colorNames = ['red', 'green', 'yellow', 'blue'];
                    const playerName = String(player.name || '').trim();
                    const playerNameLower = playerName.toLowerCase();

                    // Check if it's a custom name (not empty and not a default color name)
                    let displayName;
                    if (playerName && !colorNames.includes(playerNameLower)) {
                        displayName = playerName;
                    } else {
                        // Use Player 1 or Player 2 as default
                        displayName = ownerIdx === 0 ? 'Player 1' : 'Player 2';
                    }

                    // Final safety check - ensure displayName is never empty
                    if (!displayName || !displayName.trim()) {
                        displayName = ownerIdx === 0 ? 'Player 1' : 'Player 2';
                    }

                    const aiSuffix = player.type !== 'human' ? ' (AI)' : '';

                    // Create token indicators for each color with explicit color classes
                    // This ensures each player sees 8 tokens in 2 distinct colors (4+4)
                    const tokenIndicators = colors.flatMap(colorIdx =>
                        [0, 1, 2, 3].map(tokenIndex => {
                            const token = tokens.find(t =>
                                t.userData.playerIndex === colorIdx &&
                                t.userData.tokenIndex === tokenIndex
                            );
                            const isOut = token && token.userData.position >= 58;
                            // Add explicit color class for each token to show distinct colors
                            return `<div class="token-indicator ${PLAYER_COLORS[colorIdx]} ${isOut ? 'home' : ''}"></div>`;
                        })
                    ).join('');

                    // Create wrapper with label above the card
                    const wrapper = document.createElement('div');
                    wrapper.className = 'player-card-wrapper';

                    const isActive = getCurrentOwner() === ownerIdx;

                    wrapper.innerHTML = `
                        <div class="player-card-label">${displayName}${aiSuffix}</div>
                        <div class="player-card ${PLAYER_COLORS[displayColor]} ${isActive ? 'active' : ''}">
                            <div class="player-icon">${getPlayerEmoji(displayColor)}</div>
                            <div class="player-info">
                                <div class="player-status">${outCount}/${requiredOut} out</div>
                            </div>
                            <div class="player-tokens">
                                ${tokenIndicators}
                            </div>
                        </div>
                    `;

                    panel.appendChild(wrapper);
                });
                return;
            }

            [0, 1, 2, 3].forEach((idx) => {
                const player = gameState.players[idx];
                if (!player) return;
                if (!player.active) return;

                const card = document.createElement('div');
                card.className = `player-card ${PLAYER_COLORS[idx]} ${idx === gameState.currentPlayer ? 'active' : ''}`;

                const outCount = getColorOutCount(idx);
                const colorTokens = tokens.filter(t => t.userData.playerIndex === idx);

                card.innerHTML = `
                    <div class="player-icon">${getPlayerEmoji(idx)}</div>
                    <div class="player-info">
                        <div class="player-name">${player.name}${player.type !== 'human' ? ' (AI)' : ''}</div>
                        <div class="player-status">${outCount}/${requiredOut} out</div>
                    </div>
                    <div class="player-tokens">
                        ${[0,1,2,3].map(i => {
                            const token = colorTokens.find(t => t.userData.tokenIndex === i);
                            const isOut = token && token.userData.position >= 58;
                            return `<div class="token-indicator ${isOut ? 'home' : ''}"></div>`;
                        }).join('')}
                    </div>
                `;

                panel.appendChild(card);
            });
        }

        function updateTurnDisplay() {
            const currentPlayer = getCurrentPlayer();
            if (!currentPlayer) return;
            const turnMsg = document.getElementById('turnMessage');
            if (turnMsg) {
                if (isFullMode()) {
                    const currentOwnerIdx = getCurrentOwner();
                    const ownerName = getOwnerDisplayName(currentOwnerIdx);
                    const ownerColors = currentOwnerIdx === 0 ? 'Red/Green' : 'Blue/Yellow';
                    turnMsg.textContent = `${ownerName}'s turn (${ownerColors})${currentPlayer.type !== 'human' ? ' (AI thinking...)' : ''}`;
                } else {
                    turnMsg.textContent = `${currentPlayer.name}'s turn${currentPlayer.type !== 'human' ? ' (AI thinking...)' : ''}`;
                }
            }
            document.body.dataset.turn = PLAYER_COLORS[gameState.currentPlayer];

            const rollBtn = document.getElementById('rollDiceBtn');
            if (rollBtn) {
                const rolling = (dice && dice.userData && dice.userData.rolling) || (dice2 && dice2.userData && dice2.userData.rolling);
                rollBtn.disabled = gameState.phase !== 'roll' || rolling || !isMyTurn();
            }
        }

        function showNotification(message) {
            const notif = document.getElementById('notification');
            notif.textContent = message;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 2000);
        }

        function showModal(id) {
            document.getElementById(id).classList.add('active');
        }

        function hideModal(id) {
            document.getElementById(id).classList.remove('active');
        }

        function refreshStartButton() {
            const btn = document.getElementById('startGameBtn');
            if (!btn) return;
            if (gameMode === 'online' && !isHost) {
                btn.disabled = true;
                btn.textContent = 'Waiting for Host';
            } else {
                btn.disabled = false;
                btn.textContent = 'Start Game';
            }
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundBtn').textContent = gameState.soundEnabled ? '' : '';
        }

        function isTextInputFocused() {
            const el = document.activeElement;
            if (!el) return false;
            const tag = el.tagName ? el.tagName.toLowerCase() : '';
            return tag === 'input' || tag === 'textarea' || tag === 'select' || el.isContentEditable;
        }

        function anyModalActive() {
            return !!document.querySelector('.modal.active');
        }

        function handleKeyboardShortcuts(e) {
            if (isTextInputFocused()) return;

            const key = e.key;
            const isSpace = key === ' ' || key === 'Spacebar';
            const isEnter = key === 'Enter';
            const isArrow = key === 'ArrowLeft' || key === 'ArrowRight' || key === 'ArrowUp' || key === 'ArrowDown';

            // Avoid interfering with menus/modals
            if (anyModalActive()) return;

            // Space = roll dice (when appropriate)
            if (isSpace) {
                const rollBtn = document.getElementById('rollDiceBtn');
                if (rollBtn && !rollBtn.disabled && gameState.phase === 'roll' && getCurrentPlayer().type === 'human' && isMyTurn()) {
                    e.preventDefault();
                    rollBtn.click();
                }
                return;
            }

            // Arrow keys = cycle selectable tokens
            if (isArrow) {
                if (gameState.phase === 'select' && Array.isArray(selectableTokens) && selectableTokens.length > 0) {
                    e.preventDefault();
                    const dir = (key === 'ArrowLeft' || key === 'ArrowUp') ? -1 : 1;
                    keyboardSelectedTokenIndex = (keyboardSelectedTokenIndex + dir + selectableTokens.length) % selectableTokens.length;
                    updateKeyboardTokenHighlight();
                }
                return;
            }

            // Enter = confirm selected token move
            if (isEnter) {
                if (gameState.phase === 'select' && Array.isArray(selectableTokens) && selectableTokens.length > 0) {
                    const token = selectableTokens[keyboardSelectedTokenIndex] || selectableTokens[0];
                    const move = token?.userData?.pendingMove;
                    if (move && move.token && typeof move.newPosition === 'number') {
                        e.preventDefault();
                        executeMove(move.token, move.newPosition, move.type, gameState.currentDieValue);
                    }
                }
            }
        }

        function getPlayerEmoji(idx) {
            return ['', '', '', ''][idx];
        }

        function getDiceEmoji(value) {
            return ['', '', '', '', '', ''][value - 1];
        }

        // ==================== EVENT HANDLERS ====================
        function onWindowResize() {
            const { width, height } = getViewportSize();
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            applyResponsiveCamera();
        }

        function handleTokenSelectEvent(clientX, clientY) {
            if (gameState.phase !== 'select') return;
            if (getCurrentPlayer().type !== 'human') return;
            if (!isMyTurn()) return;

            const { width, height } = getViewportSize();
            mouse.x = (clientX / width) * 2 - 1;
            mouse.y = -(clientY / height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(selectableTokens, true);

            if (intersects.length > 0) {
                let clickedToken = intersects[0].object;
                while (clickedToken.parent && !clickedToken.userData.hasOwnProperty('playerIndex')) {
                    clickedToken = clickedToken.parent;
                }

                if (clickedToken.userData.isSelectable && clickedToken.userData.pendingMove) {
                    const move = clickedToken.userData.pendingMove;
                    executeMove(move.token, move.newPosition, move.type, gameState.currentDieValue);
                }
            }
        }

        function onCanvasClick(event) {
            handleTokenSelectEvent(event.clientX, event.clientY);
        }

        function onCanvasTouch(event) {
            // Use changedTouches so touchend still gives us a point
            const t = (event.changedTouches && event.changedTouches[0]) ||
                      (event.touches && event.touches[0]);
            if (!t) return;
            if (event.cancelable) event.preventDefault();
            handleTokenSelectEvent(t.clientX, t.clientY);
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            // Animate selectable tokens (pulsing)
            selectableTokens.forEach(token => {
                const time = Date.now() * 0.003;
                const scale = 1 + Math.sin(time) * 0.11;
                token.scale.set(scale, scale, scale);

                // Pulsing ring
                if (token.userData.ring) {
                    const pulse = 0.9 + Math.sin(time * 2) * 0.7; // more visible glow bounce
                    token.userData.ring.material.emissiveIntensity = Math.max(0.2, pulse);
                }
            });

            // Smooth camera controls
            if (controls) controls.update();

            updateDebugOverlay();
            updateCoachOverlay();
            renderer.render(scene, camera);
        }

        function resumeAudioIfNeeded() {
            AudioManager.resume();
        }

        // ==================== START ====================
        init();
        animate();

        // Dynamic UI rules for player count / modes
        function updatePlayerSelectorsForCount() {
            const count = parseInt(document.querySelector('input[name="playerCount"]:checked')?.value || '2', 10);
            const twoPlayerMode = document.querySelector('input[name="twoPlayerMode"]:checked')?.value || 'half';
            const options = document.querySelectorAll('.player-option');
            const selects = document.querySelectorAll('.player-type-select');
            const nameInputs = document.querySelectorAll('.player-name-input');
            const setup = document.querySelector('#startMenu .player-setup');

            // Reset disabled/selected state
            options.forEach(opt => opt.classList.remove('disabled'));
            selects.forEach(sel => { sel.disabled = false; });
            nameInputs.forEach(inp => { inp.disabled = false; inp.readOnly = false; });
            if (setup) setup.classList.remove('two-player-full');

            const sel0 = document.querySelector(`.player-type-select[data-player="0"]`);
            const sel1 = document.querySelector(`.player-type-select[data-player="1"]`);
            const sel2 = document.querySelector(`.player-type-select[data-player="2"]`);
            const sel3 = document.querySelector(`.player-type-select[data-player="3"]`);
            const name0 = document.querySelector(`.player-name-input[data-player="0"]`);
            const name1 = document.querySelector(`.player-name-input[data-player="1"]`);
            const name2 = document.querySelector(`.player-name-input[data-player="2"]`);
            const name3 = document.querySelector(`.player-name-input[data-player="3"]`);

            if (count === 2) {
                // In UI, keep all selectable; enforcement happens on start
                // (optional: gray out yellow/blue when half is selected)
                if (twoPlayerMode === 'half') {
                    // Gray out yellow/blue selectors
                    ['2','3'].forEach(idx => {
                        const opt = document.querySelector(`.player-option[data-player="${idx}"]`);
                        const sel = document.querySelector(`.player-type-select[data-player="${idx}"]`);
                        const inp = document.querySelector(`.player-name-input[data-player="${idx}"]`);
                        if (opt) opt.classList.add('disabled');
                        if (sel) sel.disabled = true;
                        if (inp) { inp.disabled = true; inp.readOnly = true; }
                    });
                } else {
                    // Full: 2 humans control 4 colors; configure only Red and Blue directly.
                    // Keep all four cards visible, but lock only the paired name inputs.
                    if (setup) setup.classList.add('two-player-full');
                    if (sel0 && sel1) sel1.value = sel0.value; // Green mirrors Red
                    if (sel3 && sel2) sel2.value = sel3.value; // Yellow mirrors Blue

                    if (name0 && name1) name1.value = name0.value; // Green mirrors Red
                    if (name3 && name2) name2.value = name3.value; // Yellow mirrors Blue

                    // Lock paired controls (Green + Yellow) without greying out the whole card
                    if (sel1) sel1.disabled = true;
                    if (sel2) sel2.disabled = true;
                    if (name1) { name1.readOnly = true; }
                    if (name2) { name2.readOnly = true; }
                }
            } else if (count === 3) {
                // Disable one side (Blue)
                const opt = document.querySelector('.player-option[data-player="3"]');
                const sel = document.querySelector('.player-type-select[data-player="3"]');
                const inp = document.querySelector('.player-name-input[data-player="3"]');
                if (opt) opt.classList.add('disabled');
                if (sel) sel.disabled = true;
                if (inp) { inp.disabled = true; inp.readOnly = true; }
                // Others enabled
                ['0','1','2'].forEach(idx => {
                    const o = document.querySelector(`.player-option[data-player="${idx}"]`);
                    const s = document.querySelector(`.player-type-select[data-player="${idx}"]`);
                    const n = document.querySelector(`.player-name-input[data-player="${idx}"]`);
                    if (o) o.classList.remove('disabled');
                    if (s) s.disabled = false;
                    if (n) { n.disabled = false; n.readOnly = false; }
                });
            } else {
                // 4 players: all enabled
                options.forEach(opt => opt.classList.remove('disabled'));
                selects.forEach(sel => { sel.disabled = false; });
                nameInputs.forEach(inp => { inp.disabled = false; inp.readOnly = false; });
            }
        }

        document.querySelectorAll('input[name="playerCount"]').forEach(r => {
            r.addEventListener('change', updatePlayerSelectorsForCount);
        });
        document.querySelectorAll('input[name="twoPlayerMode"]').forEach(r => {
            r.addEventListener('change', updatePlayerSelectorsForCount);
        });
        // Mirror names/types in 2-player full mode as the user edits them
        document.querySelectorAll('.player-type-select[data-player="0"], .player-type-select[data-player="3"]').forEach(sel => {
            sel.addEventListener('change', updatePlayerSelectorsForCount);
        });
        document.querySelectorAll('.player-name-input[data-player="0"], .player-name-input[data-player="3"]').forEach(inp => {
            inp.addEventListener('input', updatePlayerSelectorsForCount);
        });
        // Initial sync
        updatePlayerSelectorsForCount();
    </script>
</body>
</html>
