<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ludo Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            user-select: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            width: 300px;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #f1c40f;
        }

        p {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Rule Button - Added */
        #rules-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #f1c40f;
            color: #f1c40f;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 10;
            pointer-events: auto;
            transition: 0.2s;
        }

        #rules-toggle:hover {
            background: rgba(241, 196, 15, 0.2);
            transform: scale(1.1);
        }

        /* Rules Modal - Added */
        #rules-modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #rules-content {
            background: #1a1a2e;
            color: white;
            padding: 30px;
            border-radius: 20px;
            border: 2px solid #f1c40f;
            max-width: 450px;
            width: 80%;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        #rules-content h2 {
            color: #f1c40f;
            margin-top: 0;
        }

        #rules-content li {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        /* Roll Button */
        button {
            background: linear-gradient(135deg, #f1c40f, #e67e22);
            border: none;
            padding: 12px 30px;
            color: white;
            font-weight: 800;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.5);
            pointer-events: auto;
            margin-top: 15px;
            transition: all 0.2s;
            outline: none;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.7);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            filter: grayscale(100%);
        }

        /* Loading & Win Screen */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            pointer-events: none;
        }

        #win-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
        }

        #win-title {
            font-size: 4rem;
            font-weight: 900;
            color: #f1c40f;
            margin-bottom: 20px;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>

<body>

    <div id="ui-container">
        <h1>3D Ludo Game</h1>
        <p>Initializing...</p>
        <button onclick="rollDice()" disabled>ROLL DICE</button>
    </div>

    <div id="rules-toggle" onclick="toggleRules()">?</div>
    <div id="rules-modal" onclick="toggleRules()">
        <div id="rules-content" onclick="event.stopPropagation()">
            <h2>How to Play</h2>
            <ul>
                <li>Roll a <b>6</b> to bring a piece out of the base and onto the start square.</li>
                <li>Rolling a <b>6</b> gives you an extra roll!</li>
                <li>Move your pieces clockwise around the board based on your roll.</li>
                <li>Click a pulsing piece to move it after rolling.</li>
                <li>Land all 4 pieces in the center <b>HOME</b> to win.</li>
            </ul>
            <button onclick="toggleRules()" style="width: 100%; margin-top: 10px;">GOT IT</button>
        </div>
    </div>

    <div id="loading">Building Board...</div>

    <div id="win-screen">
        <div id="win-title">VICTORY!</div>
        <p id="win-message" style="font-size: 2rem; margin-bottom: 40px;">Player Wins!</p>
        <button onclick="location.reload()" style="font-size: 1.2rem; padding: 15px 40px;">PLAY AGAIN</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import gsap from 'gsap';

        // Add Rule Toggle Logic
        window.toggleRules = () => {
            const modal = document.getElementById('rules-modal');
            modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
        };

        // ==========================================
        // --- AUDIO ENGINE (PROCEDURAL) ---
        // ==========================================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();

        // Resume context on user interaction (browsers block auto-audio)
        function initAudio() { if (ctx.state === 'suspended') ctx.resume(); }

        const sfx = {
            jump: () => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.1);
                osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                osc.start(); osc.stop(ctx.currentTime + 0.2);
            },
            land: () => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                osc.start(); osc.stop(ctx.currentTime + 0.15);
            },
            roll: () => {
                // Noise buffer for rattle
                const bufferSize = ctx.sampleRate * 0.1;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = ctx.createBufferSource();
                const gain = ctx.createGain();
                noise.buffer = buffer;
                noise.connect(gain); gain.connect(ctx.destination);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                noise.start();
            },
            win: () => {
                const now = ctx.currentTime;
                [392, 523, 659, 783, 1046].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.1, now + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4);
                    osc.start(now + i * 0.1); osc.stop(now + i * 0.1 + 0.4);
                });
            }
        };

        // ==========================================
        // --- ENGINE SETUP ---
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#0b0b14'); // Deep Space
        scene.fog = new THREE.Fog('#0b0b14', 20, 60);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-12, 9, -12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5; controls.maxDistance = 30;

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);

        // --- ATMOSPHERE (Stars) ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPos = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i++) starPos[i] = (Math.random() - 0.5) * 80;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 }));
        scene.add(stars);

        // ==========================================
        // --- PROCEDURAL BOARD ---
        // ==========================================
        function createLudoBoardTexture() {
            const canvas = document.createElement('canvas');
            const size = 2048; canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const step = size / 15; const halfStep = step / 2;

            const colors = { red: '#d32f2f', green: '#2e7d32', yellow: '#fbc02d', blue: '#1565c0', white: '#ffffff', bg: '#f5f5f5' };

            ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#888'; ctx.lineWidth = 4;
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    if ((i < 6 && j < 6) || (i > 8 && j < 6) || (i < 6 && j > 8) || (i > 8 && j > 8)) continue;
                    ctx.strokeRect(i * step, j * step, step, step);
                }
            }

            function drawArrow(col, row, dir) {
                const cx = col * step + halfStep; const cy = row * step + halfStep; const s = step * 0.3;
                ctx.fillStyle = '#222'; ctx.beginPath();
                if (dir === 'r') { ctx.moveTo(cx - s, cy - s / 2); ctx.lineTo(cx + s, cy); ctx.lineTo(cx - s, cy + s / 2); }
                if (dir === 'u') { ctx.moveTo(cx - s / 2, cy + s); ctx.lineTo(cx, cy - s); ctx.lineTo(cx + s / 2, cy + s); }
                if (dir === 'l') { ctx.moveTo(cx + s, cy - s / 2); ctx.lineTo(cx - s, cy); ctx.lineTo(cx + s, cy + s / 2); }
                if (dir === 'd') { ctx.moveTo(cx - s / 2, cy - s); ctx.lineTo(cx, cy + s); ctx.lineTo(cx + s / 2, cy - s); }
                ctx.fill();
            }

            drawArrow(1, 6, 'r'); drawArrow(3, 6, 'r'); drawArrow(5, 6, 'r');
            drawArrow(6, 4, 'u'); drawArrow(6, 1, 'u');
            drawArrow(8, 1, 'd'); drawArrow(8, 4, 'd');
            drawArrow(10, 6, 'r'); drawArrow(13, 6, 'r');
            drawArrow(13, 8, 'l'); drawArrow(11, 8, 'l'); drawArrow(9, 8, 'l');
            drawArrow(8, 10, 'd'); drawArrow(8, 13, 'd');
            drawArrow(6, 13, 'u'); drawArrow(6, 10, 'u');
            drawArrow(4, 8, 'l'); drawArrow(1, 8, 'l');

            function drawBase(x, y, color) {
                ctx.fillStyle = color; ctx.fillRect(x * step, y * step, 6 * step, 6 * step);
                ctx.fillStyle = colors.white; ctx.fillRect((x + 0.5) * step, (y + 0.5) * step, 5 * step, 5 * step);
                ctx.fillStyle = color; const r = step * 0.35;
                [[2, 2], [2, 4], [4, 2], [4, 4]].forEach(p => {
                    ctx.beginPath(); ctx.arc((x + p[0]) * step + halfStep, (y + p[1]) * step + halfStep, r, 0, Math.PI * 2); ctx.fill();
                });
            }
            drawBase(0, 0, colors.green); drawBase(9, 0, colors.yellow);
            drawBase(0, 9, colors.red); drawBase(9, 9, colors.blue);

            ctx.font = `bold ${step * 0.4}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

            // Tracks
            ctx.fillStyle = colors.green; ctx.fillRect(1 * step, 6 * step, step, step); ctx.fillStyle = colors.white; ctx.fillText("S", 1.5 * step, 6.5 * step);
            ctx.fillStyle = colors.green; for (let i = 1; i < 6; i++) ctx.fillRect(i * step, 7 * step, step, step);

            ctx.fillStyle = colors.yellow; ctx.fillRect(8 * step, 1 * step, step, step); ctx.fillStyle = '#333'; ctx.fillText("S", 8.5 * step, 1.5 * step);
            ctx.fillStyle = colors.yellow; for (let i = 1; i < 6; i++) ctx.fillRect(7 * step, i * step, step, step);

            ctx.fillStyle = colors.blue; ctx.fillRect(13 * step, 8 * step, step, step); ctx.fillStyle = colors.white; ctx.fillText("S", 13.5 * step, 8.5 * step);
            ctx.fillStyle = colors.blue; for (let i = 9; i < 14; i++) ctx.fillRect(i * step, 7 * step, step, step);

            ctx.fillStyle = colors.red; ctx.fillRect(6 * step, 13 * step, step, step); ctx.fillStyle = colors.white; ctx.fillText("S", 6.5 * step, 13.5 * step);
            ctx.fillStyle = colors.red; for (let i = 9; i < 14; i++) ctx.fillRect(7 * step, i * step, step, step);

            // Center
            const c = 7.5 * step;
            ctx.fillStyle = colors.green; ctx.beginPath(); ctx.moveTo(6 * step, 6 * step); ctx.lineTo(6 * step, 9 * step); ctx.lineTo(c, c); ctx.fill();
            ctx.fillStyle = colors.yellow; ctx.beginPath(); ctx.moveTo(6 * step, 6 * step); ctx.lineTo(9 * step, 6 * step); ctx.lineTo(c, c); ctx.fill();
            ctx.fillStyle = colors.blue; ctx.beginPath(); ctx.moveTo(9 * step, 6 * step); ctx.lineTo(9 * step, 9 * step); ctx.lineTo(c, c); ctx.fill();
            ctx.fillStyle = colors.red; ctx.beginPath(); ctx.moveTo(9 * step, 9 * step); ctx.lineTo(6 * step, 9 * step); ctx.lineTo(c, c); ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.beginPath(); ctx.arc(c, c, step * 0.8, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#333'; ctx.fillText("HOME", c, c);

            const tex = new THREE.CanvasTexture(canvas); tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); return tex;
        }

        const boardMat = new THREE.MeshStandardMaterial({ map: createLudoBoardTexture(), roughness: 0.8, metalness: 0.0 });
        const sideMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.9 });
        const board = new THREE.Mesh(new THREE.BoxGeometry(10, 0.4, 10), [sideMat, sideMat, boardMat, sideMat, sideMat, sideMat]);
        board.receiveShadow = true; board.castShadow = true; scene.add(board);

        const table = new THREE.Mesh(new THREE.CylinderGeometry(13, 15, 0.5, 64), new THREE.MeshStandardMaterial({ color: 0x212121 }));
        table.position.y = -0.45; table.receiveShadow = true; scene.add(table);

        // --- PIECES ---
        function getBoardPoint(col, row) {
            const cellSize = 10 / 15;
            return new THREE.Vector3((col * cellSize) - 5 + (cellSize / 2), 0.4, (row * cellSize) - 5 + (cellSize / 2));
        }

        function createPawn(colorHex) {
            const grp = new THREE.Group();
            const mat = new THREE.MeshPhysicalMaterial({
                color: colorHex,
                roughness: 0.2,
                metalness: 0.1,
                clearcoat: 1.0
            });

            // The Wide Base (The "Foot" that plants it)
            const baseGeo = new THREE.CylinderGeometry(0.25, 0.28, 0.05, 32);
            const base = new THREE.Mesh(baseGeo, mat);
            base.position.y = 0.025; // Half height to sit on 0

            // The Body (Cone)
            const bodyGeo = new THREE.ConeGeometry(0.2, 0.6, 32);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 0.3 + 0.05; // Stack on top of base

            // The Head (Sphere)
            const headGeo = new THREE.SphereGeometry(0.15, 32);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = 0.65 + 0.05;

            // The Collar (Ring)
            const collarGeo = new THREE.TorusGeometry(0.1, 0.04, 16, 32);
            const collar = new THREE.Mesh(collarGeo, mat);
            collar.position.y = 0.52 + 0.05;
            collar.rotation.x = Math.PI / 2;

            // The Shadow (Darker and Wider)
            const shadGeo = new THREE.CircleGeometry(0.35, 32); // Wider than base (0.28)
            const shadMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.6, // Darker shadow
            });
            const shad = new THREE.Mesh(shadGeo, shadMat);
            shad.rotation.x = -Math.PI / 2;
            shad.position.y = 0.005; // Just barely above board to prevent Z-fighting

            grp.add(shad, base, body, head, collar);

            // Enable real shadows for 3D parts
            grp.children.slice(1).forEach(m => {
                m.castShadow = true;
                m.receiveShadow = true;
            });

            return grp;
        }

        const pieces = [];
        const homes = [
            { color: 0x2e7d32, type: 'green', pos: [[2, 2], [2, 4], [4, 2], [4, 4]] },
            { color: 0xfbc02d, type: 'yellow', pos: [[11, 2], [11, 4], [13, 2], [13, 4]] },
            { color: 0x1565c0, type: 'blue', pos: [[11, 11], [11, 13], [13, 11], [13, 13]] },
            { color: 0xd32f2f, type: 'red', pos: [[2, 11], [2, 13], [4, 11], [4, 13]] }
        ];

        homes.forEach(home => {
            home.pos.forEach((p, idx) => {
                const pawn = createPawn(home.color);
                pawn.position.copy(getBoardPoint(p[0], p[1]));
                pawn.userData = { color: home.type, isHome: true, gridPos: p, steps: 0 };
                scene.add(pawn); pieces.push(pawn);
            });
        });

        // --- DICE ---
        function createDiceFace(n) {
            const c = document.createElement('canvas'); c.width = 128; c.height = 128;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#000';
            const dot = (x, y) => { ctx.beginPath(); ctx.arc(x, y, 14, 0, Math.PI * 2); ctx.fill(); };
            if (n % 2) dot(64, 64); if (n > 1) { dot(32, 32); dot(96, 96); } if (n > 3) { dot(96, 32); dot(32, 96); } if (n == 6) { dot(32, 64); dot(96, 64); }
            return new THREE.CanvasTexture(c);
        }
        const diceGroup = new THREE.Group();
        const die = new THREE.Mesh(new RoundedBoxGeometry(0.8, 0.8, 0.8, 4, 0.1), [5, 2, 1, 6, 3, 4].map(n => new THREE.MeshStandardMaterial({ map: createDiceFace(n) })));
        die.castShadow = true; diceGroup.add(die); diceGroup.visible = false; scene.add(diceGroup);
        const faceRotations = { 1: { x: 0, z: 0 }, 6: { x: Math.PI, z: 0 }, 2: { x: 0, z: -Math.PI / 2 }, 5: { x: 0, z: Math.PI / 2 }, 3: { x: -Math.PI / 2, z: 0 }, 4: { x: Math.PI / 2, z: 0 } };

        // --- GAME LOGIC ---
        const mainPath = [
            [1, 6], [2, 6], [3, 6], [4, 6], [5, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0], [8, 0],
            [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [9, 6], [10, 6], [11, 6], [12, 6], [13, 6], [14, 6], [14, 7], [14, 8],
            [13, 8], [12, 8], [11, 8], [10, 8], [9, 8], [8, 9], [8, 10], [8, 11], [8, 12], [8, 13], [8, 14], [7, 14], [6, 14],
            [6, 13], [6, 12], [6, 11], [6, 10], [6, 9], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [0, 7], [0, 6]
        ];

        const startIndices = { 'green': 0, 'yellow': 13, 'blue': 27, 'red': 40 };

        const homeRuns = {
            'green': [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]], 'yellow': [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6]],
            'blue': [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [8, 7]], 'red': [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8]]
        };
        const centerPos = [7.5, 7.5];

        let turnIdx = 0, turnOrder = ['green', 'yellow', 'blue', 'red'], diceVal = 0, waiting = false, isRolling = false;
        const uiText = document.querySelector('#ui-container p');
        const uiBtn = document.querySelector('button');

        window.rollDice = function () {
            if (isRolling) return;
            initAudio(); // INIT AUDIO ON FIRST CLICK
            isRolling = true; uiBtn.disabled = true; diceGroup.visible = true; diceGroup.position.set(0, 3, 0);

            const res = Math.floor(Math.random() * 6) + 1;
            const rot = faceRotations[res];

            // Dice Shake/Roll Sound
            const rollInt = setInterval(sfx.roll, 100);

            const tl = gsap.timeline({ onComplete: () => { clearInterval(rollInt); sfx.land(); processResult(res); } });
            tl.to(diceGroup.position, { y: 5, duration: 0.3 })
                .to(die.rotation, { x: rot.x + Math.PI * 4, z: rot.z + Math.PI * 4, y: Math.random() * Math.PI * 2, duration: 0.8, ease: "bounce.out" }, "<")
                .to(diceGroup.position, { y: 0.6, duration: 0.8, ease: "bounce.out" }, "-=0.8");
        };

        function processResult(val) {
            isRolling = false; diceVal = val;
            const color = turnOrder[turnIdx];
            uiText.innerHTML = `Rolled <b style="color:#f1c40f">${val}</b>`;

            const myPieces = pieces.filter(p => p.userData.color === color);
            const canMove = myPieces.some(p => { const d = p.userData; return d.isHome ? val === 6 : d.steps + val <= 57; });

            if (!canMove) {
                uiText.innerHTML += ". No moves!";
                setTimeout(nextTurn, 1000);
            } else {
                waiting = true;
                uiText.innerHTML += ". Select piece.";
                myPieces.forEach(p => {
                    const d = p.userData;
                    if ((d.isHome && val == 6) || (!d.isHome && d.steps + val <= 57)) {
                        gsap.to(p.position, { y: 0.6, duration: 0.3, yoyo: true, repeat: -1, overwrite: true });
                    }
                });
            }
        }

        const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        window.onclick = (e) => {
            if (!waiting) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            ray.setFromCamera(mouse, camera);
            const hits = ray.intersectObjects(pieces, true);
            if (hits.length) {
                let obj = hits[0].object;
                while (obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                if (obj.userData.color === turnOrder[turnIdx]) movePiece(obj);
            }
        };

        function movePiece(p) {
            const d = p.userData;
            if (d.isHome && diceVal !== 6) return shake(p);
            if (!d.isHome && d.steps + diceVal > 57) return shake(p);

            pieces.forEach(p => { gsap.killTweensOf(p.position); if (!p.userData.moving) p.position.y = 0.4; });
            waiting = false; uiBtn.disabled = true; d.moving = true;

            let targetGrid;
            if (d.isHome) { d.pathIdx = startIndices[d.color]; d.steps = 0; d.isHome = false; targetGrid = mainPath[d.pathIdx]; }
            else {
                d.steps += diceVal;
                if (d.steps > 50) { const idx = d.steps - 51; targetGrid = (idx < 6) ? homeRuns[d.color][idx] : centerPos; }
                else { d.pathIdx = (d.pathIdx + diceVal) % 52; targetGrid = mainPath[d.pathIdx]; }
            }

            const wPos = getBoardPoint(targetGrid[0], targetGrid[1]);
            const tl = gsap.timeline({
                onComplete: () => {
                    d.moving = false; sfx.land();
                    if (d.steps === 57) winGame(d.color);
                    else if (diceVal === 6) { uiText.innerHTML = "Roll 6 again!"; uiBtn.disabled = false; }
                    else nextTurn();
                }
            });
            sfx.jump();
            tl.to(p.position, { x: wPos.x, z: wPos.z, duration: 0.6 })
                .to(p.position, { y: 1.5, duration: 0.3, yoyo: true, repeat: 1 }, "<");
        }

        function shake(p) { gsap.to(p.rotation, { z: 0.4, duration: 0.1, yoyo: true, repeat: 3 }); }

        function nextTurn() {
            turnIdx = (turnIdx + 1) % 4;
            const color = turnOrder[turnIdx];
            uiText.innerHTML = `Current Turn: <b style="color:${homes[turnIdx].color.toString(16).replace('0x', '#')}">${color.toUpperCase()}</b>`;
            uiBtn.innerText = "ROLL DICE"; uiBtn.disabled = false; diceGroup.visible = false;
            let tx, tz; const dist = 12; const height = 9;
            if (turnIdx === 0) { tx = -dist; tz = -dist; } if (turnIdx === 1) { tx = dist; tz = -dist; }
            if (turnIdx === 2) { tx = dist; tz = dist; } if (turnIdx === 3) { tx = -dist; tz = dist; }
            gsap.to(camera.position, { x: tx, z: tz, y: height, duration: 1.5, ease: "power2.inOut", onUpdate: () => camera.lookAt(0, 0, 0) });
        }

        // --- CONFETTI ON WIN ---
        const confetti = [];
        function spawnConfetti() {
            const geo = new THREE.PlaneGeometry(0.2, 0.2);
            for (let i = 0; i < 200; i++) {
                const mat = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide });
                const c = new THREE.Mesh(geo, mat);
                c.position.set(0, 10, 0);
                c.vel = new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5);
                scene.add(c); confetti.push(c);
            }
        }

        function winGame(winner) {
            sfx.win(); spawnConfetti();
            document.getElementById('win-screen').style.display = 'flex';
            document.getElementById('win-message').innerText = `${winner.toUpperCase()} WINS!`;
        }

        document.getElementById('loading').remove();
        updateUI();
        function updateUI() { uiText.innerHTML = `Current Turn: <b style="color:#2ecc71">GREEN</b>`; uiBtn.disabled = false; }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            // Stars animation
            stars.rotation.y += 0.0005;
            // Confetti animation
            confetti.forEach(c => { c.position.add(c.vel); c.rotation.x += 0.1; c.rotation.y += 0.1; });
            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };
    </script>
</body>

</html>