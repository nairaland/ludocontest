<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo 3D - Nairaland Challenge</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --red: #ea4330;
            --red-dark: #a32011;
            --red-light: #d22915;
            --red-bg: #fae4dc;
            --green: #34a853;
            --green-dark: #1c5a2d;
            --green-light: #288140;
            --green-bg: #ebfaea;
            --blue: #4285f4;
            --blue-dark: #0b51c5;
            --blue-light: #1266f1;
            --blue-bg: #e1ecf7;
            --yellow: #fbbc05;
            --yellow-dark: #987102;
            --yellow-light: #ca9703;
            --yellow-bg: #f3f1e5;
            --primary-bg: #0a1628;
            --secondary-bg: #1a2a4a;
            --card-bg: rgba(26, 42, 74, 0.95);
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --accent: #4285f4;
            --current-color: var(--red);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--primary-bg);
        }

        /* Menu Styles */
        .menu-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a1628 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 2rem;
        }

        .menu-overlay.hidden {
            display: none;
        }

        .menu-title {
            font-size: 3.5rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--red), var(--yellow), var(--green), var(--blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .menu-subtitle {
            color: var(--text-secondary);
            margin-bottom: 3rem;
            font-size: 1.1rem;
        }

        .menu-container {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 900px;
        }

        .mode-card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 2rem;
            width: 380px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .mode-card:hover {
            transform: translateY(-8px);
            border-color: var(--accent);
            box-shadow: 0 20px 40px rgba(66, 133, 244, 0.2);
        }

        .mode-card h3 {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .mode-card p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .mode-card .icon {
            font-size: 1.3rem;
        }

        .player-options {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .player-btn {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: transparent;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .player-btn:hover,
        .player-btn.selected {
            border-color: var(--accent);
            background: rgba(66, 133, 244, 0.2);
        }

        .start-btn {
            width: 100%;
            padding: 1rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent), #1266f1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            opacity: 0.5;
            pointer-events: none;
        }

        .start-btn.active {
            opacity: 1;
            pointer-events: auto;
        }

        .start-btn.active:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(66, 133, 244, 0.4);
        }

        /* Color Selection */
        .color-selection {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .color-selection.active {
            display: flex;
        }

        .color-panel {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 2.5rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .color-panel h3 {
            color: #fff;
            text-align: center;
            margin-bottom: 0.5rem;
            font-size: 1.5rem;
        }

        .color-panel .player-label {
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 2rem;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .color-option {
            padding: 1.25rem;
            border-radius: 12px;
            border: 3px solid transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.2s;
            text-transform: capitalize;
        }

        .color-option:hover {
            transform: scale(1.03);
        }

        .color-option.selected {
            border-color: #fff;
            box-shadow: 0 0 20px currentColor;
        }

        .color-option.disabled {
            opacity: 0.3;
            pointer-events: none;
        }

        .color-option.red {
            background: var(--red);
            color: #fff;
        }

        .color-option.green {
            background: var(--green);
            color: #fff;
        }

        .color-option.blue {
            background: var(--blue);
            color: #fff;
        }

        .color-option.yellow {
            background: var(--yellow);
            color: #000;
        }

        .color-buttons {
            display: flex;
            gap: 0.75rem;
            flex-direction: column;
        }

        .color-btn-row {
            display: flex;
            gap: 0.75rem;
        }

        .confirm-colors {
            flex: 1;
            padding: 1rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--green), var(--green-dark));
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .confirm-colors:hover:not(:disabled) {
            transform: scale(1.02);
        }

        .confirm-colors:disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .back-btn {
            padding: 1rem 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .back-btn:hover {
            border-color: var(--accent);
            color: #fff;
            background: rgba(66, 133, 244, 0.1);
        }

        /* Game Layout */
        .game-container {
            display: none;
            width: 100%;
            height: 100%;
        }

        .game-container.active {
            display: flex;
        }

        #board-container {
            flex: 1;
            height: 100%;
            position: relative;
        }

        #board-container canvas {
            display: block;
        }

        .board-controls {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }

        .board-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .board-control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }

        .board-control-btn.active {
            background: var(--accent);
            color: white;
        }

        .music-controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            z-index: 100;
        }

        .board-control-btn.music-off {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Control Panel */
        .control-panel {
            width: 360px;
            height: 100%;
            background: linear-gradient(180deg, var(--secondary-bg) 0%, var(--primary-bg) 100%);
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            gap: 1.25rem;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        .game-title {
            font-size: 1.75rem;
            font-weight: 700;
            text-align: center;
            color: #fff;
            background: linear-gradient(135deg, var(--red), var(--yellow), var(--green), var(--blue));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .current-player-section {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .current-player-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .current-player-name {
            font-size: 1.5rem;
            font-weight: 600;
            text-transform: capitalize;
            color: var(--current-color);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .message-box {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.95rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Dice */
        .dice-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .dice-container {
            width: 80px;
            height: 80px;
            cursor: pointer;
        }

        .dice {
            position: relative;
            width: 80px;
            height: 80px;
            transform-style: preserve-3d;
            transform-origin: 40px 40px -40px;
            transform: rotateX(0deg) rotateY(0deg);
            transition: transform 1.5s ease-in-out;
        }

        .dice .face {
            position: absolute;
            background: radial-gradient(circle at center, #fff, #e8e8e8);
            width: 80px;
            height: 80px;
            border-radius: 8px;
            transform-origin: 40px 40px -40px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);
        }

        .dice .face:nth-child(1) {
            transform: rotateY(0deg);
        }

        .dice .face:nth-child(2) {
            transform: rotateY(90deg);
        }

        .dice .face:nth-child(3) {
            transform: rotateY(180deg);
        }

        .dice .face:nth-child(4) {
            transform: rotateY(270deg);
        }

        .dice .face:nth-child(5) {
            transform: rotateX(90deg);
        }

        .dice .face:nth-child(6) {
            transform: rotateX(270deg);
        }

        .dice .point {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #1a1a2e;
            box-shadow: inset 3px 0 6px rgba(0, 0, 0, 0.4);
        }

        .point-top {
            top: 12px;
        }

        .point-middle {
            top: 33px;
        }

        .point-bottom {
            bottom: 12px;
        }

        .point-left {
            left: 12px;
        }

        .point-center {
            left: 33px;
        }

        .point-right {
            right: 12px;
        }

        .roll-btn {
            padding: 0.9rem 2.5rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent), #1266f1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .roll-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(66, 133, 244, 0.4);
        }

        .roll-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Scoreboard */
        .scoreboard {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scoreboard h4 {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
            text-align: center;
        }

        .score-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .score-item.current {
            box-shadow: 0 0 0 2px var(--current-color);
        }

        .score-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .score-dot.red {
            background: var(--red);
        }

        .score-dot.green {
            background: var(--green);
        }

        .score-dot.blue {
            background: var(--blue);
        }

        .score-dot.yellow {
            background: var(--yellow);
        }

        .score-name {
            color: #fff;
            font-size: 0.8rem;
            flex: 1;
            white-space: nowrap;
        }

        .score-value {
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-weight: 600;
        }

        .score-item .fa-robot {
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: auto;
        }

        .action-btn {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
        }

        .action-btn:hover {
            border-color: var(--accent);
            color: #fff;
            background: rgba(66, 133, 244, 0.1);
        }

        /* Rules Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 2rem;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 2rem;
            max-width: 550px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h3 {
            color: #fff;
            font-size: 1.4rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.5rem;
        }

        .modal-close:hover {
            color: #fff;
        }

        .rule-item {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .rule-number {
            width: 28px;
            height: 28px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: 600;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .rule-text {
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 0.95rem;
        }

        .rule-text strong {
            color: #fff;
        }

        /* Win Modal */
        .win-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .win-modal.active {
            display: flex;
        }

        .win-content {
            text-align: center;
            padding: 3rem;
        }

        .win-icon {
            font-size: 5rem;
            margin-bottom: 1.5rem;
        }

        .win-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .win-player {
            font-size: 1.5rem;
            text-transform: capitalize;
            margin-bottom: 2rem;
        }

        .win-btn {
            padding: 1rem 3rem;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent), #1266f1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .win-btn:hover {
            transform: scale(1.05);
        }

        /* Help Button on Menu */
        .help-btn {
            margin-top: 2rem;
            padding: 0.75rem 2rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .help-btn:hover {
            border-color: var(--accent);
            color: #fff;
            background: rgba(66, 133, 244, 0.1);
        }

        /* Help Modal Sections */
        .help-section {
            margin-bottom: 1.5rem;
        }

        .help-section h4 {
            color: #fff;
            font-size: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .help-section h4 i {
            color: var(--accent);
        }

        .help-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .help-item i {
            width: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
        }

        .help-item strong {
            color: #fff;
        }

        /* Confetti Canvas */
        #confettiCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3001;
        }

        /* ============ RESPONSIVE STYLES ============ */

        /* Tablet Breakpoint */
        @media (max-width: 1024px) {
            .control-panel {
                width: 300px;
                padding: 1.25rem;
                gap: 1rem;
            }

            .mode-card {
                width: 340px;
                padding: 1.5rem;
            }

            .menu-title {
                font-size: 3rem;
            }
        }

        /* Mobile Landscape / Small Tablet */
        @media (max-width: 768px) {
            .menu-title {
                font-size: 2.5rem;
            }

            .menu-subtitle {
                font-size: 1rem;
                margin-bottom: 2rem;
            }

            .menu-container {
                flex-direction: column;
                gap: 1rem;
                width: 100%;
                padding: 0 1rem;
            }

            .mode-card {
                width: 100%;
                max-width: 400px;
                padding: 1.25rem;
            }

            .mode-card h3 {
                font-size: 1.25rem;
            }

            .mode-card p {
                font-size: 0.85rem;
                margin-bottom: 1rem;
            }

            /* Game Layout - Vertical Stack */
            .game-container.active {
                flex-direction: column;
            }

            #board-container {
                flex: none;
                width: 100%;
                height: 66vh;
                min-height: 280px;
                max-height: 66vh;
            }

            .control-panel {
                width: 100%;
                height: auto;
                min-height: 280px;
                flex: 1;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 0.75rem;
                gap: 0.75rem;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                overflow-y: auto;
                align-content: flex-start;
            }

            .game-title {
                display: none;
            }

            .current-player-section {
                flex: 1;
                min-width: 120px;
                padding: 0.75rem;
            }

            .current-player-label {
                font-size: 0.7rem;
            }

            .current-player-name {
                font-size: 1.1rem;
            }

            .message-box {
                flex: 2;
                min-width: 150px;
                padding: 0.5rem;
                font-size: 0.85rem;
                min-height: 40px;
            }

            .dice-section {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
                order: 2;
            }

            .dice-container,
            .dice,
            .dice .face {
                width: 60px;
                height: 60px;
            }

            .dice {
                transform-origin: 30px 30px -30px;
            }

            .dice .face {
                transform-origin: 30px 30px -30px;
            }

            .dice .point {
                width: 10px;
                height: 10px;
            }

            .point-top {
                top: 8px;
            }

            .point-middle {
                top: 25px;
            }

            .point-bottom {
                bottom: 8px;
            }

            .point-left {
                left: 8px;
            }

            .point-center {
                left: 25px;
            }

            .point-right {
                right: 8px;
            }

            .roll-btn {
                padding: 0.6rem 1.5rem;
                font-size: 0.9rem;
            }

            .scoreboard {
                flex: 1;
                min-width: 120px;
                padding: 0.75rem;
                order: 1;
            }

            .scoreboard h4 {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }

            .score-grid {
                gap: 0.5rem;
            }

            .score-item {
                padding: 0.4rem 0.5rem;
            }

            .score-dot {
                width: 10px;
                height: 10px;
            }

            .score-name {
                display: none;
            }

            .score-item .fa-robot {
                display: none;
            }

            .score-value {
                font-size: 0.7rem;
            }

            .action-buttons {
                min-width: 100%;
                gap: 0.5rem;
                margin-top: 0;
                order: 3;
            }

            .action-btn {
                padding: 0.5rem;
                font-size: 0.75rem;
            }

            /* Modals */
            .modal-content {
                padding: 1.5rem;
                max-height: 85vh;
            }

            .modal-header h3 {
                font-size: 1.2rem;
            }

            .rule-item {
                margin-bottom: 0.75rem;
            }

            .rule-number {
                width: 24px;
                height: 24px;
                font-size: 0.75rem;
            }

            .rule-text {
                font-size: 0.85rem;
            }

            /* Color Selection */
            .color-panel {
                padding: 1.5rem;
                max-width: 90%;
            }

            .color-panel h3 {
                font-size: 1.25rem;
            }

            .color-grid {
                gap: 0.75rem;
                margin-bottom: 1.5rem;
            }

            .color-option {
                padding: 1rem;
                font-size: 0.9rem;
            }
        }

        /* Small Mobile */
        @media (max-width: 480px) {
            .menu-overlay {
                padding: 1rem;
            }

            .menu-title {
                font-size: 2rem;
            }

            .menu-subtitle {
                font-size: 0.9rem;
                margin-bottom: 1.5rem;
            }

            .mode-card {
                padding: 1rem;
            }

            .mode-card h3 {
                font-size: 1.1rem;
                gap: 0.5rem;
            }

            .mode-card .icon {
                font-size: 1rem;
            }

            .mode-card p {
                font-size: 0.8rem;
                line-height: 1.4;
            }

            .player-options {
                gap: 0.5rem;
                margin-bottom: 1rem;
            }

            .player-btn {
                padding: 0.5rem;
                font-size: 0.85rem;
            }

            .start-btn {
                padding: 0.75rem;
                font-size: 0.9rem;
            }

            /* Control Panel - More Compact */
            .control-panel {
                min-height: 240px;
                padding: 0.5rem;
                gap: 0.5rem;
            }

            #board-container {
                height: 62vh;
                max-height: 62vh;
            }

            .current-player-section {
                padding: 0.5rem;
            }

            .current-player-name {
                font-size: 1rem;
            }

            .message-box {
                font-size: 0.8rem;
                padding: 0.4rem;
            }

            .dice-container,
            .dice,
            .dice .face {
                width: 50px;
                height: 50px;
            }

            .dice {
                transform-origin: 25px 25px -25px;
            }

            .dice .face {
                transform-origin: 25px 25px -25px;
            }

            .dice .point {
                width: 8px;
                height: 8px;
            }

            .point-top {
                top: 6px;
            }

            .point-middle {
                top: 21px;
            }

            .point-bottom {
                bottom: 6px;
            }

            .point-left {
                left: 6px;
            }

            .point-center {
                left: 21px;
            }

            .point-right {
                right: 6px;
            }

            .roll-btn {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
            }

            .scoreboard {
                padding: 0.5rem;
            }

            .action-btn {
                padding: 0.4rem;
                font-size: 0.7rem;
            }

            /* Board Controls */
            .board-controls,
            .music-controls {
                bottom: 0.5rem;
            }

            .board-controls {
                left: 0.5rem;
            }

            .music-controls {
                right: 0.5rem;
            }

            .board-control-btn {
                width: 36px;
                height: 36px;
                font-size: 0.9rem;
            }

            /* Color Selection */
            .color-panel {
                padding: 1rem;
            }

            .color-panel h3 {
                font-size: 1.1rem;
                margin-bottom: 0.25rem;
            }

            .color-panel .player-label {
                font-size: 0.85rem;
                margin-bottom: 1rem;
            }

            .color-grid {
                gap: 0.5rem;
                margin-bottom: 1rem;
            }

            .color-option {
                padding: 0.75rem;
                font-size: 0.8rem;
                border-radius: 8px;
            }

            .color-buttons {
                gap: 0.5rem;
            }

            .confirm-colors,
            .back-btn {
                padding: 0.75rem;
                font-size: 0.9rem;
            }

            /* Win Modal */
            .win-content {
                padding: 2rem 1.5rem;
            }

            .win-icon {
                font-size: 3.5rem;
                margin-bottom: 1rem;
            }

            .win-title {
                font-size: 2rem;
            }

            .win-player {
                font-size: 1.25rem;
                margin-bottom: 1.5rem;
            }

            .win-btn {
                padding: 0.75rem 2rem;
                font-size: 1rem;
            }

            /* Rules Modal */
            .modal-content {
                padding: 1rem;
            }

            .modal-header {
                margin-bottom: 1rem;
            }

            .modal-header h3 {
                font-size: 1.1rem;
            }

            .rule-item {
                gap: 0.75rem;
                margin-bottom: 0.6rem;
            }

            .rule-number {
                width: 22px;
                height: 22px;
                font-size: 0.7rem;
            }

            .rule-text {
                font-size: 0.8rem;
                line-height: 1.5;
            }
        }

        /* Extra Small - Ensure touch targets */
        @media (max-width: 360px) {
            .control-panel {
                max-height: 160px;
            }

            .dice-container,
            .dice,
            .dice .face {
                width: 44px;
                height: 44px;
            }

            .dice {
                transform-origin: 22px 22px -22px;
            }

            .dice .face {
                transform-origin: 22px 22px -22px;
            }

            .score-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>

<body>
    <!-- Main Menu -->
    <div class="menu-overlay" id="menuOverlay">
        <h1 class="menu-title">LUDO 3D</h1>
        <p class="menu-subtitle">A Classic Board Game in 3D</p>
        <div class="menu-container">
            <div class="mode-card" id="passPlayCard">
                <h3><i class="fas fa-users icon"></i> Pass and Play</h3>
                <p>Local multiplayer on the same device. Take turns with friends and family.</p>
                <div class="player-options">
                    <button class="player-btn" data-players="2">2 Players</button>
                    <button class="player-btn" data-players="4">4 Players</button>
                </div>
                <button class="start-btn" data-mode="passplay"><i class="fas fa-play"></i> Start Game</button>
            </div>
            <div class="mode-card" id="vsComputerCard">
                <h3><i class="fas fa-robot icon"></i> Vs Computer</h3>
                <p>Challenge AI opponents. Test your skills against computer-controlled players.</p>
                <div class="player-options">
                    <button class="player-btn" data-players="2">1v1 Bot</button>
                    <button class="player-btn" data-players="4">1v3 Bots</button>
                </div>
                <button class="start-btn" data-mode="vscomputer"><i class="fas fa-play"></i> Start Game</button>
            </div>
        </div>
        <button class="help-btn" id="menuHelpBtn"><i class="fas fa-question-circle"></i> Help</button>
    </div>

    <!-- Color Selection -->
    <div class="color-selection" id="colorSelection">
        <div class="color-panel">
            <h3>Choose Your Colors</h3>
            <p class="player-label" id="colorPlayerLabel">Player 1, select your color:</p>
            <div class="color-grid" id="colorGrid">
                <div class="color-option red" data-color="red"><i class="fas fa-chess-pawn"></i> Red</div>
                <div class="color-option green" data-color="green"><i class="fas fa-chess-pawn"></i> Green</div>
                <div class="color-option blue" data-color="blue"><i class="fas fa-chess-pawn"></i> Blue</div>
                <div class="color-option yellow" data-color="yellow"><i class="fas fa-chess-pawn"></i> Yellow</div>
            </div>
            <div class="color-buttons">
                <button class="confirm-colors" id="confirmColors" disabled>Confirm Selection</button>
                <button class="back-btn" id="colorBackBtn"><i class="fas fa-arrow-left"></i> Back to Menu</button>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="gameContainer">
        <div id="board-container">
            <!-- Board control buttons -->
            <div class="board-controls">
                <button class="board-control-btn" id="fullscreenBtn" title="Toggle Fullscreen">
                    <i class="fas fa-expand"></i>
                </button>
                <button class="board-control-btn" id="lockBoardBtn" title="Lock/Unlock Board Rotation">
                    <i class="fas fa-lock-open"></i>
                </button>
                <button class="board-control-btn" id="topViewBtn" title="Toggle Top View">
                    <i class="fas fa-camera"></i>
                </button>
                <button class="board-control-btn" id="zoomInBtn" title="Zoom In">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="board-control-btn" id="zoomOutBtn" title="Zoom Out">
                    <i class="fas fa-minus"></i>
                </button>
            </div>
            <!-- Music control button (bottom-right) -->
            <div class="music-controls">
                <button class="board-control-btn" id="musicBtn" title="Toggle Background Music">
                    <i class="fas fa-music"></i>
                </button>
            </div>
        </div>
        <div class="control-panel">
            <h2 class="game-title">LUDO 3D</h2>
            <div class="current-player-section">
                <div class="current-player-label">Current Turn</div>
                <div class="current-player-name" id="currentPlayer"><i class="fas fa-user"></i> <span>Red</span></div>
            </div>
            <div class="message-box" id="messageBox">Roll the dice to begin!</div>
            <div class="dice-section">
                <div class="dice-container" id="diceContainer">
                    <div class="dice" id="dice">
                        <div class="face" data-id="1">
                            <div class="point point-middle point-center"></div>
                        </div>
                        <div class="face" data-id="2">
                            <div class="point point-top point-right"></div>
                            <div class="point point-bottom point-left"></div>
                        </div>
                        <div class="face" data-id="6">
                            <div class="point point-top point-right"></div>
                            <div class="point point-top point-left"></div>
                            <div class="point point-middle point-right"></div>
                            <div class="point point-middle point-left"></div>
                            <div class="point point-bottom point-right"></div>
                            <div class="point point-bottom point-left"></div>
                        </div>
                        <div class="face" data-id="5">
                            <div class="point point-top point-right"></div>
                            <div class="point point-top point-left"></div>
                            <div class="point point-middle point-center"></div>
                            <div class="point point-bottom point-right"></div>
                            <div class="point point-bottom point-left"></div>
                        </div>
                        <div class="face" data-id="3">
                            <div class="point point-top point-right"></div>
                            <div class="point point-middle point-center"></div>
                            <div class="point point-bottom point-left"></div>
                        </div>
                        <div class="face" data-id="4">
                            <div class="point point-top point-right"></div>
                            <div class="point point-top point-left"></div>
                            <div class="point point-bottom point-right"></div>
                            <div class="point point-bottom point-left"></div>
                        </div>
                    </div>
                </div>
                <button class="roll-btn" id="rollBtn"><i class="fas fa-dice"></i> Roll Dice</button>
            </div>
            <div class="scoreboard">
                <h4>Scoreboard</h4>
                <div class="score-grid" id="scoreGrid"></div>
            </div>
            <div class="action-buttons">
                <button class="action-btn" id="rulesBtn"><i class="fas fa-question-circle"></i> Rules</button>
                <button class="action-btn" id="newGameBtn"><i class="fas fa-redo"></i> New Game</button>
            </div>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal-overlay" id="rulesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-book"></i> Game Rules</h3>
                <button class="modal-close" id="closeRules"><i class="fas fa-times"></i></button>
            </div>
            <div class="rule-item">
                <div class="rule-number">1</div>
                <div class="rule-text"><strong>Objective:</strong> Move all 4 of your tokens from the base to the center
                    home triangle.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">2</div>
                <div class="rule-text"><strong>Starting:</strong> Roll a 6 to move a token from your base onto the
                    starting cell.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">3</div>
                <div class="rule-text"><strong>Movement:</strong> Move your tokens clockwise around the board equal to
                    the dice value.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">4</div>
                <div class="rule-text"><strong>Rolling 6:</strong> When you roll a 6, you get an extra turn after
                    moving.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">5</div>
                <div class="rule-text"><strong>Capture:</strong> Land on an opponent's token to send it back to their
                    base.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">6</div>
                <div class="rule-text"><strong>Safe Zones:</strong> Tokens on star cells or colored starting cells
                    cannot be captured.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">7</div>
                <div class="rule-text"><strong>Home Entry:</strong> Enter the final path leading to home after
                    completing the track.</div>
            </div>
            <div class="rule-item">
                <div class="rule-number">8</div>
                <div class="rule-text"><strong>Winning:</strong> The first player to get all 4 tokens home wins the
                    game!</div>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="win-modal" id="winModal">
        <div class="win-content">
            <div class="win-icon"><i class="fas fa-crown" id="winIcon"></i></div>
            <h2 class="win-title" id="winTitle">Victory!</h2>
            <p class="win-player" id="winPlayer">Red Wins!</p>
            <button class="win-btn" id="playAgainBtn"><i class="fas fa-redo"></i> Play Again</button>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-question-circle"></i> Help & Controls</h3>
                <button class="modal-close" id="closeHelp"><i class="fas fa-times"></i></button>
            </div>
            <div class="help-section">
                <h4><i class="fas fa-gamepad"></i> 3D Controls</h4>
                <div class="help-item">
                    <i class="fas fa-expand"></i>
                    <span><strong>Fullscreen:</strong> Toggle fullscreen mode</span>
                </div>
                <div class="help-item">
                    <i class="fas fa-lock"></i>
                    <span><strong>Lock/Unlock:</strong> Lock or unlock board rotation</span>
                </div>
                <div class="help-item">
                    <i class="fas fa-camera"></i>
                    <span><strong>Camera:</strong> Toggle top-down view</span>
                </div>
                <div class="help-item">
                    <i class="fas fa-plus"></i> / <i class="fas fa-minus"></i>
                    <span><strong>Zoom:</strong> Zoom in or out on the board</span>
                </div>
                <div class="help-item">
                    <i class="fas fa-music"></i>
                    <span><strong>Music:</strong> Toggle background music</span>
                </div>
            </div>
            <div class="help-section">
                <h4><i class="fas fa-hand-pointer"></i> Board Interaction</h4>
                <div class="help-item">
                    <i class="fas fa-mouse"></i>
                    <span><strong>Drag:</strong> Click and drag to rotate the board</span>
                </div>
                <div class="help-item">
                    <i class="fas fa-search-plus"></i>
                    <span><strong>Scroll:</strong> Use mouse wheel to zoom</span>
                </div>
                <div class="help-item">
                    <i class="fas fa-chess-pawn"></i>
                    <span><strong>Click Token:</strong> Select a token to move when highlighted</span>
                </div>
            </div>
            <div class="help-section">
                <h4><i class="fas fa-star"></i> Tips</h4>
                <div class="help-item">
                    <span>• Roll a 6 to bring a token out of home</span>
                </div>
                <div class="help-item">
                    <span>• Landing on an opponent sends them back home</span>
                </div>
                <div class="help-item">
                    <span>• Star cells are safe zones</span>
                </div>
                <div class="help-item">
                    <span>• Rolling 6 gives you an extra turn</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Confetti Canvas -->
    <canvas id="confettiCanvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============ GAME CONSTANTS ============
        const COLORS = {
            red: 0xea4330, redDark: 0xa32011, redLight: 0xd22915,
            green: 0x34a853, greenDark: 0x1c5a2d, greenLight: 0x288140,
            blue: 0x4285f4, blueDark: 0x0b51c5, blueLight: 0x1266f1,
            yellow: 0xfbbc05, yellowDark: 0x987102, yellowLight: 0xca9703,
            white: 0xffffff, gray: 0xaaaaaa, border: 0x666666
        };
        const BOARD_SIZE = 15, CELL_SIZE = 40, BOARD_TOTAL = 600, BASE_SIZE = 240;
        const BOARD_THICKNESS = 8, TOKEN_RADIUS = 14, TOKEN_HEIGHT = 8;

        // Player paths - movement around the board
        const PLAYER_PATHS = {
            red: [[1, 6], [2, 6], [3, 6], [4, 6], [5, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [9, 6], [10, 6], [11, 6], [12, 6], [13, 6], [14, 6], [14, 7], [14, 8], [13, 8], [12, 8], [11, 8], [10, 8], [9, 8], [8, 9], [8, 10], [8, 11], [8, 12], [8, 13], [8, 14], [7, 14], [6, 14], [6, 13], [6, 12], [6, 11], [6, 10], [6, 9], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [0, 7]],
            green: [[8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [9, 6], [10, 6], [11, 6], [12, 6], [13, 6], [14, 6], [14, 7], [14, 8], [13, 8], [12, 8], [11, 8], [10, 8], [9, 8], [8, 9], [8, 10], [8, 11], [8, 12], [8, 13], [8, 14], [7, 14], [6, 14], [6, 13], [6, 12], [6, 11], [6, 10], [6, 9], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [0, 7], [0, 6], [1, 6], [2, 6], [3, 6], [4, 6], [5, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0]],
            yellow: [[13, 8], [12, 8], [11, 8], [10, 8], [9, 8], [8, 9], [8, 10], [8, 11], [8, 12], [8, 13], [8, 14], [7, 14], [6, 14], [6, 13], [6, 12], [6, 11], [6, 10], [6, 9], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [0, 7], [0, 6], [1, 6], [2, 6], [3, 6], [4, 6], [5, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [9, 6], [10, 6], [11, 6], [12, 6], [13, 6], [14, 6], [14, 7]],
            blue: [[6, 13], [6, 12], [6, 11], [6, 10], [6, 9], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [0, 7], [0, 6], [1, 6], [2, 6], [3, 6], [4, 6], [5, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [9, 6], [10, 6], [11, 6], [12, 6], [13, 6], [14, 6], [14, 7], [14, 8], [13, 8], [12, 8], [11, 8], [10, 8], [9, 8], [8, 9], [8, 10], [8, 11], [8, 12], [8, 13], [8, 14], [7, 14]]
        };
        const FINAL_PATHS = {
            red: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]],
            green: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6]],
            yellow: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [8, 7]],
            blue: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8]]
        };
        const HOME_POSITIONS = {
            red: [[1.5, 1.5], [1.5, 3.5], [3.5, 1.5], [3.5, 3.5]],
            green: [[10.5, 1.5], [10.5, 3.5], [12.5, 1.5], [12.5, 3.5]],
            yellow: [[10.5, 10.5], [10.5, 12.5], [12.5, 10.5], [12.5, 12.5]],
            blue: [[1.5, 10.5], [1.5, 12.5], [3.5, 10.5], [3.5, 12.5]]
        };
        // Positions within each player's home triangle at center
        // Red's triangle: between x=6 and x=7, centered on y=7
        // Green's triangle: between y=6 and y=7, centered on x=7
        // Yellow's triangle: between x=7 and x=8, centered on y=7
        // Blue's triangle: between y=7 and y=8, centered on x=7
        const HOME_TRIANGLE_POSITIONS = {
            red: [[5.8, 6.5], [5.8, 7.5], [6.2, 6.75], [6.2, 7.25]],
            green: [[6.5, 5.8], [7.5, 5.8], [6.75, 6.2], [7.25, 6.2]],
            yellow: [[8.2, 6.5], [8.2, 7.5], [7.8, 6.75], [7.8, 7.25]],
            blue: [[6.5, 8.2], [7.5, 8.2], [6.75, 7.8], [7.25, 7.8]]
        };
        const SAFE_CELLS = [0, 8, 13, 21, 26, 34, 39, 47]; // Safe spots on main track
        const START_CELLS = { red: 0, green: 13, yellow: 26, blue: 39 };

        // ============ DOM ELEMENTS ============
        const menuOverlay = document.getElementById('menuOverlay');
        const colorSelection = document.getElementById('colorSelection');
        const colorPlayerLabel = document.getElementById('colorPlayerLabel');
        const colorGrid = document.getElementById('colorGrid');
        const confirmColors = document.getElementById('confirmColors');
        const gameContainer = document.getElementById('gameContainer');
        const boardContainer = document.getElementById('board-container');
        const currentPlayerEl = document.getElementById('currentPlayer');
        const messageBox = document.getElementById('messageBox');
        const diceEl = document.getElementById('dice');
        const rollBtn = document.getElementById('rollBtn');
        const scoreGrid = document.getElementById('scoreGrid');
        const rulesModal = document.getElementById('rulesModal');
        const winModal = document.getElementById('winModal');
        const winPlayer = document.getElementById('winPlayer');

        // ============ GAME STATE ============
        let gameMode = null, playerCount = 0, players = [], currentPlayerIndex = 0;
        let tokens = {}, tokenMeshes = {}, lastRoll = 0, isRolling = false, gameActive = false;
        let selectedColors = [], colorSelectingPlayer = 0, aiPlayers = [];
        let scene, camera, renderer, controls, boardGroup, raycaster, mouse;

        // ============ MENU LOGIC ============
        document.querySelectorAll('.mode-card').forEach(card => {
            card.querySelectorAll('.player-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    card.querySelectorAll('.player-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    card.querySelector('.start-btn').classList.add('active');
                });
            });
            card.querySelector('.start-btn').addEventListener('click', e => {
                e.stopPropagation();
                const mode = e.target.closest('.start-btn').dataset.mode;
                const selectedBtn = card.querySelector('.player-btn.selected');
                if (!selectedBtn) return;
                gameMode = mode;
                playerCount = parseInt(selectedBtn.dataset.players);
                startColorSelection();
            });
        });

        function startColorSelection() {
            menuOverlay.classList.add('hidden');
            colorSelection.classList.add('active');
            selectedColors = [];
            colorSelectingPlayer = 0;
            updateColorSelectionUI();
        }

        function closeColorSelection() {
            colorSelection.classList.remove('active');
            menuOverlay.classList.remove('hidden');
            // Reset any selected player buttons
            document.querySelectorAll('.player-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.start-btn').forEach(b => b.classList.remove('active'));
        }

        // Back button click handler
        document.getElementById('colorBackBtn').addEventListener('click', closeColorSelection);

        // Click outside to close color selection modal
        colorSelection.addEventListener('click', (e) => {
            if (e.target === colorSelection) {
                closeColorSelection();
            }
        });

        function updateColorSelectionUI() {
            const humanPlayers = gameMode === 'vscomputer' ? 1 : playerCount;
            if (colorSelectingPlayer < humanPlayers) {
                colorPlayerLabel.textContent = `Player ${colorSelectingPlayer + 1}, select your color:`;
                confirmColors.textContent = colorSelectingPlayer < humanPlayers - 1 ? 'Next Player' : 'Start Game';
            }
            colorGrid.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected', 'disabled');
                if (selectedColors.includes(opt.dataset.color)) opt.classList.add('disabled');
            });
            confirmColors.disabled = true;
        }

        colorGrid.addEventListener('click', e => {
            const option = e.target.closest('.color-option');
            if (!option || option.classList.contains('disabled')) return;
            colorGrid.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            option.classList.add('selected');
            confirmColors.disabled = false;
        });

        confirmColors.addEventListener('click', () => {
            const selected = colorGrid.querySelector('.color-option.selected');
            if (!selected) return;
            selectedColors.push(selected.dataset.color);
            colorSelectingPlayer++;
            const humanPlayers = gameMode === 'vscomputer' ? 1 : playerCount;
            if (colorSelectingPlayer >= humanPlayers) {
                assignRemainingColors();
                colorSelection.classList.remove('active');
                initGame();
            } else {
                updateColorSelectionUI();
            }
        });

        function assignRemainingColors() {
            const allColors = ['red', 'green', 'blue', 'yellow'];
            const available = allColors.filter(c => !selectedColors.includes(c));
            while (selectedColors.length < playerCount) {
                const idx = Math.floor(Math.random() * available.length);
                selectedColors.push(available.splice(idx, 1)[0]);
            }
            players = selectedColors.slice(0, playerCount);
            aiPlayers = gameMode === 'vscomputer' ? players.slice(1) : [];
        }

        // ============ SOUND EFFECTS ============
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioContext) initAudio();
            if (audioContext.state === 'suspended') audioContext.resume();

            switch (type) {
                case 'roll':
                    playDiceRollSound();
                    break;
                case 'hop':
                    playHopSound();
                    break;
                case 'capture':
                    playCaptureSound();
                    break;
                case 'win':
                    playWinSound();
                    break;
                case 'safe':
                    playSafeSound();
                    break;
                case 'home':
                    playHomeSound();
                    break;
            }
        }

        function playDiceRollSound() {
            // Sharp clicking sounds like dice on hard surface
            const clicks = [0, 60, 130, 200, 280, 370, 470, 580, 700];

            clicks.forEach((delay, i) => {
                setTimeout(() => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    // High frequency click
                    osc.frequency.value = 1200 + Math.random() * 800;
                    osc.type = 'sine';

                    // Quick attack and decay
                    const vol = 0.12 * (1 - i * 0.08);
                    gain.gain.setValueAtTime(vol, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.03);

                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.03);
                }, delay);
            });
        }

        function playHopSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.frequency.setValueAtTime(400, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.05);
            osc.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.1);
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.1);
        }

        function playCaptureSound() {
            // Dramatic descending tone
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.3);
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.3);
        }

        function playWinSound() {
            // Victory fanfare - ascending notes
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.3);
                }, i * 150);
            });
        }

        function playSafeSound() {
            // Gentle chime for safe zone
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.frequency.setValueAtTime(880, audioContext.currentTime);
            osc.frequency.setValueAtTime(1100, audioContext.currentTime + 0.1);
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.12, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.25);
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.25);
        }

        function playHomeSound() {
            // Triumphant double chime for reaching home
            [0, 120].forEach((delay, i) => {
                setTimeout(() => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.value = i === 0 ? 784 : 1047; // G5 then C6
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.18, audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.3);
                }, delay);
            });
        }

        // ============ BACKGROUND MUSIC ============
        let bgMusicInterval = null;
        let musicEnabled = false;

        function startBackgroundMusic() {
            if (!audioContext || bgMusicInterval) return;

            const melody = [
                { note: 262, dur: 0.3 }, { note: 294, dur: 0.3 }, { note: 330, dur: 0.3 }, { note: 349, dur: 0.3 },
                { note: 392, dur: 0.6 }, { note: 349, dur: 0.3 }, { note: 330, dur: 0.3 },
                { note: 294, dur: 0.6 }, { note: 262, dur: 0.6 },
                { note: 294, dur: 0.3 }, { note: 330, dur: 0.3 }, { note: 349, dur: 0.3 }, { note: 392, dur: 0.3 },
                { note: 440, dur: 0.6 }, { note: 392, dur: 0.3 }, { note: 349, dur: 0.3 },
                { note: 330, dur: 0.6 }, { note: 294, dur: 0.6 }
            ];

            let noteIndex = 0;

            const playNextNote = () => {
                if (!musicEnabled || !audioContext) return;

                const { note, dur } = melody[noteIndex];
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(note, audioContext.currentTime);
                gain.gain.setValueAtTime(0.03, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + dur * 0.9);

                osc.start();
                osc.stop(audioContext.currentTime + dur);

                noteIndex = (noteIndex + 1) % melody.length;

                bgMusicInterval = setTimeout(playNextNote, dur * 1000);
            };

            playNextNote();
        }

        function stopBackgroundMusic() {
            if (bgMusicInterval) {
                clearTimeout(bgMusicInterval);
                bgMusicInterval = null;
            }
        }

        function toggleBackgroundMusic() {
            musicEnabled = !musicEnabled;
            const musicBtn = document.getElementById('musicBtn');

            if (musicEnabled) {
                initAudio();
                startBackgroundMusic();
                musicBtn.innerHTML = '<i class="fas fa-music"></i>';
                musicBtn.classList.remove('music-off');
            } else {
                stopBackgroundMusic();
                musicBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                musicBtn.classList.add('music-off');
            }
        }

        function gridToWorld(gx, gy) {
            const offset = BOARD_TOTAL / 2 - CELL_SIZE / 2;
            return { x: gx * CELL_SIZE - offset, z: gy * CELL_SIZE - offset };
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1628);
            const w = boardContainer.clientWidth, h = boardContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(45, w / h, 1, 2000);
            camera.position.set(0, 650, 550);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(w, h);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            boardContainer.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.2;
            controls.minDistance = 300;
            controls.maxDistance = 1400;
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(200, 400, 200);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.near = 100;
            dirLight.shadow.camera.far = 1000;
            dirLight.shadow.camera.left = dirLight.shadow.camera.bottom = -400;
            dirLight.shadow.camera.right = dirLight.shadow.camera.top = 400;
            scene.add(dirLight);
            boardGroup = new THREE.Group();
            scene.add(boardGroup);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onBoardClick);
        }

        function onWindowResize() {
            const w = boardContainer.clientWidth, h = boardContainer.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);

            // Automatically adjust camera distance for smaller screens
            adjustCameraForScreenSize();
        }

        function adjustCameraForScreenSize() {
            if (!camera || !controls) return;
            const screenWidth = window.innerWidth;

            // Calculate appropriate camera distance based on screen width
            // On mobile (< 600px), zoom out more; on larger screens, stay closer
            let targetDistance;
            if (screenWidth < 480) {
                targetDistance = 1200; // Very small screens - max zoom out
            } else if (screenWidth < 600) {
                targetDistance = 1000; // Small mobile screens
            } else if (screenWidth < 768) {
                targetDistance = 850; // Tablets portrait
            } else if (screenWidth < 1024) {
                targetDistance = 750; // Tablets landscape
            } else {
                targetDistance = 850; // Desktop
            }

            // Update camera position
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.negate();
            camera.position.copy(controls.target).add(direction.multiplyScalar(targetDistance));
        }

        // ============ ZOOM CONTROLS ============
        const ZOOM_STEP = 50;
        const MIN_ZOOM = 300;
        const MAX_ZOOM = 1400;

        function zoomIn() {
            if (!controls) return;
            const currentDistance = controls.getDistance();
            const newDistance = Math.max(MIN_ZOOM, currentDistance - ZOOM_STEP);
            smoothZoom(newDistance);
        }

        function zoomOut() {
            if (!controls) return;
            const currentDistance = controls.getDistance();
            const newDistance = Math.min(MAX_ZOOM, currentDistance + ZOOM_STEP);
            smoothZoom(newDistance);
        }

        function smoothZoom(targetDistance) {
            const startDistance = controls.getDistance();
            const duration = 200;
            const startTime = Date.now();

            function animateZoom() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easeT = 1 - Math.pow(1 - t, 3);
                const currentDistance = startDistance + (targetDistance - startDistance) * easeT;

                // Move camera along its look direction
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.negate();
                camera.position.copy(controls.target).add(direction.multiplyScalar(currentDistance));

                if (t < 1) {
                    requestAnimationFrame(animateZoom);
                }
            }
            animateZoom();
        }

        // Zoom button event listeners
        document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
        document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);

        // ============ TOP VIEW TOGGLE ============
        let isTopView = false;
        const DEFAULT_CAMERA_TARGET = new THREE.Vector3(0, 0, 0);

        // Get the default camera position adjusted for screen size
        function getDefaultCameraPosition() {
            const screenWidth = window.innerWidth;
            let distance;
            if (screenWidth < 480) {
                distance = 1200;
            } else if (screenWidth < 600) {
                distance = 1000;
            } else if (screenWidth < 768) {
                distance = 850;
            } else if (screenWidth < 1024) {
                distance = 750;
            } else {
                distance = 850;
            }
            // Original camera was at (0, 650, 550), which is about 852 units from origin
            // Scale the original position to match the target distance
            const originalDistance = Math.sqrt(650 * 650 + 550 * 550);
            const scale = distance / originalDistance;
            return new THREE.Vector3(0, 650 * scale, 550 * scale);
        }

        function toggleTopView() {
            const topViewBtn = document.getElementById('topViewBtn');

            if (!isTopView) {
                // Animate to top view (directly above the board)
                animateCameraTo(
                    new THREE.Vector3(0, 900, 0),  // Position directly above
                    new THREE.Vector3(0, 0, 0),    // Looking at center
                    500
                );

                topViewBtn.classList.add('active');
                isTopView = true;
            } else {
                // Animate directly to the screen-size-adjusted default position
                animateCameraTo(
                    getDefaultCameraPosition(),
                    DEFAULT_CAMERA_TARGET.clone(),
                    500
                );

                topViewBtn.classList.remove('active');
                isTopView = false;
            }
        }

        function animateCameraTo(targetPosition, targetLookAt, duration, onComplete) {
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easeT = 1 - Math.pow(1 - t, 3); // Ease out cubic

                // Interpolate position
                camera.position.lerpVectors(startPosition, targetPosition, easeT);

                // Interpolate target
                controls.target.lerpVectors(startTarget, targetLookAt, easeT);

                camera.lookAt(controls.target);
                controls.update();

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else if (onComplete) {
                    onComplete();
                }
            }
            animate();
        }

        document.getElementById('topViewBtn').addEventListener('click', toggleTopView);

        function buildBoard() {
            // Main board
            const boardGeo = new THREE.BoxGeometry(BOARD_TOTAL, BOARD_THICKNESS, BOARD_TOTAL);
            const boardMat = new THREE.MeshStandardMaterial({ color: COLORS.white, polygonOffset: true, polygonOffsetFactor: 2, polygonOffsetUnits: 2 });
            const board = new THREE.Mesh(boardGeo, boardMat);
            board.position.y = -BOARD_THICKNESS / 2 - 2;
            board.receiveShadow = true;
            boardGroup.add(board);
            // Bases
            createBase(0, 0, COLORS.red, 'red');
            createBase(9, 0, COLORS.green, 'green');
            createBase(0, 9, COLORS.blue, 'blue');
            createBase(9, 9, COLORS.yellow, 'yellow');
            // Race cells
            createRaceCells();
            // Final paths
            createFinalPaths();
            // Center home
            createCenterHome();
        }

        // Store base glow indicators for each player
        const baseGlowIndicators = {};

        function createBase(gx, gy, color, playerColorName) {
            const group = new THREE.Group();
            const outerGeo = new THREE.BoxGeometry(BASE_SIZE, 0.5, BASE_SIZE);
            const outerMat = new THREE.MeshStandardMaterial({ color });
            const outer = new THREE.Mesh(outerGeo, outerMat);
            outer.position.y = 0.25;
            outer.receiveShadow = true;
            group.add(outer);
            const innerSize = BASE_SIZE - 80;
            const innerGeo = new THREE.BoxGeometry(innerSize, 0.6, innerSize);
            const innerMat = new THREE.MeshStandardMaterial({ color: COLORS.white });
            const inner = new THREE.Mesh(innerGeo, innerMat);
            inner.position.y = 0.55;
            inner.receiveShadow = true;
            group.add(inner);

            // Create glowing square outline inside the base (thick mesh frame)
            const glowSize = innerSize - 10;  // Larger size, closer to edge
            const frameThickness = 6;
            const frameHeight = 3;
            const glowGroup = new THREE.Group();
            glowGroup.name = 'baseGlow';

            // Create 4 sides of the frame
            const frameMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0
            });

            // Top and bottom bars
            const hBarGeo = new THREE.BoxGeometry(glowSize + frameThickness, frameHeight, frameThickness);
            const topBar = new THREE.Mesh(hBarGeo, frameMat);
            topBar.position.set(0, 0, -glowSize / 2);
            glowGroup.add(topBar);

            const bottomBar = new THREE.Mesh(hBarGeo, frameMat.clone());
            bottomBar.position.set(0, 0, glowSize / 2);
            glowGroup.add(bottomBar);

            // Left and right bars
            const vBarGeo = new THREE.BoxGeometry(frameThickness, frameHeight, glowSize + frameThickness);
            const leftBar = new THREE.Mesh(vBarGeo, frameMat.clone());
            leftBar.position.set(-glowSize / 2, 0, 0);
            glowGroup.add(leftBar);

            const rightBar = new THREE.Mesh(vBarGeo, frameMat.clone());
            rightBar.position.set(glowSize / 2, 0, 0);
            glowGroup.add(rightBar);

            glowGroup.position.y = 0.8;
            group.add(glowGroup);

            // Store reference for animation
            if (playerColorName) {
                baseGlowIndicators[playerColorName] = glowGroup;
            }

            const pos = gridToWorld(gx + 2.5, gy + 2.5);
            group.position.set(pos.x, 0.1, pos.z);
            boardGroup.add(group);
        }

        // Base glow animation
        let baseGlowAnimationId = null;
        let currentGlowPlayer = null;

        function startBaseGlow(playerColor) {
            // Stop previous animation
            stopBaseGlow();

            currentGlowPlayer = playerColor;
            let glowTime = 0;

            function animateGlow() {
                if (!currentGlowPlayer || !baseGlowIndicators[currentGlowPlayer]) return;

                glowTime += 0.05;
                const opacity = (Math.sin(glowTime * 2) + 1) / 2;
                const finalOpacity = 0.5 + opacity * 0.5;

                // Update opacity for all children in the glow group
                baseGlowIndicators[currentGlowPlayer].children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = finalOpacity;
                    }
                });

                baseGlowAnimationId = requestAnimationFrame(animateGlow);
            }

            animateGlow();
        }

        function stopBaseGlow() {
            if (baseGlowAnimationId) {
                cancelAnimationFrame(baseGlowAnimationId);
                baseGlowAnimationId = null;
            }

            // Reset all base glows to invisible
            Object.values(baseGlowIndicators).forEach(glowGroup => {
                if (glowGroup && glowGroup.children) {
                    glowGroup.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = 0;
                        }
                    });
                }
            });

            currentGlowPlayer = null;
        }

        const raceCellPositions = [
            [1, 6], [2, 6], [3, 6], [4, 6], [5, 6], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5],
            [9, 6], [10, 6], [11, 6], [12, 6], [13, 6], [14, 6], [14, 7], [14, 8], [13, 8], [12, 8], [11, 8], [10, 8], [9, 8], [8, 9], [8, 10], [8, 11],
            [8, 12], [8, 13], [8, 14], [7, 14], [6, 14], [6, 13], [6, 12], [6, 11], [6, 10], [6, 9], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [0, 7], [0, 6]
        ];
        const startCells = { 1: COLORS.red, 14: COLORS.green, 27: COLORS.yellow, 40: COLORS.blue };
        const safeZones = [1, 9, 14, 22, 27, 35, 40, 48];
        const safeZoneColors = { 1: 0xef6d5e, 9: 0xcccccc, 14: 0x48c76a, 22: 0xcccccc, 27: 0xfcc937, 35: 0xcccccc, 40: 0x72a4f7, 48: 0xcccccc };

        function createRaceCells() {
            raceCellPositions.forEach((pos, idx) => {
                const cellNum = idx + 1;
                const wp = gridToWorld(pos[0], pos[1]);
                let cellColor = COLORS.white;
                if (startCells[cellNum]) cellColor = startCells[cellNum];
                const cellGeo = new THREE.BoxGeometry(CELL_SIZE - 1, 1, CELL_SIZE - 1);
                const cellMat = new THREE.MeshStandardMaterial({ color: cellColor });
                const cell = new THREE.Mesh(cellGeo, cellMat);
                cell.position.set(wp.x, 0.6, wp.z);
                cell.receiveShadow = true;
                boardGroup.add(cell);
                const edges = new THREE.EdgesGeometry(cellGeo);
                const lineMat = new THREE.LineBasicMaterial({ color: COLORS.border });
                const wire = new THREE.LineSegments(edges, lineMat);
                wire.position.set(wp.x, 0.6, wp.z);
                boardGroup.add(wire);
                if (safeZones.includes(cellNum)) createStar(wp.x, wp.z, safeZoneColors[cellNum]);
            });
        }

        function createStar(x, z, color) {
            const shape = new THREE.Shape();
            const outerR = 12, innerR = 5, points = 5;
            for (let i = 0; i < points * 2; i++) {
                const r = i % 2 === 0 ? outerR : innerR;
                const angle = (i * Math.PI) / points - Math.PI / 2;
                const px = Math.cos(angle) * r, py = Math.sin(angle) * r;
                i === 0 ? shape.moveTo(px, py) : shape.lineTo(px, py);
            }
            shape.closePath();
            const geo = new THREE.ShapeGeometry(shape);
            const mat = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide });
            const star = new THREE.Mesh(geo, mat);
            star.rotation.x = -Math.PI / 2;
            star.position.set(x, 1.2, z);
            boardGroup.add(star);
        }

        function createFinalPaths() {
            const paths = [
                { cells: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7]], color: COLORS.red },
                { cells: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5]], color: COLORS.green },
                { cells: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7]], color: COLORS.yellow },
                { cells: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9]], color: COLORS.blue }
            ];
            paths.forEach(p => {
                p.cells.forEach(c => {
                    const wp = gridToWorld(c[0], c[1]);
                    const geo = new THREE.BoxGeometry(CELL_SIZE - 1, 1, CELL_SIZE - 1);
                    const mat = new THREE.MeshStandardMaterial({ color: p.color });
                    const cell = new THREE.Mesh(geo, mat);
                    cell.position.set(wp.x, 0.6, wp.z);
                    cell.receiveShadow = true;
                    boardGroup.add(cell);
                    const edges = new THREE.EdgesGeometry(geo);
                    const lineMat = new THREE.LineBasicMaterial({ color: COLORS.border });
                    const wire = new THREE.LineSegments(edges, lineMat);
                    wire.position.set(wp.x, 0.6, wp.z);
                    boardGroup.add(wire);
                });
            });
        }

        function createCenterHome() {
            const centerSize = 3 * CELL_SIZE, halfSize = centerSize / 2;
            const triangles = [
                { color: COLORS.red, rotation: 0 },
                { color: COLORS.green, rotation: -Math.PI / 2 },
                { color: COLORS.yellow, rotation: Math.PI },
                { color: COLORS.blue, rotation: Math.PI / 2 }
            ];
            triangles.forEach(({ color, rotation }) => {
                const shape = new THREE.Shape();
                shape.moveTo(-halfSize, -halfSize);
                shape.lineTo(0, 0);
                shape.lineTo(-halfSize, halfSize);
                shape.lineTo(-halfSize, -halfSize);
                const geo = new THREE.ExtrudeGeometry(shape, { depth: 1, bevelEnabled: false });
                const mat = new THREE.MeshStandardMaterial({ color });
                const tri = new THREE.Mesh(geo, mat);
                tri.rotation.x = -Math.PI / 2;
                tri.rotation.z = rotation;
                tri.position.y = 0.1;
                boardGroup.add(tri);
            });
        }

        function createToken(color, colorLight) {
            const group = new THREE.Group();
            const outerGeo = new THREE.CylinderGeometry(TOKEN_RADIUS, TOKEN_RADIUS, TOKEN_HEIGHT, 32);
            const outerMat = new THREE.MeshStandardMaterial({ color });
            const outer = new THREE.Mesh(outerGeo, outerMat);
            outer.castShadow = true;
            group.add(outer);
            const innerGeo = new THREE.CylinderGeometry(TOKEN_RADIUS - 3, TOKEN_RADIUS - 3, TOKEN_HEIGHT + 0.5, 32);
            const innerMat = new THREE.MeshStandardMaterial({ color: colorLight });
            const inner = new THREE.Mesh(innerGeo, innerMat);
            inner.position.y = 0.25;
            inner.castShadow = true;
            group.add(inner);
            group.position.y = TOKEN_HEIGHT / 2 + 0.8;
            return group;
        }

        function createPlayerTokens() {
            const colorMap = {
                red: { dark: COLORS.redDark, light: COLORS.redLight },
                green: { dark: COLORS.greenDark, light: COLORS.greenLight },
                blue: { dark: COLORS.blueDark, light: COLORS.blueLight },
                yellow: { dark: COLORS.yellowDark, light: COLORS.yellowLight }
            };
            players.forEach(player => {
                tokens[player] = [-1, -1, -1, -1]; // -1 = at home
                tokenMeshes[player] = [];
                for (let i = 0; i < 4; i++) {
                    const token = createToken(colorMap[player].dark, colorMap[player].light);
                    const hp = HOME_POSITIONS[player][i];
                    const wp = gridToWorld(hp[0], hp[1]);
                    token.position.set(wp.x, token.position.y, wp.z);
                    token.userData = { player, index: i };
                    boardGroup.add(token);
                    tokenMeshes[player].push(token);
                }
            });
        }

        // ============ GAME LOGIC ============
        function initGame() {
            gameContainer.classList.add('active');
            initThreeJS();
            buildBoard();
            adjustCameraForScreenSize(); // Set initial camera position based on screen size
            createPlayerTokens();

            // Rotate board for optimal 2-player view
            rotateBoardForPlayers();

            currentPlayerIndex = 0;
            gameActive = true;
            updateUI();
            updateScoreboard();
            animate();

            // Start background music when game begins
            initAudio();
            if (musicEnabled) startBackgroundMusic();

            if (aiPlayers.includes(players[currentPlayerIndex])) {
                setTimeout(aiTurn, 1000);
            }
        }

        // Rotate the board so 2-player games have both players' bases facing the camera
        function rotateBoardForPlayers() {
            if (playerCount !== 2) return;

            const [p1, p2] = players;

            // Board color positions:
            // Red: top-left, Green: top-right
            // Blue: bottom-left, Yellow: bottom-right
            // Camera faces "south" (positive Z), so bottom colors are already front

            // Same row pairs
            const topRow = ['red', 'green'];
            const bottomRow = ['blue', 'yellow'];
            // Same column pairs  
            const leftColumn = ['red', 'blue'];
            const rightColumn = ['green', 'yellow'];

            let rotation = 0;

            // Check if both players are on same row
            if (topRow.includes(p1) && topRow.includes(p2)) {
                // Both on top row - rotate 180° to bring top to front
                rotation = Math.PI;
            } else if (bottomRow.includes(p1) && bottomRow.includes(p2)) {
                // Both on bottom row - already at front, no rotation needed
                rotation = 0;
            }
            // Check if both players are on same column
            else if (leftColumn.includes(p1) && leftColumn.includes(p2)) {
                // Both on left column - rotate 90° clockwise
                rotation = Math.PI / 2;
            } else if (rightColumn.includes(p1) && rightColumn.includes(p2)) {
                // Both on right column - rotate 90° counter-clockwise
                rotation = -Math.PI / 2;
            }
            // If players are diagonal, no rotation needed

            if (rotation !== 0) {
                boardGroup.rotation.y = rotation;
            }
        }

        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function updateUI() {
            const player = players[currentPlayerIndex];
            const isAI = aiPlayers.includes(player);
            const colorVar = `var(--${player})`;

            // Determine display name based on game mode
            let displayName;
            if (gameMode === 'vscomputer') {
                if (isAI) {
                    const aiIndex = aiPlayers.indexOf(player);
                    displayName = players.length > 2 ? `Bot ${aiIndex + 1}` : 'Bot';
                } else {
                    displayName = 'You';
                }
            } else {
                displayName = `Player ${currentPlayerIndex + 1}`;
            }

            currentPlayerEl.innerHTML = `<i class="fas ${isAI ? 'fa-robot' : 'fa-user'}"></i> <span>${displayName}</span>`;
            currentPlayerEl.style.color = colorVar;
            document.documentElement.style.setProperty('--current-color', colorVar);
            rollBtn.disabled = isRolling || isAI;

            // Activate base glow for current player
            startBaseGlow(player);
        }

        function updateScoreboard() {
            scoreGrid.innerHTML = '';
            let botCount = 0;
            players.forEach((player, idx) => {
                const score = tokens[player].filter(t => t === 56).length; // 56 = home
                const isAI = aiPlayers.includes(player);
                const isCurrent = idx === currentPlayerIndex;

                // Determine display name based on game mode
                let displayName;
                if (gameMode === 'vscomputer') {
                    if (isAI) {
                        botCount++;
                        displayName = players.length > 2 ? `Bot ${botCount}` : 'Bot';
                    } else {
                        displayName = 'You';
                    }
                } else {
                    displayName = `Player ${idx + 1}`;
                }

                scoreGrid.innerHTML += `
                    <div class="score-item ${isCurrent ? 'current' : ''}">
                        <div class="score-dot ${player}"></div>
                        <span class="score-name">${displayName}</span>
                        ${isAI ? '<i class="fas fa-robot"></i>' : ''}
                        <span class="score-value">${score}/4</span>
                    </div>
                `;
            });
        }

        function setMessage(msg) { messageBox.textContent = msg; }

        // ============ DICE ============
        let diceAngleX = 0, diceAngleY = 0;
        const diceContainer = document.getElementById('diceContainer');
        const ROLL_MAX = 8;

        rollBtn.addEventListener('click', () => {
            if (isRolling || !gameActive || rollBtn.disabled) return;
            rollDice();
        });

        diceContainer.addEventListener('click', () => {
            if (isRolling || !gameActive || rollBtn.disabled || aiPlayers.includes(players[currentPlayerIndex])) return;
            rollDice();
        });

        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }

        function rollDice() {
            if (isRolling) return;
            isRolling = true;
            rollBtn.disabled = true;
            playSound('roll');

            const xTurn = 4 + getRandomInt(ROLL_MAX);
            const yTurn = 4 + getRandomInt(ROLL_MAX);
            const delay = Math.max(xTurn, yTurn) * 200;

            diceAngleX += 90 * xTurn;
            diceAngleY += 90 * yTurn;

            // Balance the results
            if (diceAngleX % 180) {
                if (getRandomInt(3) > 1) diceAngleX += 90;
            }

            diceEl.style.transform = `rotateX(${diceAngleX}deg) rotateY(${diceAngleY}deg)`;
            diceEl.style.transitionDuration = delay + 'ms';

            // Calculate result based on final orientation
            let result = 1;
            const x = diceAngleX % 360;
            const y = diceAngleY % 360;

            if (x === 0 || x === 180) {
                switch ((x + y) % 360) {
                    case 0: result = 1; break;
                    case 90: result = 5; break;
                    case 180: result = 6; break;
                    case 270: result = 2; break;
                }
            } else if (x === 90) {
                result = 4;
            } else if (x === 270) {
                result = 3;
            }

            setTimeout(() => {
                lastRoll = result;
                isRolling = false;
                setMessage(`Rolled a ${result}!`);
                handleRoll(result);
            }, delay + 100);
        }

        function handleRoll(value) {
            const player = players[currentPlayerIndex];
            const validMoves = getValidMoves(player, value);
            if (validMoves.length === 0) {
                setMessage(`Rolled ${value}. No valid moves!`);
                setTimeout(nextTurn, 1500);
            } else if (validMoves.length === 1) {
                setTimeout(() => moveToken(player, validMoves[0], value), 500);
            } else {
                setMessage(`Rolled ${value}. Select a token to move.`);
                highlightTokens(player, validMoves);
                rollBtn.disabled = true;
            }
        }

        function getValidMoves(player, value) {
            const moves = [];
            for (let i = 0; i < 4; i++) {
                const pos = tokens[player][i];
                if (pos === -1) {
                    if (value === 6) moves.push(i); // Can leave home
                } else if (pos < 51) {
                    if (pos + value <= 56) moves.push(i); // Normal move or entering final path
                } else if (pos >= 51 && pos < 56) {
                    if (pos + value <= 56) moves.push(i); // In final path
                }
            }
            return moves;
        }

        let highlightAnimationId = null;
        let highlightedMeshes = [];

        function highlightTokens(player, validMoves) {
            highlightedMeshes = [];

            // Get player's light color for the ring
            const lightColors = {
                red: 0xff6b6b,
                green: 0x69db7c,
                blue: 0x74c0fc,
                yellow: 0xffd43b
            };
            const ringColor = lightColors[player] || 0xffffff;

            validMoves.forEach(i => {
                const mesh = tokenMeshes[player][i];
                mesh.userData.highlighted = true;
                highlightedMeshes.push(mesh);

                // Create glowing ring indicator
                const ringGeo = new THREE.RingGeometry(TOKEN_RADIUS + 3, TOKEN_RADIUS + 7, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: ringColor,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 1
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 1;
                ring.name = 'highlightRing';
                mesh.add(ring);
            });

            // Start blinking animation
            startHighlightBlink();
        }

        function startHighlightBlink() {
            let blinkTime = 0;
            function blink() {
                blinkTime += 0.05;
                const opacity = (Math.sin(blinkTime * 2) + 1) / 2;

                highlightedMeshes.forEach(mesh => {
                    const ring = mesh.getObjectByName('highlightRing');
                    if (ring) {
                        ring.material.opacity = 0.3 + opacity * 0.7;
                    }
                });

                if (highlightedMeshes.length > 0) {
                    highlightAnimationId = requestAnimationFrame(blink);
                }
            }
            blink();
        }

        function clearHighlights() {
            if (highlightAnimationId) {
                cancelAnimationFrame(highlightAnimationId);
                highlightAnimationId = null;
            }

            players.forEach(p => {
                tokenMeshes[p].forEach(mesh => {
                    mesh.userData.highlighted = false;
                    const ring = mesh.getObjectByName('highlightRing');
                    if (ring) {
                        mesh.remove(ring);
                        ring.geometry.dispose();
                        ring.material.dispose();
                    }
                });
            });
            highlightedMeshes = [];
        }

        function onBoardClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const player = players[currentPlayerIndex];
            const meshes = tokenMeshes[player].filter(m => m.userData.highlighted);
            const intersects = raycaster.intersectObjects(meshes, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.player) obj = obj.parent;
                if (obj.userData.player === player) {
                    clearHighlights();
                    moveToken(player, obj.userData.index, lastRoll);
                }
            }
        }

        function moveToken(player, tokenIndex, steps) {
            const oldPos = tokens[player][tokenIndex];
            let newPos;
            if (oldPos === -1) {
                newPos = 0; // Move to start
            } else {
                newPos = oldPos + steps;
            }
            tokens[player][tokenIndex] = newPos;
            animateTokenMove(player, tokenIndex, oldPos, newPos, () => {
                checkCapture(player, tokenIndex, newPos);
                // Redistribute tokens on both old and new positions
                if (oldPos >= 0) distributeTokensOnCell(oldPos);
                distributeTokensOnCell(newPos);

                // Play sound for safe zone or home entry
                if (newPos === 56) {
                    playSound('home');
                } else if (newPos >= 0 && newPos < 51 && (SAFE_CELLS.includes(newPos) || newPos === START_CELLS[player])) {
                    playSound('safe');
                }

                updateScoreboard();
                if (checkWin(player)) {
                    showWin(player);
                } else if (lastRoll === 6) {
                    setMessage('Rolled 6! Roll again.');
                    rollBtn.disabled = aiPlayers.includes(player);
                    if (aiPlayers.includes(player)) setTimeout(aiTurn, 1000);
                } else {
                    nextTurn();
                }
            });
        }

        function distributeTokensOnCell(pos) {
            // Get grid coordinates for the given position for the current player
            // Then find ALL tokens from ALL players at those grid coordinates

            // First, we need to find the actual grid coordinates
            // We'll check from the perspective of the player who just moved
            const player = players[currentPlayerIndex];
            let targetGridPos;

            if (pos === 56) {
                // Home triangle - each token has its own spot, no redistribution needed
                return;
            } else if (pos >= 51 && pos < 56) {
                targetGridPos = FINAL_PATHS[player][pos - 51];
            } else if (pos >= 0 && pos < 51) {
                targetGridPos = PLAYER_PATHS[player][pos];
            } else {
                return; // Home position, no distribution needed
            }

            // Now find all tokens at this grid position
            const tokensOnCell = [];

            players.forEach(p => {
                tokens[p].forEach((tPos, idx) => {
                    if (tPos < 0) return; // Skip tokens at home

                    let gridPos;
                    if (tPos === 56) {
                        gridPos = [7, 7];
                    } else if (tPos >= 51 && tPos < 56) {
                        gridPos = FINAL_PATHS[p][tPos - 51];
                    } else if (tPos >= 0 && tPos < 51) {
                        gridPos = PLAYER_PATHS[p][tPos];
                    } else {
                        return;
                    }

                    // Check if this token is at the same grid position
                    if (gridPos[0] === targetGridPos[0] && gridPos[1] === targetGridPos[1]) {
                        tokensOnCell.push({ player: p, index: idx, gridPos });
                    }
                });
            });

            // Reposition based on count
            const spacing = 12;
            const count = tokensOnCell.length;

            tokensOnCell.forEach((token, i) => {
                const basePos = gridToWorld(token.gridPos[0], token.gridPos[1]);
                const mesh = tokenMeshes[token.player][token.index];

                let offsetX = 0, offsetZ = 0;

                if (count === 1) {
                    // Single token - center it
                    offsetX = 0;
                    offsetZ = 0;
                } else if (count === 2) {
                    offsetX = (i - 0.5) * spacing;
                } else if (count === 3) {
                    if (i === 0) { offsetX = -spacing * 0.7; offsetZ = -spacing * 0.4; }
                    else if (i === 1) { offsetX = spacing * 0.7; offsetZ = -spacing * 0.4; }
                    else { offsetZ = spacing * 0.6; }
                } else if (count >= 4) {
                    offsetX = (i % 2 === 0 ? -1 : 1) * spacing * 0.5;
                    offsetZ = (Math.floor(i / 2) % 2 === 0 ? -1 : 1) * spacing * 0.5;
                }

                mesh.position.x = basePos.x + offsetX;
                mesh.position.z = basePos.z + offsetZ;
            });
        }

        function getPositionForStep(player, tokenIndex, pos) {
            if (pos === 56) {
                // Home triangle - each token goes to its player's colored triangle
                const htp = HOME_TRIANGLE_POSITIONS[player][tokenIndex];
                return gridToWorld(htp[0], htp[1]);
            } else if (pos >= 51) {
                // Final path
                const fpIdx = pos - 51;
                const fp = FINAL_PATHS[player][fpIdx];
                return gridToWorld(fp[0], fp[1]);
            } else if (pos >= 0) {
                // Main track
                const pp = PLAYER_PATHS[player][pos];
                return gridToWorld(pp[0], pp[1]);
            } else {
                // Home base
                const hp = HOME_POSITIONS[player][tokenIndex];
                return gridToWorld(hp[0], hp[1]);
            }
        }

        function animateTokenMove(player, tokenIndex, oldPos, newPos, callback) {
            const mesh = tokenMeshes[player][tokenIndex];
            const stepDuration = 150; // Time for each step in ms
            const pauseDuration = 50;  // Pause between steps

            // Build list of positions to move through
            const positions = [];

            if (oldPos === -1) {
                // Moving from home to start position
                positions.push(0);
            } else {
                // Moving step by step
                for (let p = oldPos + 1; p <= newPos; p++) {
                    positions.push(p);
                }
            }

            let currentStep = 0;

            function animateStep() {
                if (currentStep >= positions.length) {
                    callback();
                    return;
                }

                playSound('hop');

                const targetWorldPos = getPositionForStep(player, tokenIndex, positions[currentStep]);
                const startPos = mesh.position.clone();
                const endPos = new THREE.Vector3(targetWorldPos.x, mesh.position.y, targetWorldPos.z);
                const startTime = Date.now();

                function stepAnim() {
                    const elapsed = Date.now() - startTime;
                    const t = Math.min(elapsed / stepDuration, 1);
                    // Ease out for snappy movement
                    const easeT = 1 - Math.pow(1 - t, 3);
                    mesh.position.lerpVectors(startPos, endPos, easeT);

                    // Add slight hop effect
                    const hopHeight = 8;
                    const hopProgress = Math.sin(t * Math.PI);
                    mesh.position.y = (TOKEN_HEIGHT / 2 + 0.8) + hopProgress * hopHeight;

                    if (t < 1) {
                        requestAnimationFrame(stepAnim);
                    } else {
                        // Pause briefly then move to next step
                        currentStep++;
                        setTimeout(animateStep, pauseDuration);
                    }
                }
                stepAnim();
            }

            animateStep();
        }

        function checkCapture(player, tokenIndex, pos) {
            if (pos < 0 || pos >= 51) return; // Can't capture in final path or home
            const safeIdx = SAFE_CELLS.includes(pos);
            const startIdx = Object.values(START_CELLS).includes(pos);
            if (safeIdx || startIdx) return; // Safe zone
            const gridPos = PLAYER_PATHS[player][pos];
            players.forEach(other => {
                if (other === player) return;
                for (let i = 0; i < 4; i++) {
                    const oPos = tokens[other][i];
                    if (oPos >= 0 && oPos < 51) {
                        const otherGridPos = PLAYER_PATHS[other][oPos];
                        if (gridPos[0] === otherGridPos[0] && gridPos[1] === otherGridPos[1]) {
                            // Capture!
                            tokens[other][i] = -1;
                            const hp = HOME_POSITIONS[other][i];
                            const wp = gridToWorld(hp[0], hp[1]);
                            tokenMeshes[other][i].position.set(wp.x, tokenMeshes[other][i].position.y, wp.z);
                            setMessage(`${player} captured ${other}'s token!`);
                            playSound('capture');
                        }
                    }
                }
            });
        }

        function checkWin(player) {
            return tokens[player].every(t => t === 56);
        }

        function showWin(player) {
            gameActive = false;
            playSound('win');
            startConfetti(); // Trigger confetti animation

            const winTitle = document.getElementById('winTitle');
            const winIcon = document.getElementById('winIcon');
            const isAI = aiPlayers.includes(player);
            const playerIdx = players.indexOf(player);

            if (gameMode === 'vscomputer') {
                if (isAI) {
                    // Bot won - defeat
                    winTitle.textContent = 'Defeat!';
                    winIcon.className = 'fas fa-sad-tear';
                    const aiIndex = aiPlayers.indexOf(player);
                    const botName = players.length > 2 ? `Bot ${aiIndex + 1}` : 'Bot';
                    winPlayer.textContent = `${botName} Wins!`;
                } else {
                    // Human won - victory
                    winTitle.textContent = 'Victory!';
                    winIcon.className = 'fas fa-crown';
                    winPlayer.textContent = 'You Won!';
                }
            } else {
                // Pass and Play mode
                winTitle.textContent = 'Victory!';
                winIcon.className = 'fas fa-crown';
                winPlayer.textContent = `Player ${playerIdx + 1} Wins!`;
            }

            winPlayer.style.color = `var(--${player})`;
            winModal.classList.add('active');
        }

        // ============ CONFETTI ANIMATION ============
        const confettiCanvas = document.getElementById('confettiCanvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiParticles = [];
        let confettiAnimationId = null;

        function resizeConfettiCanvas() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        resizeConfettiCanvas();
        window.addEventListener('resize', resizeConfettiCanvas);

        class ConfettiParticle {
            constructor() {
                this.reset();
                this.y = Math.random() * -confettiCanvas.height; // Start above screen
            }

            reset() {
                this.x = Math.random() * confettiCanvas.width;
                this.y = -20;
                this.size = Math.random() * 10 + 5;
                this.speedY = Math.random() * 3 + 2;
                this.speedX = Math.random() * 2 - 1;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = Math.random() * 10 - 5;
                this.color = this.getRandomColor();
                this.shape = Math.floor(Math.random() * 3); // 0: rect, 1: circle, 2: triangle
                this.wobble = Math.random() * 10;
                this.wobbleSpeed = Math.random() * 0.1 + 0.05;
            }

            getRandomColor() {
                const colors = [
                    '#ea4330', '#34a853', '#4285f4', '#fbbc05', // Ludo colors
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96c93d', // Vibrant extras
                    '#f9ca24', '#f0932b', '#eb4d4b', '#6ab04c',
                    '#be2edd', '#22a6b3', '#ff9ff3', '#feca57'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.y += this.speedY;
                this.x += this.speedX + Math.sin(this.wobble) * 0.5;
                this.wobble += this.wobbleSpeed;
                this.rotation += this.rotationSpeed;

                // Reset if off screen
                if (this.y > confettiCanvas.height + 20) {
                    this.reset();
                }
            }

            draw() {
                confettiCtx.save();
                confettiCtx.translate(this.x, this.y);
                confettiCtx.rotate((this.rotation * Math.PI) / 180);
                confettiCtx.fillStyle = this.color;

                switch (this.shape) {
                    case 0: // Rectangle
                        confettiCtx.fillRect(-this.size / 2, -this.size / 4, this.size, this.size / 2);
                        break;
                    case 1: // Circle
                        confettiCtx.beginPath();
                        confettiCtx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        confettiCtx.fill();
                        break;
                    case 2: // Triangle
                        confettiCtx.beginPath();
                        confettiCtx.moveTo(0, -this.size / 2);
                        confettiCtx.lineTo(this.size / 2, this.size / 2);
                        confettiCtx.lineTo(-this.size / 2, this.size / 2);
                        confettiCtx.closePath();
                        confettiCtx.fill();
                        break;
                }

                confettiCtx.restore();
            }
        }

        function startConfetti() {
            // Create particles
            confettiParticles = [];
            for (let i = 0; i < 150; i++) {
                confettiParticles.push(new ConfettiParticle());
            }

            // Start animation
            animateConfetti();

            // Stop confetti after 8 seconds
            setTimeout(stopConfetti, 8000);
        }

        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

            confettiParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            confettiAnimationId = requestAnimationFrame(animateConfetti);
        }

        function stopConfetti() {
            if (confettiAnimationId) {
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null;
            }
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            confettiParticles = [];
        }

        function nextTurn() {
            clearHighlights();
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            lastRoll = 0;
            updateUI();
            updateScoreboard();
            setMessage('Roll the dice!');
            if (aiPlayers.includes(players[currentPlayerIndex])) {
                setTimeout(aiTurn, 1000);
            }
        }

        // ============ AI ============
        function aiTurn() {
            if (!gameActive) return;
            setMessage('Computer is thinking...');
            setTimeout(() => {
                rollDice();
            }, 500);
        }

        // Override handleRoll for AI
        const originalHandleRoll = handleRoll;
        handleRoll = function (value) {
            const player = players[currentPlayerIndex];
            if (aiPlayers.includes(player)) {
                const validMoves = getValidMoves(player, value);
                if (validMoves.length === 0) {
                    setMessage(`AI rolled ${value}. No valid moves!`);
                    setTimeout(nextTurn, 1500);
                } else {
                    // Simple AI: prefer captures, then furthest token, then leaving home
                    const bestMove = chooseBestMove(player, value, validMoves);
                    setTimeout(() => moveToken(player, bestMove, value), 800);
                }
            } else {
                originalHandleRoll(value);
            }
        };

        function chooseBestMove(player, value, validMoves) {
            // Priority: capture > enter home > advance furthest > leave base
            let best = validMoves[0];
            let bestScore = -1000;
            validMoves.forEach(i => {
                let score = 0;
                const pos = tokens[player][i];
                const newPos = pos === -1 ? 0 : pos + value;
                // Entering home
                if (newPos === 56) score += 100;
                // Capture potential
                if (newPos >= 0 && newPos < 51) {
                    const gp = PLAYER_PATHS[player][newPos];
                    players.forEach(other => {
                        if (other === player) return;
                        for (let j = 0; j < 4; j++) {
                            const oPos = tokens[other][j];
                            if (oPos >= 0 && oPos < 51) {
                                const ogp = PLAYER_PATHS[other][oPos];
                                if (gp[0] === ogp[0] && gp[1] === ogp[1]) score += 50;
                            }
                        }
                    });
                    // Landing on safe
                    if (SAFE_CELLS.includes(newPos)) score += 10;
                }
                // Advance more = better
                score += newPos;
                // Leaving home
                if (pos === -1) score += 5;
                if (score > bestScore) {
                    bestScore = score;
                    best = i;
                }
            });
            return best;
        }

        // ============ MODALS ============
        document.getElementById('rulesBtn').addEventListener('click', () => rulesModal.classList.add('active'));
        document.getElementById('closeRules').addEventListener('click', () => rulesModal.classList.remove('active'));
        rulesModal.addEventListener('click', e => { if (e.target === rulesModal) rulesModal.classList.remove('active'); });
        document.getElementById('newGameBtn').addEventListener('click', () => location.reload());
        document.getElementById('playAgainBtn').addEventListener('click', () => location.reload());

        // ============ BOARD CONTROLS ============
        let boardLocked = false;
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const lockBoardBtn = document.getElementById('lockBoardBtn');

        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
                fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
            } else {
                document.exitFullscreen();
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            }
        });

        lockBoardBtn.addEventListener('click', () => {
            boardLocked = !boardLocked;
            if (boardLocked) {
                lockBoardBtn.innerHTML = '<i class="fas fa-lock"></i>';
                lockBoardBtn.classList.add('active');
                if (controls) controls.enabled = false;
            } else {
                lockBoardBtn.innerHTML = '<i class="fas fa-lock-open"></i>';
                lockBoardBtn.classList.remove('active');
                if (controls) controls.enabled = true;
            }
        });

        // Music toggle button
        document.getElementById('musicBtn').addEventListener('click', toggleBackgroundMusic);

        // ============ HELP MODAL ============
        const helpModal = document.getElementById('helpModal');
        const menuHelpBtn = document.getElementById('menuHelpBtn');
        const closeHelpBtn = document.getElementById('closeHelp');

        menuHelpBtn.addEventListener('click', () => {
            helpModal.classList.add('active');
        });

        closeHelpBtn.addEventListener('click', () => {
            helpModal.classList.remove('active');
        });

        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.remove('active');
            }
        });
    </script>
</body>

</html>