<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ludo Pro Elite</title>

    <!-- Import Map for modern Three.js (r180+) -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.180.0/three.module.min.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
        }
    }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/25.0.0/tween.umd.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #020202;
            color: white;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            width: calc(100% - 40px);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 10;
        }

        .panel {
            background: rgba(10, 10, 10, 0.95);
            padding: 20px;
            border-radius: 16px;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9);
        }

        .turn-indicator {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 1px;
        }

        .color-dot {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: inline-block;
            box-shadow: 0 0 15px currentColor;
        }

        #dice-btn {
            background: linear-gradient(135deg, #555, #111);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 14px 28px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #dice-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #666, #1a1a1a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.1);
        }

        #dice-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #dice-result {
            margin-top: 15px;
            text-align: center;
            font-size: 2.2rem;
            font-weight: 900;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
        }

        #msg-box {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.98);
            color: #fff;
            padding: 12px 35px;
            border-radius: 40px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            letter-spacing: 1px;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div class="panel">
            <div class="turn-indicator">
                <span id="player-dot" class="color-dot"></span>
                <span id="player-text">RED PLAYER</span>
            </div>
            <button id="dice-btn">Roll Dice</button>
            <div id="dice-result">-</div>
        </div>
        <div class="panel" style="padding: 10px 15px;">
            <div style="font-size: 0.7rem; opacity: 0.6; font-weight: 800; letter-spacing: 3px;">LUDO 3D ELITE</div>
        </div>
    </div>

    <div id="msg-box">SELECT A PIECE</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const COLORS = {
            RED: 0xc1121f,
            BLUE: 0x00308f,
            YELLOW: 0xffb703,
            GREEN: 0x007f5f,
            BOARD_BASE: 0x4e342e, // Mahogany
            WOOD_RIM: 0x1a1a1a,   // Ebony contrast
            TILE_LIGHT: 0xffffff,
            TILE_DARK: 0xfafafa,
            TILE_SIDE: 0x000000    // Black sides for tiles
        };

        const PLAYER_ORDER = ['RED', 'GREEN', 'YELLOW', 'BLUE'];
        const BOARD_SIZE = 15;
        const TILE_HEIGHT = 0.22;

        // Path arrays for each player: 51 main track tiles + 6 home stretch tiles = 57 total
        // Each player enters at index 0 and finishes at index 56 (center)
        const PATHS = {
            RED: [
                // Entry and first leg (going right along z=-1)
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 }, { x: -1, z: -1 },
                // Turn down (going along x=-1)
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                // Corner and cross bottom
                { x: 0, z: -7 }, { x: 1, z: -7 },
                // Going up (along x=1)
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 }, { x: 1, z: -1 },
                // Turn right (going along z=-1 to right edge)
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                // Corner and cross right
                { x: 7, z: 0 }, { x: 7, z: 1 },
                // Going left (along z=1)
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 }, { x: 1, z: 1 },
                // Turn down (going along x=1)
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                // Corner and cross top
                { x: 0, z: 7 }, { x: -1, z: 7 },
                // Going up (along x=-1)
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 }, { x: -1, z: 1 },
                // Turn left (going along z=1 to left edge)
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                // Corner to home turn
                { x: -7, z: 0 },
                // RED Home stretch (along z=0, going right toward center)
                { x: -6, z: 0 }, { x: -5, z: 0 }, { x: -4, z: 0 }, { x: -3, z: 0 }, { x: -2, z: 0 }, { x: -1, z: 0 }
            ],
            GREEN: [
                // Entry and first leg (going down along x=1)
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 }, { x: 1, z: -1 },
                // Turn right (going along z=-1)
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                // Corner and cross right
                { x: 7, z: 0 }, { x: 7, z: 1 },
                // Going left (along z=1)
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 }, { x: 1, z: 1 },
                // Turn down (going along x=1)
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                // Corner and cross top
                { x: 0, z: 7 }, { x: -1, z: 7 },
                // Going up (along x=-1)
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 }, { x: -1, z: 1 },
                // Turn left (going along z=1)
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                // Corner and cross left
                { x: -7, z: 0 }, { x: -7, z: -1 },
                // Going right (along z=-1)
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 }, { x: -1, z: -1 },
                // Turn up (going along x=-1)
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                // Corner to home turn
                { x: 0, z: -7 },
                // GREEN Home stretch (along x=0, going down toward center)
                { x: 0, z: -6 }, { x: 0, z: -5 }, { x: 0, z: -4 }, { x: 0, z: -3 }, { x: 0, z: -2 }, { x: 0, z: -1 }
            ],
            YELLOW: [
                // Entry and first leg (going left along z=1)
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 }, { x: 1, z: 1 },
                // Turn down (going along x=1)
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                // Corner and cross top
                { x: 0, z: 7 }, { x: -1, z: 7 },
                // Going up (along x=-1)
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 }, { x: -1, z: 1 },
                // Turn left (going along z=1)
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                // Corner and cross left
                { x: -7, z: 0 }, { x: -7, z: -1 },
                // Going right (along z=-1)
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 }, { x: -1, z: -1 },
                // Turn up (going along x=-1)
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                // Corner and cross bottom
                { x: 0, z: -7 }, { x: 1, z: -7 },
                // Going down (along x=1)
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 }, { x: 1, z: -1 },
                // Turn right (going along z=-1)
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                // Corner to home turn
                { x: 7, z: 0 },
                // YELLOW Home stretch (along z=0, going left toward center)
                { x: 6, z: 0 }, { x: 5, z: 0 }, { x: 4, z: 0 }, { x: 3, z: 0 }, { x: 2, z: 0 }, { x: 1, z: 0 }
            ],
            BLUE: [
                // Entry and first leg (going up along x=-1)
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 }, { x: -1, z: 1 },
                // Turn left (going along z=1)
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                // Corner and cross left
                { x: -7, z: 0 }, { x: -7, z: -1 },
                // Going right (along z=-1)
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 }, { x: -1, z: -1 },
                // Turn up (going along x=-1)
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                // Corner and cross bottom
                { x: 0, z: -7 }, { x: 1, z: -7 },
                // Going down (along x=1)
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 }, { x: 1, z: -1 },
                // Turn right (going along z=-1)
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                // Corner and cross right
                { x: 7, z: 0 }, { x: 7, z: 1 },
                // Going left (along z=1)
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 }, { x: 1, z: 1 },
                // Turn down (going along x=1)
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                // Corner to home turn
                { x: 0, z: 7 },
                // BLUE Home stretch (along x=0, going up toward center)
                { x: 0, z: 6 }, { x: 0, z: 5 }, { x: 0, z: 4 }, { x: 0, z: 3 }, { x: 0, z: 2 }, { x: 0, z: 1 }
            ]
        };

        // Constants for path logic
        const MAIN_TRACK_LENGTH = 51;  // Tiles before home stretch
        const HOME_STRETCH_LENGTH = 6; // Tiles in home stretch
        const TOTAL_PATH_LENGTH = 57;  // Total path length per player

        let scene, camera, renderer, raycaster, mouse, controls;
        let currentPlayerIndex = 0;
        let diceValue = 0;
        let gameState = 'WAITING_FOR_ROLL';
        let tokens = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            camera = new THREE.PerspectiveCamera(38, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 16);
            camera.lookAt(0, -1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.05;
            controls.minDistance = 8;
            controls.maxDistance = 40;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 5.0);
            pointLight.position.set(5, 12, 5);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 2048;
            pointLight.shadow.mapSize.height = 2048;
            scene.add(pointLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 1.8);
            fillLight.position.set(-10, 8, -10);
            scene.add(fillLight);

            createAdvancedBoard();
            createTokens();
            updateUI();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown);
            document.getElementById('dice-btn').addEventListener('click', rollDice);

            animate();
        }

        function createRoundedRectShape(width, height, radius) {
            const shape = new THREE.Shape();
            const x = -width / 2;
            const y = -height / 2;
            shape.moveTo(x, y + radius);
            shape.lineTo(x, y + height - radius);
            shape.quadraticCurveTo(x, y + height, x + radius, y + height);
            shape.lineTo(x + width - radius, y + height);
            shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            shape.lineTo(x + width, y + radius);
            shape.quadraticCurveTo(x + width, y, x + width - radius, y);
            shape.lineTo(x + radius, y);
            shape.quadraticCurveTo(x, y, x, y + radius);
            return shape;
        }

        function createArrowMesh(color, size = 0.5) {
            const shape = new THREE.Shape();
            shape.moveTo(0, size * 0.4);
            shape.lineTo(size * 0.35, -size * 0.1);
            shape.lineTo(size * 0.15, -size * 0.1);
            shape.lineTo(size * 0.15, -size * 0.4);
            shape.lineTo(-size * 0.15, -size * 0.4);
            shape.lineTo(-size * 0.15, -size * 0.1);
            shape.lineTo(-size * 0.35, -size * 0.1);
            shape.closePath();

            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.01, bevelEnabled: false });
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.5,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            return mesh;
        }

        function createAdvancedBoard() {
            const baseWidth = BOARD_SIZE + 1.8;
            const baseShape = createRoundedRectShape(baseWidth, baseWidth, 0.3);
            const baseGeom = new THREE.ExtrudeGeometry(baseShape, {
                depth: 1.2, bevelEnabled: true, bevelThickness: 0.15, bevelSize: 0.15, bevelSegments: 10
            });
            const baseMat = new THREE.MeshStandardMaterial({ color: COLORS.BOARD_BASE, roughness: 0.5, metalness: 0.15 });
            const base = new THREE.Mesh(baseGeom, baseMat);
            base.rotation.x = Math.PI / 2;
            base.position.y = -0.12;
            base.receiveShadow = true;
            scene.add(base);

            const frameGeom = new THREE.BoxGeometry(BOARD_SIZE + 0.1, 0.1, BOARD_SIZE + 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: COLORS.WOOD_RIM, roughness: 0.95 });
            const innerFrame = new THREE.Mesh(frameGeom, frameMat);
            innerFrame.position.y = -0.05;
            scene.add(innerFrame);

            const homeConfigs = [
                { x: -4.5, z: -4.5, color: COLORS.RED },
                { x: 4.5, z: -4.5, color: COLORS.GREEN },
                { x: 4.5, z: 4.5, color: COLORS.YELLOW },
                { x: -4.5, z: 4.5, color: COLORS.BLUE }
            ];
            const homeGeom = new THREE.BoxGeometry(5.95, TILE_HEIGHT, 5.95);

            const innerShape = createRoundedRectShape(4.0, 4.0, 0.5);
            const innerGeom = new THREE.ExtrudeGeometry(innerShape, { depth: 0.06, bevelEnabled: false });

            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
            const homeSideMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });
            // Material for base squares: 4 sides Black, Top/Bottom Colored
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });
            const innerMaterials = [whiteMat, homeSideMat];

            homeConfigs.forEach(config => {
                // Create multi-material array for Home Base
                // BoxGeometry order: +x, -x, +y (Top), -y (Bottom), +z, -z
                const colorMat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.5 });
                const homeMaterials = [
                    blackMat, // +x (Right) - Black
                    blackMat, // -x (Left)  - Black
                    colorMat, // +y (Top)   - Color
                    colorMat, // -y (Bottom)- Color
                    blackMat, // +z (Front) - Black
                    blackMat  // -z (Back)  - Black
                ];

                const hMesh = new THREE.Mesh(homeGeom, homeMaterials);
                hMesh.position.set(config.x, 0, config.z);
                scene.add(hMesh);

                const iMesh = new THREE.Mesh(innerGeom, innerMaterials);
                iMesh.rotation.x = Math.PI / 2;
                iMesh.position.set(config.x, TILE_HEIGHT / 2 + 0.08, config.z);
                scene.add(iMesh);
            });

            // --- MODIFIED SOCKET CREATION ---
            const socketInnerRadius = 0.4 * 1.05;
            const socketOuterRadius = 0.4 * 1.25;

            // Create 3D Ring using ExtrudeGeometry
            const ringShape = new THREE.Shape();
            ringShape.absarc(0, 0, socketOuterRadius, 0, Math.PI * 2, false);
            const ringHole = new THREE.Path();
            ringHole.absarc(0, 0, socketInnerRadius, 0, Math.PI * 2, true);
            ringShape.holes.push(ringHole);

            const socketHeight = TILE_HEIGHT / 8;

            const socketGeom = new THREE.ExtrudeGeometry(ringShape, {
                depth: socketHeight,
                bevelEnabled: false,
                curveSegments: 24
            });

            const socketMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5 });

            PLAYER_ORDER.forEach(colorName => {
                const positions = getStartPositions(colorName);
                positions.forEach(pos => {
                    const ring = new THREE.Mesh(socketGeom, socketMat);
                    // Rotate -90 deg X to extrude UPWARDS from position
                    ring.rotation.x = -Math.PI / 2;
                    // Position Y = Top of White Rounded Rectangle
                    // White Rect Base Y is (TILE_HEIGHT / 2 + 0.01). If it was Extruded down, Face is at that Y.
                    // Assuming white rect Face is at TILE_HEIGHT/2 + 0.01
                    ring.position.set(pos.x, TILE_HEIGHT / 2 + 0.08, pos.z);
                    scene.add(ring);
                });
            });

            const GAP = 0.05;
            const tileInnerEdge = 1.525;
            const triMaxY = tileInnerEdge - GAP; // End before the tiles start
            const diagOffset = (GAP / 2) * Math.sqrt(2); // Inset to create gap between diagonals
            const yStart = diagOffset;
            const halfWidth = triMaxY - diagOffset;

            const triShape = new THREE.Shape();
            triShape.moveTo(0, yStart);
            triShape.lineTo(-halfWidth, triMaxY);
            triShape.lineTo(halfWidth, triMaxY);
            triShape.lineTo(0, yStart);

            const triGeom = new THREE.ExtrudeGeometry(triShape, { depth: TILE_HEIGHT, bevelEnabled: false });
            const centerTris = [
                { rot: 0, color: COLORS.BLUE }, { rot: Math.PI / 2, color: COLORS.RED },
                { rot: Math.PI, color: COLORS.GREEN }, { rot: -Math.PI / 2, color: COLORS.YELLOW }
            ];
            centerTris.forEach(config => {
                const mat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.4 });
                const mesh = new THREE.Mesh(triGeom, mat);
                mesh.rotation.x = Math.PI / 2; mesh.rotation.z = config.rot;
                mesh.position.y = TILE_HEIGHT / 2;
                scene.add(mesh);
            });

            const blackSideMat = new THREE.MeshStandardMaterial({ color: COLORS.TILE_SIDE, roughness: 0.9 });

            for (let x = -7; x <= 7; x++) {
                for (let z = -7; z <= 7; z++) {
                    if (Math.abs(x) >= 2 && Math.abs(z) >= 2) continue;
                    if (Math.abs(x) < 2 && Math.abs(z) < 2) continue;

                    let topColor = (x + z) % 2 === 0 ? COLORS.TILE_LIGHT : COLORS.TILE_DARK;

                    if (x === 0 && z < 0 && z > -7) topColor = COLORS.GREEN;
                    else if (x === 0 && z > 0 && z < 7) topColor = COLORS.BLUE;
                    else if (z === 0 && x < 0 && x > -7) topColor = COLORS.RED;
                    else if (z === 0 && x > 0 && x < 7) topColor = COLORS.YELLOW;

                    if (x === -6 && z === -1) topColor = COLORS.RED;
                    if (x === 1 && z === -6) topColor = COLORS.GREEN;
                    if (x === 6 && z === 1) topColor = COLORS.YELLOW;
                    if (x === -1 && z === 6) topColor = COLORS.BLUE;

                    const tileGeom = new THREE.BoxGeometry(0.95, TILE_HEIGHT, 0.95);
                    const topMat = new THREE.MeshStandardMaterial({ color: topColor, roughness: 0.4 });

                    const materials = [
                        blackSideMat, // +x
                        blackSideMat, // -x
                        topMat,       // +y
                        blackSideMat, // -y
                        blackSideMat, // +z
                        blackSideMat  // -z
                    ];

                    const tile = new THREE.Mesh(tileGeom, materials);
                    tile.position.set(x, 0, z);
                    tile.receiveShadow = true;
                    scene.add(tile);

                    // --- Colored Home-Turn Arrows ---
                    if (x === -7 && z === 0) {
                        const arrow = createArrowMesh(COLORS.RED);
                        arrow.rotation.z = -Math.PI / 2;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === 0 && z === -7) {
                        const arrow = createArrowMesh(COLORS.GREEN);
                        arrow.rotation.z = Math.PI;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === 7 && z === 0) {
                        const arrow = createArrowMesh(COLORS.YELLOW);
                        arrow.rotation.z = Math.PI / 2;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === 0 && z === 7) {
                        const arrow = createArrowMesh(COLORS.BLUE);
                        arrow.rotation.z = 0;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }

                    // --- White Entry Arrows ---
                    if (x === -6 && z === -1) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = -Math.PI / 2;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                    if (x === 1 && z === -6) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = -Math.PI;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                    if (x === 6 && z === 1) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = Math.PI / 2;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                    if (x === -1 && z === 6) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = 0;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                }
            }
        }

        function createTokens() {
            const headGeom = new THREE.SphereGeometry(0.25, 24, 24);
            const bodyGeom = new THREE.CylinderGeometry(0.1, 0.35, 0.7, 24);
            const baseGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.12, 24);

            PLAYER_ORDER.forEach((colorName, pIdx) => {
                const color = COLORS[colorName];
                const startPositions = getStartPositions(colorName);
                for (let i = 0; i < 4; i++) {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.2,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });

                    const base = new THREE.Mesh(baseGeom, mat); base.position.y = 0.06;
                    const body = new THREE.Mesh(bodyGeom, mat); body.position.y = 0.45;
                    const head = new THREE.Mesh(headGeom, mat); head.position.y = 0.85;

                    group.add(base); group.add(body); group.add(head);
                    group.position.set(startPositions[i].x, TILE_HEIGHT / 2 + 0.08, startPositions[i].z);
                    group.castShadow = true;
                    group.userData = { playerIndex: pIdx, id: i, colorName: colorName, atHome: true, pathIndex: -1 };
                    scene.add(group); tokens.push(group);
                }
            });
        }

        function getStartPositions(colorName) {
            const positions = [{ x: -1.0, z: -1.0 }, { x: 1.0, z: -1.0 }, { x: -1.0, z: 1.0 }, { x: 1.0, z: 1.0 }];
            let center = { x: 0, z: 0 };
            if (colorName === 'RED') center = { x: -4.5, z: -4.5 };
            if (colorName === 'GREEN') center = { x: 4.5, z: -4.5 };
            if (colorName === 'YELLOW') center = { x: 4.5, z: 4.5 };
            if (colorName === 'BLUE') center = { x: -4.5, z: 4.5 };
            return positions.map(p => ({ x: p.x + center.x, z: p.z + center.z }));
        }

        function rollDice() {
            if (gameState !== 'WAITING_FOR_ROLL') return;
            const btn = document.getElementById('dice-btn');
            const res = document.getElementById('dice-result');
            btn.disabled = true; res.innerText = "?";
            setTimeout(() => {
                diceValue = Math.floor(Math.random() * 6) + 1;
                res.innerText = diceValue;
                const valid = tokens.filter(t => t.userData.playerIndex === currentPlayerIndex && (!t.userData.atHome || diceValue === 6));
                if (valid.length === 0) {
                    showMessage("NO MOVES POSSIBLE");
                    setTimeout(nextTurn, 1200);
                } else {
                    gameState = 'WAITING_FOR_MOVE';
                    showMessage("CHOOSE A PIECE");
                    highlightTokens(valid);
                }
            }, 500);
        }

        function highlightTokens(validOnes) {
            tokens.forEach(t => t.scale.set(1, 1, 1));
            validOnes.forEach(t => {
                new TWEEN.Tween(t.scale).to({ x: 1.25, y: 1.1, z: 1.25 }, 400).easing(TWEEN.Easing.Cubic.InOut).repeat(Infinity).yoyo(true).start();
            });
        }

        function moveToken(token, roll) {
            gameState = 'ANIMATING';
            TWEEN.removeAll();
            tokens.forEach(t => t.scale.set(1, 1, 1));
            let targetX, targetZ;
            if (token.userData.atHome) {
                token.userData.atHome = false;
                const entry = getEntryPosition(token.userData.colorName);
                targetX = entry.x; targetZ = entry.z;
            } else {
                targetX = token.position.x + (Math.random() > 0.5 ? 1 : -1) * 1.0;
                targetZ = token.position.z + (Math.random() > 0.5 ? 1 : -1) * 1.0;
                targetX = Math.max(-7, Math.min(7, targetX));
                targetZ = Math.max(-7, Math.min(7, targetZ));
            }
            const duration = 650;
            new TWEEN.Tween(token.position).to({ x: targetX, z: targetZ }, duration).easing(TWEEN.Easing.Quadratic.Out).onComplete(() => {
                checkCollision(token);
                if (roll !== 6) nextTurn();
                else { gameState = 'WAITING_FOR_ROLL'; updateUI(); showMessage("ROLL AGAIN!"); }
            }).start();
            new TWEEN.Tween(token.position).to({ y: 2.5 }, duration / 2).easing(TWEEN.Easing.Quadratic.Out).chain(new TWEEN.Tween(token.position).to({ y: TILE_HEIGHT / 2 }, duration / 2).easing(TWEEN.Easing.Quadratic.In)).start();
        }

        function getEntryPosition(colorName) {
            if (colorName === 'RED') return { x: -6, z: -1 };
            if (colorName === 'GREEN') return { x: 1, z: -6 };
            if (colorName === 'YELLOW') return { x: 6, z: 1 };
            if (colorName === 'BLUE') return { x: -1, z: 6 };
            return { x: 0, z: 0 };
        }

        function checkCollision(movedToken) {
            tokens.forEach(other => {
                if (other === movedToken || other.userData.playerIndex === movedToken.userData.playerIndex || other.userData.atHome) return;
                if (movedToken.position.distanceTo(other.position) < 0.6) {
                    showMessage(`CAPTURED ${PLAYER_ORDER[other.userData.playerIndex]}!`);
                    sendBack(other);
                }
            });
        }

        function sendBack(token) {
            const homePos = getStartPositions(token.userData.colorName)[token.userData.id];
            new TWEEN.Tween(token.position).to({ x: homePos.x, y: TILE_HEIGHT / 2 + 0.08, z: homePos.z }, 1200).easing(TWEEN.Easing.Elastic.Out).start();
            token.userData.atHome = true;
        }

        function nextTurn() {
            currentPlayerIndex = (currentPlayerIndex + 1) % 4;
            gameState = 'WAITING_FOR_ROLL';
            diceValue = 0;
            document.getElementById('dice-result').innerText = "-";
            updateUI();
        }

        function updateUI() {
            const colorName = PLAYER_ORDER[currentPlayerIndex];
            const dot = document.getElementById('player-dot');
            const text = document.getElementById('player-text');
            const btn = document.getElementById('dice-btn');
            const colorHex = `#${COLORS[colorName].toString(16).padStart(6, '0')}`;
            dot.style.backgroundColor = colorHex;
            dot.style.color = colorHex;
            text.innerText = `${colorName} PLAYER`;
            text.style.color = colorHex;
            btn.disabled = (gameState !== 'WAITING_FOR_ROLL');
        }

        function showMessage(msg) {
            const box = document.getElementById('msg-box');
            box.innerText = msg; box.style.opacity = 1; box.style.bottom = '60px';
            setTimeout(() => { box.style.opacity = 0; box.style.bottom = '40px'; }, 2000);
        }

        function onMouseDown(event) {
            if (gameState !== 'WAITING_FOR_MOVE') return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(tokens, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && obj.userData.playerIndex === undefined) { obj = obj.parent; }
                if (obj.userData.playerIndex === currentPlayerIndex && (!obj.userData.atHome || diceValue === 6)) moveToken(obj, diceValue);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            if (controls) controls.update();
            tokens.forEach(t => { t.rotation.y += (t.userData.playerIndex === currentPlayerIndex && gameState === 'WAITING_FOR_MOVE') ? 0.05 : 0.01; });
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>