<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ludo Pro Elite</title>

    <!-- Import Map for modern Three.js (r180+) -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.180.0/three.module.min.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
        }
    }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/25.0.0/tween.umd.js"></script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #020202;
            color: white;
        }

        canvas {
            display: block;
        }

        /* ============================================
           SETUP SCREEN STYLES
           ============================================ */
        #setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 70%, #000 100%);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        #setup-screen.hidden {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }

        .setup-container {
            background: rgba(15, 15, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 40px 50px;
            max-width: 520px;
            width: 90%;
            backdrop-filter: blur(20px);
            box-shadow:
                0 0 60px rgba(0, 0, 0, 0.8),
                0 0 120px rgba(100, 100, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: translateY(0);
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #setup-screen.hidden .setup-container {
            transform: translateY(50px) scale(0.9);
        }

        .setup-title {
            text-align: center;
            margin-bottom: 8px;
        }

        .setup-title h1 {
            font-size: 2.2rem;
            font-weight: 900;
            letter-spacing: 6px;
            margin: 0;
            background: linear-gradient(135deg, #fff 0%, #888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }

        .setup-title .subtitle {
            font-size: 0.75rem;
            letter-spacing: 4px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 8px;
            text-transform: uppercase;
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            margin: 25px 0;
        }

        /* Player Selection Grid */
        .player-selection {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 25px;
        }

        .player-slot {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
        }

        .player-slot:hover {
            border-color: rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.5);
        }

        .player-slot-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .player-color-badge {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            box-shadow: 0 0 12px currentColor;
        }

        .player-color-badge.red {
            background: #c1121f;
            color: #c1121f;
        }

        .player-color-badge.green {
            background: #007f5f;
            color: #007f5f;
        }

        .player-color-badge.yellow {
            background: #ffb703;
            color: #ffb703;
        }

        .player-color-badge.blue {
            background: #00308f;
            color: #00308f;
        }

        .player-slot-name {
            font-weight: 700;
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .player-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            background: rgba(20, 20, 25, 0.9);
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            transition: all 0.2s;
        }

        .player-select:hover {
            border-color: rgba(255, 255, 255, 0.3);
        }

        .player-select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1);
        }

        .player-select option {
            background: #1a1a1a;
            color: white;
        }

        /* Rules Section */
        .rules-section {
            margin-bottom: 25px;
        }

        .rules-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .rules-header h3 {
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            margin: 0;
        }

        .rules-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 16px;
            max-height: 180px;
            overflow-y: auto;
            font-size: 0.85rem;
            line-height: 1.7;
            color: rgba(255, 255, 255, 0.75);
        }

        .rules-box::-webkit-scrollbar {
            width: 6px;
        }

        .rules-box::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .rules-box::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .rules-box h4 {
            color: #fff;
            font-size: 0.9rem;
            margin: 0 0 8px 0;
            letter-spacing: 1px;
        }

        .rules-box ul {
            margin: 0 0 12px 0;
            padding-left: 18px;
        }

        .rules-box li {
            margin-bottom: 6px;
        }

        .rules-box strong {
            color: #ffb703;
        }

        /* Begin Button */
        #begin-btn {
            width: 100%;
            padding: 18px 30px;
            font-size: 1.1rem;
            font-weight: 800;
            letter-spacing: 4px;
            text-transform: uppercase;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a25 100%);
            color: white;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #begin-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        #begin-btn:hover {
            transform: translateY(-2px);
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #begin-btn:hover::before {
            left: 100%;
        }

        #begin-btn:active {
            transform: translateY(0);
        }

        /* ============================================
           GAME UI STYLES (hidden initially)
           ============================================ */
        #game-container {
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        #game-container.visible {
            opacity: 1;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            width: calc(100% - 40px);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 10;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.5s ease 0.3s, transform 0.5s ease 0.3s;
        }

        #ui.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .panel {
            background: rgba(10, 10, 10, 0.95);
            padding: 20px;
            border-radius: 16px;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9);
        }

        .turn-indicator {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 1px;
        }

        .color-dot {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: inline-block;
            box-shadow: 0 0 15px currentColor;
        }

        #msg-box {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.98);
            color: #fff;
            padding: 12px 35px;
            border-radius: 40px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            letter-spacing: 1px;
        }

        /* Floating particles background for setup */
        .particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: float 15s infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-100vh) rotate(720deg);
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <!-- ============================================
         SETUP SCREEN
         ============================================ -->
    <div id="setup-screen">
        <!-- Floating particles background -->
        <div class="particles" id="particles"></div>

        <div class="setup-container">
            <div class="setup-title">
                <h1>LUDO 3D</h1>
                <div class="subtitle">Elite Edition</div>
            </div>

            <div class="divider"></div>

            <!-- Player Selection -->
            <div class="player-selection">
                <div class="player-slot">
                    <div class="player-slot-header">
                        <div class="player-color-badge red"></div>
                        <span class="player-slot-name">Red</span>
                    </div>
                    <select class="player-select" id="select-red">
                        <option value="player">Player</option>
                        <option value="ai">AI</option>
                        <option value="nobody">Nobody</option>
                    </select>
                </div>

                <div class="player-slot">
                    <div class="player-slot-header">
                        <div class="player-color-badge green"></div>
                        <span class="player-slot-name">Green</span>
                    </div>
                    <select class="player-select" id="select-green">
                        <option value="player">Player</option>
                        <option value="ai">AI</option>
                        <option value="nobody">Nobody</option>
                    </select>
                </div>

                <div class="player-slot">
                    <div class="player-slot-header">
                        <div class="player-color-badge yellow"></div>
                        <span class="player-slot-name">Yellow</span>
                    </div>
                    <select class="player-select" id="select-yellow">
                        <option value="player">Player</option>
                        <option value="ai" selected>AI</option>
                        <option value="nobody">Nobody</option>
                    </select>
                </div>

                <div class="player-slot">
                    <div class="player-slot-header">
                        <div class="player-color-badge blue"></div>
                        <span class="player-slot-name">Blue</span>
                    </div>
                    <select class="player-select" id="select-blue">
                        <option value="player">Player</option>
                        <option value="ai" selected>AI</option>
                        <option value="nobody">Nobody</option>
                    </select>
                </div>
            </div>

            <!-- Rules Section -->
            <div class="rules-section">
                <div class="rules-header">
                    <h3>ðŸ“œ Game Rules</h3>
                </div>
                <div class="rules-box">
                    <h4>Objective</h4>
                    <ul>
                        <li>Be the first to move all <strong>4 tokens</strong> from your home base to the center finish
                            area.</li>
                    </ul>

                    <h4>Getting Started</h4>
                    <ul>
                        <li>Roll a <strong>6</strong> to move a token out of your home base onto the starting tile.</li>
                        <li>Each player takes turns rolling the dice.</li>
                    </ul>

                    <h4>Movement</h4>
                    <ul>
                        <li>Move your token forward by the number shown on the dice.</li>
                        <li>Tokens travel around the board and enter their colored home stretch.</li>
                        <li>You must roll the <strong>exact number</strong> to enter the finish area.</li>
                    </ul>

                    <h4>Capturing</h4>
                    <ul>
                        <li>Land on an opponent's token to send it back to their home base.</li>
                        <li>Tokens on <strong>safe tiles</strong> (marked with stars) cannot be captured.</li>
                    </ul>

                    <h4>Bonus Rolls</h4>
                    <ul>
                        <li>Rolling a <strong>6</strong> grants an extra turn!</li>
                        <li>Capturing an opponent also grants a bonus roll.</li>
                    </ul>
                </div>
            </div>

            <button id="begin-btn">Begin Game</button>
        </div>
    </div>

    <!-- ============================================
         GAME CONTAINER (hidden initially)
         ============================================ -->
    <div id="game-container">
        <div id="ui">
            <div class="panel">
                <div class="turn-indicator">
                    <span id="player-dot" class="color-dot"></span>
                    <span id="player-text">RED PLAYER</span>
                </div>
            </div>
            <div class="panel" style="padding: 10px 15px;">
                <div style="font-size: 0.7rem; opacity: 0.6; font-weight: 800; letter-spacing: 3px;">LUDO 3D ELITE</div>
            </div>
        </div>

        <div id="msg-box">SELECT A PIECE</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        const COLORS = {
            RED: 0xc1121f,
            BLUE: 0x00308f,
            YELLOW: 0xffb703,
            GREEN: 0x007f5f,
            BOARD_BASE: 0x4e342e,
            WOOD_RIM: 0x1a1a1a,
            TILE_LIGHT: 0xffffff,
            TILE_DARK: 0xfafafa,
            TILE_SIDE: 0x000000
        };
        const PLAYER_ORDER = ['RED', 'GREEN', 'YELLOW', 'BLUE'];
        const BOARD_SIZE = 15;
        const TILE_HEIGHT = 0.22;
        const PATHS = {
            RED: [
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 },
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                { x: 0, z: -7 }, { x: 1, z: -7 },
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 },
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                { x: 7, z: 0 }, { x: 7, z: 1 },
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 },
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                { x: 0, z: 7 }, { x: -1, z: 7 },
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 },
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                { x: -7, z: 0 },
                { x: -6, z: 0 }, { x: -5, z: 0 }, { x: -4, z: 0 }, { x: -3, z: 0 }, { x: -2, z: 0 }, { x: -1, z: 0 }
            ],
            GREEN: [
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 },
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                { x: 7, z: 0 }, { x: 7, z: 1 },
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 },
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                { x: 0, z: 7 }, { x: -1, z: 7 },
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 },
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                { x: -7, z: 0 }, { x: -7, z: -1 },
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 },
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                { x: 0, z: -7 },
                { x: 0, z: -6 }, { x: 0, z: -5 }, { x: 0, z: -4 }, { x: 0, z: -3 }, { x: 0, z: -2 }, { x: 0, z: -1 }
            ],
            YELLOW: [
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 },
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                { x: 0, z: 7 }, { x: -1, z: 7 },
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 },
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                { x: -7, z: 0 }, { x: -7, z: -1 },
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 },
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                { x: 0, z: -7 }, { x: 1, z: -7 },
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 },
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                { x: 7, z: 0 },
                { x: 6, z: 0 }, { x: 5, z: 0 }, { x: 4, z: 0 }, { x: 3, z: 0 }, { x: 2, z: 0 }, { x: 1, z: 0 }
            ],
            BLUE: [
                { x: -1, z: 6 }, { x: -1, z: 5 }, { x: -1, z: 4 }, { x: -1, z: 3 }, { x: -1, z: 2 },
                { x: -2, z: 1 }, { x: -3, z: 1 }, { x: -4, z: 1 }, { x: -5, z: 1 }, { x: -6, z: 1 }, { x: -7, z: 1 },
                { x: -7, z: 0 }, { x: -7, z: -1 },
                { x: -6, z: -1 }, { x: -5, z: -1 }, { x: -4, z: -1 }, { x: -3, z: -1 }, { x: -2, z: -1 },
                { x: -1, z: -2 }, { x: -1, z: -3 }, { x: -1, z: -4 }, { x: -1, z: -5 }, { x: -1, z: -6 }, { x: -1, z: -7 },
                { x: 0, z: -7 }, { x: 1, z: -7 },
                { x: 1, z: -6 }, { x: 1, z: -5 }, { x: 1, z: -4 }, { x: 1, z: -3 }, { x: 1, z: -2 },
                { x: 2, z: -1 }, { x: 3, z: -1 }, { x: 4, z: -1 }, { x: 5, z: -1 }, { x: 6, z: -1 }, { x: 7, z: -1 },
                { x: 7, z: 0 }, { x: 7, z: 1 },
                { x: 6, z: 1 }, { x: 5, z: 1 }, { x: 4, z: 1 }, { x: 3, z: 1 }, { x: 2, z: 1 },
                { x: 1, z: 2 }, { x: 1, z: 3 }, { x: 1, z: 4 }, { x: 1, z: 5 }, { x: 1, z: 6 }, { x: 1, z: 7 },
                { x: 0, z: 7 },
                { x: 0, z: 6 }, { x: 0, z: 5 }, { x: 0, z: 4 }, { x: 0, z: 3 }, { x: 0, z: 2 }, { x: 0, z: 1 }
            ]
        };
        const MAIN_TRACK_LENGTH = 51;
        const HOME_STRETCH_LENGTH = 6;
        const TOTAL_PATH_LENGTH = 57;
        const SCREENS = {
            SETUP: 'SETUP',
            PLAYING: 'PLAYING',
            GAMEOVER: 'GAMEOVER'
        };
        let currentScreen = SCREENS.SETUP;
        const playerConfig = {
            RED: 'player',
            GREEN: 'player',
            YELLOW: 'ai',
            BLUE: 'ai'
        };
        let scene, camera, renderer, raycaster, mouse, controls;
        let currentPlayerIndex = 0;
        let diceValue = 0;
        let gameState = 'WAITING_FOR_ROLL';
        let tokens = [];
        let gameInitialized = false;
        let dice = [];
        let homeInnerMeshes = {};
        const tweenGroup = new TWEEN.Group();

        const DEBUG_TURN_FLOW = true;
        function dbg(label, data = {}) {
            if (!DEBUG_TURN_FLOW) return;
            console.log(`[TURN_FLOW] ${label}`, data);
        }

        function createParticles() {
            const container = document.getElementById('particles');
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (10 + Math.random() * 10) + 's';
                container.appendChild(particle);
            }
        }
        function readPlayerConfig() {
            playerConfig.RED = document.getElementById('select-red').value;
            playerConfig.GREEN = document.getElementById('select-green').value;
            playerConfig.YELLOW = document.getElementById('select-yellow').value;
            playerConfig.BLUE = document.getElementById('select-blue').value;
        }
        function getActivePlayers() {
            return PLAYER_ORDER.filter(color => playerConfig[color] !== 'nobody');
        }
        function transitionToGame() {
            readPlayerConfig();
            const activePlayers = getActivePlayers();
            if (activePlayers.length < 2) {
                alert('Please select at least 2 players (Player or AI) to start the game.');
                return;
            }
            currentScreen = SCREENS.PLAYING;
            const setupScreen = document.getElementById('setup-screen');
            setupScreen.classList.add('hidden');
            setTimeout(() => {
                initGame();
                const gameContainer = document.getElementById('game-container');
                gameContainer.classList.add('visible');
                setTimeout(() => {
                    document.getElementById('ui').classList.add('visible');
                }, 200);
                setTimeout(() => {
                    setupScreen.style.display = 'none';
                }, 800);
            }, 400);
        }
        function initGame() {
            if (gameInitialized) return;
            gameInitialized = true;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            camera = new THREE.PerspectiveCamera(38, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 40);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('game-container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.05;
            controls.minDistance = 8;
            controls.maxDistance = 40;
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 5.0);
            pointLight.position.set(5, 12, 5);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 2048;
            pointLight.shadow.mapSize.height = 2048;
            scene.add(pointLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.8);
            fillLight.position.set(-10, 8, -10);
            scene.add(fillLight);
            createAdvancedBoard();
            createTokens();
            createDice();
            findFirstActivePlayer();
            updateUI();
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown);
            animateCameraEntrance();
            animate();
            // Debug helper (disabled by default): walk 1 pawn of each color along its path.
            // NOTE: Running 4 walkers at once can tank FPS and make movement look janky on slower devices.
            // Flip this to true only when you're actively debugging paths.
            const ENABLE_DEBUG_WALK = false;
            if (ENABLE_DEBUG_WALK) {
                setTimeout(() => {
                    PLAYER_ORDER.forEach(color => debugWalkPath(color));
                }, 1000);
            }
        }
        function setDiceHighlight(index, active) {
            if (!dice[index]) return;
            const intensity = active ? 0.4 : 0;
            const color = 0xffffff;
            if (dice[index].material) {
                if (Array.isArray(dice[index].material)) {
                    dice[index].material.forEach(mat => {
                        mat.emissive.setHex(active ? color : 0x000000);
                        mat.emissiveIntensity = intensity;
                    });
                } else {
                    dice[index].material.emissive.setHex(active ? color : 0x000000);
                    dice[index].material.emissiveIntensity = intensity;
                }
            }
        }
        function setTokenHighlight(token, active) {
            const colorName = token.userData.colorName;
            const baseColor = COLORS[colorName];
            let baseIntensity = 0.8;
            if (colorName === 'GREEN') {
                baseIntensity = 1.6;
            } else if (colorName === 'BLUE') {
                baseIntensity = 2.24;
            } else if (colorName === 'RED') {
                baseIntensity = 1.2;
            }
            const intensity = active ? baseIntensity : 0.1;
            token.children.forEach(mesh => {
                if (mesh.material) {
                    mesh.material.emissive.setHex(baseColor);
                    mesh.material.emissiveIntensity = intensity;
                }
            });
        }
        function animateCameraEntrance() {
            new TWEEN.Tween(camera.position, tweenGroup)
                .to({ x: 0, y: 20, z: 16 }, 2000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        }
        function findFirstActivePlayer() {
            while (playerConfig[PLAYER_ORDER[currentPlayerIndex]] === 'nobody') {
                currentPlayerIndex = (currentPlayerIndex + 1) % 4;
            }
        }
        const DICE_SIZE = 0.9;
        const DICE_RADIUS = DICE_SIZE * 0.1;
        const DOT_PATTERNS = {
            1: [[0, 0]],
            2: [[-0.5, -0.5], [0.5, 0.5]],
            3: [[-0.5, -0.5], [0, 0], [0.5, 0.5]],
            4: [[-0.5, -0.5], [0.5, -0.5], [-0.5, 0.5], [0.5, 0.5]],
            5: [[-0.5, -0.5], [0.5, -0.5], [0, 0], [-0.5, 0.5], [0.5, 0.5]],
            6: [[-0.5, -0.5], [0.5, -0.5], [-0.5, 0], [0.5, 0], [-0.5, 0.5], [0.5, 0.5]]
        };
        function createDiceFaceTexture(dotCount) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size * 0.7);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(1, '#f0f0f0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            const dotRadius = size * 0.1;
            const pattern = DOT_PATTERNS[dotCount];
            ctx.fillStyle = '#1a1a1a';
            pattern.forEach(([x, y]) => {
                const px = size / 2 + x * size * 0.55;
                const py = size / 2 + y * size * 0.55;
                ctx.beginPath();
                ctx.arc(px, py, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            });
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }
        function createDice() {
            const diceGeom = new RoundedBoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE, 4, DICE_RADIUS);
            const faceOrder = [3, 4, 2, 5, 1, 6];
            for (let i = 0; i < 2; i++) {
                const materials = faceOrder.map(dots => {
                    return new THREE.MeshStandardMaterial({
                        map: createDiceFaceTexture(dots),
                        roughness: 0.3,
                        metalness: 0.05
                    });
                });
                const dieMesh = new THREE.Mesh(diceGeom, materials);
                const offsetX = (i === 0) ? -0.6 : 0.6;
                const offsetZ = (i === 0) ? 0.3 : -0.3;
                dieMesh.position.set(offsetX, TILE_HEIGHT + DICE_SIZE / 2, offsetZ);
                dieMesh.rotation.set(0, 0, 0);
                dieMesh.castShadow = true;
                dieMesh.receiveShadow = true;
                dieMesh.userData.isDice = true;
                dieMesh.userData.index = i;
                scene.add(dieMesh);
                dice.push(dieMesh);
            }
        }
        function getDiceTopFace(die) {
            const faces = [
                { normal: new THREE.Vector3(1, 0, 0), value: 3 },
                { normal: new THREE.Vector3(-1, 0, 0), value: 4 },
                { normal: new THREE.Vector3(0, 1, 0), value: 2 },
                { normal: new THREE.Vector3(0, -1, 0), value: 5 },
                { normal: new THREE.Vector3(0, 0, 1), value: 1 },
                { normal: new THREE.Vector3(0, 0, -1), value: 6 }
            ];
            const worldUp = new THREE.Vector3(0, 1, 0);
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(die.rotation);
            let topFace = null;
            let maxDot = -Infinity;
            faces.forEach(face => {
                const transformedNormal = face.normal.clone().applyMatrix4(rotationMatrix);
                const dot = transformedNormal.dot(worldUp);
                if (dot > maxDot) {
                    maxDot = dot;
                    topFace = face.value;
                }
            });
            return topFace;
        }
        function animateDiceRoll() {
            const LIFT_DURATION = 400;
            const STEP_DURATION = 100;
            const NUM_STEPS = 30;
            const ROTATION_DURATION = NUM_STEPS * STEP_DURATION;
            const DROP_DURATION = 400;
            const FLOAT_HEIGHT = 3.0;
            dice.forEach((die, index) => {
                const startY = die.position.y;
                const homeX = (index === 0) ? -0.6 : 0.6;
                const homeZ = (index === 0) ? 0.3 : -0.3;
                const rotationSteps = [];
                for (let i = 0; i < NUM_STEPS; i++) {
                    const axes = ['x', 'y', 'z'];
                    const axis = axes[Math.floor(Math.random() * 3)];
                    const angles = [-Math.PI / 2, Math.PI / 2, Math.PI];
                    const angle = angles[Math.floor(Math.random() * 3)];
                    rotationSteps.push({ axis, angle });
                }
                const liftTween = new TWEEN.Tween(die.position, tweenGroup)
                    .to({ y: startY + FLOAT_HEIGHT }, LIFT_DURATION)
                    .easing(TWEEN.Easing.Quadratic.Out);
                let currentRotation = { x: die.rotation.x, y: die.rotation.y, z: die.rotation.z };
                let firstRotationTween = null;
                let previousTween = null;
                rotationSteps.forEach((step, stepIndex) => {
                    const targetRotation = {
                        x: currentRotation.x + (step.axis === 'x' ? step.angle : 0),
                        y: currentRotation.y + (step.axis === 'y' ? step.angle : 0),
                        z: currentRotation.z + (step.axis === 'z' ? step.angle : 0)
                    };
                    const stepTween = new TWEEN.Tween(die.rotation, tweenGroup)
                        .to(targetRotation, STEP_DURATION)
                        .easing(TWEEN.Easing.Sinusoidal.InOut);
                    if (stepIndex === 0) {
                        firstRotationTween = stepTween;
                    }
                    if (previousTween) {
                        previousTween.chain(stepTween);
                    }
                    previousTween = stepTween;
                    currentRotation = { ...targetRotation };
                });
                const dropTween = new TWEEN.Tween(die.position, tweenGroup)
                    .to({ y: startY }, DROP_DURATION)
                    .easing(TWEEN.Easing.Bounce.Out);
                if (previousTween) {
                    previousTween.chain(dropTween);
                }
                if (firstRotationTween) {
                    liftTween.chain(firstRotationTween);
                }
                liftTween.start();
                const driftX = (Math.random() - 0.5) * 0.5;
                const driftZ = (Math.random() - 0.5) * 0.5;
                new TWEEN.Tween(die.position, tweenGroup)
                    .to({ x: homeX + driftX, z: homeZ + driftZ }, LIFT_DURATION + ROTATION_DURATION * 0.5)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                setTimeout(() => {
                    new TWEEN.Tween(die.position, tweenGroup)
                        .to({ x: homeX, z: homeZ }, DROP_DURATION)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .start();
                }, LIFT_DURATION + ROTATION_DURATION);
            });
        }
        function createRoundedRectShape(width, height, radius) {
            const shape = new THREE.Shape();
            const x = -width / 2;
            const y = -height / 2;
            shape.moveTo(x, y + radius);
            shape.lineTo(x, y + height - radius);
            shape.quadraticCurveTo(x, y + height, x + radius, y + height);
            shape.lineTo(x + width - radius, y + height);
            shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            shape.lineTo(x + width, y + radius);
            shape.quadraticCurveTo(x + width, y, x + width - radius, y);
            shape.lineTo(x + radius, y);
            shape.quadraticCurveTo(x, y, x, y + radius);
            return shape;
        }
        function createArrowMesh(color, size = 0.5) {
            const shape = new THREE.Shape();
            shape.moveTo(0, size * 0.4);
            shape.lineTo(size * 0.35, -size * 0.1);
            shape.lineTo(size * 0.15, -size * 0.1);
            shape.lineTo(size * 0.15, -size * 0.4);
            shape.lineTo(-size * 0.15, -size * 0.4);
            shape.lineTo(-size * 0.15, -size * 0.1);
            shape.lineTo(-size * 0.35, -size * 0.1);
            shape.closePath();
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.01, bevelEnabled: false });
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.5,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            return mesh;
        }
        function createAdvancedBoard() {
            const baseWidth = BOARD_SIZE + 1.8;
            const baseShape = createRoundedRectShape(baseWidth, baseWidth, 0.3);
            const baseGeom = new THREE.ExtrudeGeometry(baseShape, {
                depth: 1.2, bevelEnabled: true, bevelThickness: 0.15, bevelSize: 0.15, bevelSegments: 10
            });
            const baseMat = new THREE.MeshStandardMaterial({ color: COLORS.BOARD_BASE, roughness: 0.5, metalness: 0.15 });
            const base = new THREE.Mesh(baseGeom, baseMat);
            base.rotation.x = Math.PI / 2;
            base.position.y = -0.12;
            base.receiveShadow = true;
            scene.add(base);
            const frameGeom = new THREE.BoxGeometry(BOARD_SIZE + 0.1, 0.1, BOARD_SIZE + 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: COLORS.WOOD_RIM, roughness: 0.95 });
            const innerFrame = new THREE.Mesh(frameGeom, frameMat);
            innerFrame.position.y = -0.05;
            scene.add(innerFrame);
            const homeConfigs = [
                { x: -4.5, z: -4.5, color: COLORS.RED },
                { x: 4.5, z: -4.5, color: COLORS.GREEN },
                { x: 4.5, z: 4.5, color: COLORS.YELLOW },
                { x: -4.5, z: 4.5, color: COLORS.BLUE }
            ];
            const homeGeom = new THREE.BoxGeometry(5.95, TILE_HEIGHT, 5.95);
            const innerShape = createRoundedRectShape(4.0, 4.0, 0.5);
            const innerGeom = new THREE.ExtrudeGeometry(innerShape, { depth: 0.06, bevelEnabled: false });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
            const homeSideMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });
            const innerMaterials = [whiteMat, homeSideMat];
            homeConfigs.forEach(config => {
                const colorMat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.5 });
                const homeMaterials = [
                    blackMat,
                    blackMat,
                    colorMat,
                    colorMat,
                    blackMat,
                    blackMat
                ];
                const hMesh = new THREE.Mesh(homeGeom, homeMaterials);
                hMesh.position.set(config.x, 0, config.z);
                scene.add(hMesh);
                const playerWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
                const playerInnerMaterials = [playerWhiteMat, homeSideMat];
                const iMesh = new THREE.Mesh(innerGeom, playerInnerMaterials);
                iMesh.rotation.x = Math.PI / 2;
                iMesh.position.set(config.x, TILE_HEIGHT / 2 + 0.08, config.z);
                scene.add(iMesh);
                const colorName = Object.keys(COLORS).find(key => COLORS[key] === config.color);
                if (colorName) {
                    homeInnerMeshes[colorName] = { mesh: iMesh, whiteMat: playerWhiteMat, originalColor: config.color };
                }
            });
            const socketInnerRadius = 0.4 * 1.05;
            const socketOuterRadius = 0.4 * 1.25;
            const ringShape = new THREE.Shape();
            ringShape.absarc(0, 0, socketOuterRadius, 0, Math.PI * 2, false);
            const ringHole = new THREE.Path();
            ringHole.absarc(0, 0, socketInnerRadius, 0, Math.PI * 2, true);
            ringShape.holes.push(ringHole);
            const socketHeight = TILE_HEIGHT / 8;
            const socketGeom = new THREE.ExtrudeGeometry(ringShape, {
                depth: socketHeight,
                bevelEnabled: false,
                curveSegments: 24
            });
            const socketMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5 });
            PLAYER_ORDER.forEach(colorName => {
                const positions = getStartPositions(colorName);
                positions.forEach(pos => {
                    const ring = new THREE.Mesh(socketGeom, socketMat);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.set(pos.x, TILE_HEIGHT / 2 + 0.08, pos.z);
                    scene.add(ring);
                });
            });
            const GAP = 0.05;
            const tileInnerEdge = 1.525;
            const triMaxY = tileInnerEdge - GAP;
            const diagOffset = (GAP / 2) * Math.sqrt(2);
            const yStart = diagOffset;
            const halfWidth = triMaxY - diagOffset;
            const triShape = new THREE.Shape();
            triShape.moveTo(0, yStart);
            triShape.lineTo(-halfWidth, triMaxY);
            triShape.lineTo(halfWidth, triMaxY);
            triShape.lineTo(0, yStart);
            const triGeom = new THREE.ExtrudeGeometry(triShape, { depth: TILE_HEIGHT, bevelEnabled: false });
            const centerTris = [
                { rot: 0, color: COLORS.BLUE }, { rot: Math.PI / 2, color: COLORS.RED },
                { rot: Math.PI, color: COLORS.GREEN }, { rot: -Math.PI / 2, color: COLORS.YELLOW }
            ];
            centerTris.forEach(config => {
                const mat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.4 });
                const mesh = new THREE.Mesh(triGeom, mat);
                mesh.rotation.x = Math.PI / 2; mesh.rotation.z = config.rot;
                mesh.position.y = TILE_HEIGHT / 2;
                scene.add(mesh);
            });
            const blackSideMat = new THREE.MeshStandardMaterial({ color: COLORS.TILE_SIDE, roughness: 0.9 });
            for (let x = -7; x <= 7; x++) {
                for (let z = -7; z <= 7; z++) {
                    if (Math.abs(x) >= 2 && Math.abs(z) >= 2) continue;
                    if (Math.abs(x) < 2 && Math.abs(z) < 2) continue;
                    let topColor = (x + z) % 2 === 0 ? COLORS.TILE_LIGHT : COLORS.TILE_DARK;
                    if (x === 0 && z < 0 && z > -7) topColor = COLORS.GREEN;
                    else if (x === 0 && z > 0 && z < 7) topColor = COLORS.BLUE;
                    else if (z === 0 && x < 0 && x > -7) topColor = COLORS.RED;
                    else if (z === 0 && x > 0 && x < 7) topColor = COLORS.YELLOW;
                    if (x === -6 && z === -1) topColor = COLORS.RED;
                    if (x === 1 && z === -6) topColor = COLORS.GREEN;
                    if (x === 6 && z === 1) topColor = COLORS.YELLOW;
                    if (x === -1 && z === 6) topColor = COLORS.BLUE;
                    const tileGeom = new THREE.BoxGeometry(0.95, TILE_HEIGHT, 0.95);
                    const topMat = new THREE.MeshStandardMaterial({ color: topColor, roughness: 0.4 });
                    const materials = [
                        blackSideMat,
                        blackSideMat,
                        topMat,
                        blackSideMat,
                        blackSideMat,
                        blackSideMat
                    ];
                    const tile = new THREE.Mesh(tileGeom, materials);
                    tile.position.set(x, 0, z);
                    tile.receiveShadow = true;
                    scene.add(tile);
                    if (x === -7 && z === 0) {
                        const arrow = createArrowMesh(COLORS.RED);
                        arrow.rotation.z = -Math.PI / 2;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === 0 && z === -7) {
                        const arrow = createArrowMesh(COLORS.GREEN);
                        arrow.rotation.z = Math.PI;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === 7 && z === 0) {
                        const arrow = createArrowMesh(COLORS.YELLOW);
                        arrow.rotation.z = Math.PI / 2;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === 0 && z === 7) {
                        const arrow = createArrowMesh(COLORS.BLUE);
                        arrow.rotation.z = 0;
                        arrow.position.set(x, TILE_HEIGHT / 2 + 0.01, z);
                        scene.add(arrow);
                    }
                    if (x === -6 && z === -1) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = -Math.PI / 2;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                    if (x === 1 && z === -6) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = -Math.PI;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                    if (x === 6 && z === 1) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = Math.PI / 2;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                    if (x === -1 && z === 6) {
                        const entryArrow = createArrowMesh(0xffffff, 0.4);
                        entryArrow.rotation.z = 0;
                        entryArrow.position.set(x, TILE_HEIGHT / 2 + 0.015, z);
                        scene.add(entryArrow);
                    }
                }
            }
        }
        function createTokens() {
            const headGeom = new THREE.SphereGeometry(0.25, 24, 24);
            const bodyGeom = new THREE.CylinderGeometry(0.1, 0.35, 0.7, 24);
            const baseGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.12, 24);
            PLAYER_ORDER.forEach((colorName, pIdx) => {
                const color = COLORS[colorName];
                const startPositions = getStartPositions(colorName);
                for (let i = 0; i < 4; i++) {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.2,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const base = new THREE.Mesh(baseGeom, mat); base.position.y = 0.06;
                    const body = new THREE.Mesh(bodyGeom, mat); body.position.y = 0.45;
                    const head = new THREE.Mesh(headGeom, mat); head.position.y = 0.85;
                    group.add(base); group.add(body); group.add(head);
                    group.position.set(startPositions[i].x, TILE_HEIGHT / 2 + 0.08, startPositions[i].z);
                    group.castShadow = true;
                    group.userData = { playerIndex: pIdx, id: i, colorName: colorName, atHome: true, pathIndex: -1 };
                    scene.add(group); tokens.push(group);
                }
            });
        }
        function getStartPositions(colorName) {
            const positions = [{ x: -1.0, z: -1.0 }, { x: 1.0, z: -1.0 }, { x: -1.0, z: 1.0 }, { x: 1.0, z: 1.0 }];
            let center = { x: 0, z: 0 };
            if (colorName === 'RED') center = { x: -4.5, z: -4.5 };
            if (colorName === 'GREEN') center = { x: 4.5, z: -4.5 };
            if (colorName === 'YELLOW') center = { x: 4.5, z: 4.5 };
            if (colorName === 'BLUE') center = { x: -4.5, z: 4.5 };
            return positions.map(p => ({ x: p.x + center.x, z: p.z + center.z }));
        }
        let currentTurnValues = [];
        let availableDiceIndices = [];
        let activeDieIndex = -1;

        function rollDice() {
            if (gameState !== 'WAITING_FOR_ROLL') return;
            gameState = 'ROLLING';
            setDiceHighlight(0, false);
            setDiceHighlight(1, false);
            // Clear any previous token highlights
            highlightTokens([]);

            animateDiceRoll();
            setTimeout(() => {
                const die1Value = getDiceTopFace(dice[0]);
                const die2Value = getDiceTopFace(dice[1]);
                console.log('Die 1:', die1Value, '| Die 2:', die2Value);
                showMessage(`ROLLED ${die1Value} and ${die2Value}`);

                currentTurnValues = [die1Value, die2Value];
                availableDiceIndices = [0, 1];

                // Default active die: Higher value, or random/first if equal. 
                activeDieIndex = (die1Value >= die2Value) ? 0 : 1;

                dbg('rollDice -> set turn values', {
                    currentPlayerIndex,
                    currentPlayerColor: PLAYER_ORDER[currentPlayerIndex],
                    currentTurnValues,
                    availableDiceIndices,
                    activeDieIndex,
                    gameState
                });
                updateTurnState();
            }, 3900);
        }

        function updateTurnState() {
            // Unhighlight all dice first
            setDiceHighlight(0, false);
            setDiceHighlight(1, false);

            dbg('updateTurnState (start)', {
                currentPlayerIndex,
                currentPlayerColor: PLAYER_ORDER[currentPlayerIndex],
                currentTurnValues,
                availableDiceIndices,
                gameState
            });

            if (availableDiceIndices.length === 0) {
                dbg('updateTurnState -> no dice left, nextTurn scheduled');
                setTimeout(nextTurn, 500);
                return;
            }

            // Find valid tokens for each available die
            const validMovesPerDie = {};
            availableDiceIndices.forEach(dieIdx => {
                const val = currentTurnValues[dieIdx];
                const validForDie = tokens.filter(t => {
                    if (t.userData.playerIndex !== currentPlayerIndex) return false;
                    // If at home (pathIndex < 0), need exactly 6 to leave
                    if (t.userData.pathIndex === undefined || t.userData.pathIndex < 0) {
                        return val === 6;
                    }
                    // TODO: Add path overshoot check
                    return true;
                });
                if (validForDie.length > 0) {
                    validMovesPerDie[dieIdx] = validForDie;
                }
            });

            const validDiceIndices = Object.keys(validMovesPerDie).map(Number);

            dbg('updateTurnState -> valid moves analysis', {
                validDiceIndices,
                validMovesPerDie
            });

            if (validDiceIndices.length === 0) {
                // No valid moves for ANY remaining die
                const remainingValues = availableDiceIndices.map(i => currentTurnValues[i]);
                showMessage(`NO MOVES FOR ${remainingValues.join(', ')}`);

                // Discard all remaining dice and end turn
                setTimeout(() => {
                    dbg('NO MOVES -> discarding remaining dice');
                    availableDiceIndices = [];
                    updateTurnState();
                }, 1000);
            } else {
                // 2. Ensure activeDieIndex is valid (must be in availableDiceIndices)
                if (!availableDiceIndices.includes(activeDieIndex)) {
                    activeDieIndex = availableDiceIndices[0];
                }

                // 3. Highlight logic: only show moves for the ACTIVE die
                let activeHasMoves = validMovesPerDie[activeDieIndex] && validMovesPerDie[activeDieIndex].length > 0;

                if (!activeHasMoves) {
                    // Active die has no moves. Do we have another die with moves?
                    const otherValidIndex = validDiceIndices.find(idx => idx !== activeDieIndex);
                    if (otherValidIndex !== undefined) {
                        // Switch to the useful die
                        activeDieIndex = otherValidIndex;
                        activeHasMoves = true;
                    }
                }

                gameState = 'WAITING_FOR_MOVE';

                // Show message
                showMessage(`USE ${currentTurnValues[activeDieIndex]}`);

                // Highlight ONLY the active die
                availableDiceIndices.forEach(idx => {
                    setDiceHighlight(idx, idx === activeDieIndex);
                });

                // Highlight valid tokens for the ACTIVE die only
                const validTokensForActive = validMovesPerDie[activeDieIndex] || [];
                highlightTokens(validTokensForActive);
            }
        }

        function highlightTokens(validOnes) {
            // Reset all tokens to default state
            tokens.forEach(t => {
                setTokenHighlight(t, false);
            });

            // Highlight only the valid ones
            validOnes.forEach(t => {
                setTokenHighlight(t, true);
            });
        }

        function moveToken(token, roll, dieIndex) {
            gameState = 'ANIMATING';

            // Remove highlights immediately
            highlightTokens([]);

            const route = PATHS[token.userData.colorName];
            if (!route || route.length === 0) {
                // Safety fallback: if path is missing, don't move.
                gameState = 'WAITING_FOR_MOVE';
                return;
            }

            // Build a per-square list of indices to visit.
            const stepIndices = [];
            const lastIndex = route.length - 1;

            if (token.userData.atHome) {
                // Leaving home: step onto the entry square.
                token.userData.atHome = false;
                token.userData.pathIndex = 0;
                stepIndices.push(0);
            } else {
                let startIdx = token.userData.pathIndex;
                if (startIdx === undefined || startIdx < 0) startIdx = 0;

                for (let s = 1; s <= roll; s++) {
                    const idx = Math.min(startIdx + s, lastIndex);
                    if (stepIndices.length > 0 && idx === stepIndices[stepIndices.length - 1]) break; // hit the end
                    stepIndices.push(idx);
                    if (idx === lastIndex) break;
                }
            }

            const stepDuration = 220; // ms per square
            const hopHeight = 0.55;
            const groundY = TILE_HEIGHT / 2 + 0.08;
            token.position.y = groundY;

            dbg('moveToken (start)', {
                roll,
                dieIndex,
                availableDiceIndices,
                token: {
                    id: token.userData.id,
                    colorName: token.userData.colorName,
                    atHome: token.userData.atHome,
                    pathIndex: token.userData.pathIndex
                },
                stepIndices
            });

            function animateStep(stepNumber) {
                if (stepNumber >= stepIndices.length) {
                    checkCollision(token);

                    // Remove the used die from available indices
                    const idxInArray = availableDiceIndices.indexOf(dieIndex);
                    if (idxInArray > -1) {
                        availableDiceIndices.splice(idxInArray, 1);
                    }

                    dbg('moveToken (end) -> die consumed', { consumedIndex: dieIndex, remaining: availableDiceIndices });
                    updateTurnState();
                    return;
                }

                const idx = stepIndices[stepNumber];
                const target = route[idx];

                // Horizontal move for this square
                new TWEEN.Tween(token.position, tweenGroup)
                    .to({ x: target.x, z: target.z }, stepDuration)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onComplete(() => {
                        token.userData.pathIndex = idx;
                        animateStep(stepNumber + 1);
                    })
                    .start();

                // Hop for this square (timed to the horizontal move)
                new TWEEN.Tween(token.position, tweenGroup)
                    .to({ y: groundY + hopHeight }, stepDuration / 2)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .yoyo(true)
                    .repeat(1)
                    .start();
            }

            animateStep(0);
        }

        // Keep helpers
        function getEntryPosition(colorName) {
            // Use the first point of the path logic if available?
            // The PATHS array has the start.
            if (PATHS[colorName] && PATHS[colorName][0]) {
                return PATHS[colorName][0];
            }
            return { x: 0, z: 0 };
        }

        function checkCollision(movedToken) {
            tokens.forEach(other => {
                if (other === movedToken || other.userData.playerIndex === movedToken.userData.playerIndex || other.userData.pathIndex === undefined || other.userData.pathIndex < 0) return;
                // Simple distance check
                if (movedToken.position.distanceTo(other.position) < 0.6) {
                    showMessage(`CAPTURED ${PLAYER_ORDER[other.userData.playerIndex]}!`);
                    sendBack(other);
                    // Capturing usually gives bonus, but we'll stick to the requested flow for simplicity
                }
            });
        }

        function sendBack(token) {
            const homePos = getStartPositions(token.userData.colorName)[token.userData.id];
            new TWEEN.Tween(token.position, tweenGroup)
                .to({ x: homePos.x, y: TILE_HEIGHT / 2 + 0.08, z: homePos.z }, 1200)
                .easing(TWEEN.Easing.Elastic.Out)
                .start();
            token.userData.atHome = true;
            token.userData.pathIndex = -1;
        }

        function nextTurn() {
            dbg('nextTurn (start)', {
                currentPlayerIndex,
                currentPlayerColor: PLAYER_ORDER[currentPlayerIndex],
                currentTurnValues,
                availableDiceIndices,
                gameState
            });
            setDiceHighlight(0, false);
            setDiceHighlight(1, false);
            currentPlayerIndex = (currentPlayerIndex + 1) % 4;
            findFirstActivePlayer(); // Skip empty/nobody slots
            gameState = 'WAITING_FOR_ROLL';
            currentTurnValues = [];
            availableDiceIndices = [];
            updateUI();
            dbg('nextTurn (end)', {
                currentPlayerIndex,
                currentPlayerColor: PLAYER_ORDER[currentPlayerIndex],
                currentTurnValues,
                availableDiceIndices,
                gameState
            });

            // Auto-roll for the next player
            setTimeout(() => {
                rollDice();
            }, 1000);
        }
        function updateTurnIndicatorGlow() {
            const currentColorName = PLAYER_ORDER[currentPlayerIndex];
            const baseWhite = new THREE.Color(0xffffff);
            // 0.0 = pure white, 1.0 = fully player color. Keep this low for a subtle tint.
            const ACTIVE_TINT = 0.18;
            PLAYER_ORDER.forEach(colorName => {
                const homeRef = homeInnerMeshes[colorName];
                if (homeRef && homeRef.whiteMat) {
                    // Ensure emissive doesn't "wash out" the tint.
                    homeRef.whiteMat.emissive.setHex(0x000000);
                    homeRef.whiteMat.emissiveIntensity = 0;

                    if (colorName === currentColorName) {
                        const playerColor = new THREE.Color(COLORS[colorName]);
                        homeRef.whiteMat.color.copy(baseWhite).lerp(playerColor, ACTIVE_TINT);
                    } else {
                        homeRef.whiteMat.color.copy(baseWhite);
                    }
                }
            });
        }
        function updateUI() {
            const colorName = PLAYER_ORDER[currentPlayerIndex];
            const dot = document.getElementById('player-dot');
            const text = document.getElementById('player-text');
            const colorHex = `#${COLORS[colorName].toString(16).padStart(6, '0')}`;
            dot.style.backgroundColor = colorHex;
            dot.style.color = colorHex;
            text.innerText = `${colorName} PLAYER`;
            text.style.color = colorHex;
            updateTurnIndicatorGlow();
            const shouldHighlightDice = (gameState === 'WAITING_FOR_ROLL' && playerConfig[colorName] === 'player');
            setDiceHighlight(0, shouldHighlightDice);
            setDiceHighlight(1, shouldHighlightDice);
        }
        function showMessage(msg) {
            const box = document.getElementById('msg-box');
            box.innerText = msg; box.style.opacity = 1; box.style.bottom = '60px';
            setTimeout(() => { box.style.opacity = 0; box.style.bottom = '40px'; }, 2000);
        }
        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // Handle Die Selection (Switching Focus)
            if (gameState === 'WAITING_FOR_MOVE') {
                const diceIntersects = raycaster.intersectObjects(dice, false);
                if (diceIntersects.length > 0) {
                    let dieObj = diceIntersects[0].object;
                    // Traverse up if needed (though dice meshes are usually flat in this code)
                    while (dieObj.parent && !dieObj.userData.isDice) { dieObj = dieObj.parent; }

                    if (dieObj.userData.isDice) {
                        const clickedIndex = dieObj.userData.index;
                        if (availableDiceIndices.includes(clickedIndex) && clickedIndex !== activeDieIndex) {
                            console.log('Switching active die to:', clickedIndex);
                            activeDieIndex = clickedIndex;
                            updateTurnState();
                            return;
                        }
                    }
                }
            }

            if (gameState === 'WAITING_FOR_ROLL') {
                const diceIntersects = raycaster.intersectObjects(dice, false);
                if (diceIntersects.length > 0) {
                    rollDice();
                    return;
                }
            }
            if (gameState !== 'WAITING_FOR_MOVE') return;
            const intersects = raycaster.intersectObjects(tokens, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && obj.userData.playerIndex === undefined) { obj = obj.parent; }

                if (obj.userData.playerIndex === currentPlayerIndex) {
                    // Check if this token is valid for the CURRENT ACTIVE DIE only
                    const val = currentTurnValues[activeDieIndex];
                    let isValid = false;

                    if (obj.userData.pathIndex === undefined || obj.userData.pathIndex < 0) {
                        if (val === 6) isValid = true;
                    } else {
                        // TODO: Overshoot check
                        isValid = true;
                    }

                    dbg('click token', {
                        activeDieIndex,
                        val,
                        isValid,
                        token: {
                            id: obj.userData.id,
                            pathIndex: obj.userData.pathIndex
                        }
                    });

                    if (isValid) {
                        moveToken(obj, val, activeDieIndex);
                    }
                }
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate(time) {
            requestAnimationFrame(animate);
            tweenGroup.update(time);
            if (controls) controls.update();
            tokens.forEach(t => { t.rotation.y += (t.userData.playerIndex === currentPlayerIndex && gameState === 'WAITING_FOR_MOVE') ? 0.05 : 0.01; });
            renderer.render(scene, camera);
        }
        function initSetupScreen() {
            createParticles();
            document.getElementById('begin-btn').addEventListener('click', transitionToGame);
        }
        function debugWalkPath(colorName) {
            const token = tokens.find(t => t.userData.colorName === colorName);
            const path = PATHS[colorName];
            if (!token || !path) {
                console.warn('Debug walk failed: Token or path not found');
                return;
            }

            // Drive steps off tween completion (not setTimeout) to avoid overlap/jank when frames drop.
            let stepIndex = 0;
            const stepDuration = 500;
            const groundY = TILE_HEIGHT / 2 + 0.08;
            token.userData.atHome = false;
            token.position.y = groundY;

            console.log(`Starting path walk for ${colorName}, ${path.length} steps`);

            function nextStep() {
                if (stepIndex >= path.length) return;

                const target = path[stepIndex];

                // Horizontal move (chain the next step on completion)
                new TWEEN.Tween(token.position, tweenGroup)
                    .to({ x: target.x, z: target.z }, stepDuration)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onComplete(() => {
                        stepIndex++;
                        nextStep();
                    })
                    .start();

                // Vertical hop (same duration as the horizontal move: up half, down half)
                new TWEEN.Tween(token.position, tweenGroup)
                    .to({ y: groundY + 0.5 }, stepDuration / 2)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .yoyo(true)
                    .repeat(1)
                    .start();
            }

            nextStep();
        }

        initSetupScreen();
    </script>
</body>

</html>