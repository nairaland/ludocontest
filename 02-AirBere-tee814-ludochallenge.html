<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ZLUDO</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #menu { position: absolute; width: 100%; height: 100%; background: radial-gradient(circle, #1a1a1a 0%, #000 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; text-align: center; }
        .setup-row { display: flex; gap: 20px; margin: 15px; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px; border: 1px solid #333; backdrop-filter: blur(5px); }
        .player-box { text-align: center; width: 130px; }
        select { padding: 8px; margin-top: 10px; width: 100%; border-radius: 5px; background: #222; color: white; border: 1px solid #555; cursor: pointer; }
        .btn-start { padding: 18px 70px; font-size: 24px; background: #27ae60; color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: bold; margin-top: 20px; box-shadow: 0 6px 0 #1e8449; transition: 0.2s; }
        .btn-start:active { transform: translateY(4px); box-shadow: 0 2px 0 #1e8449; }
        
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; flex-direction: column; justify-content: space-between; }
        .header { background: linear-gradient(to bottom, rgba(0,0,0,0.85), transparent); padding: 30px; color: white; display: flex; justify-content: space-between; align-items: center; }
        #instr { position: absolute; left: 20px; top: 130px; width: 240px; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 15px; color: #ddd; font-size: 0.85rem; border-left: 6px solid #f1c40f; pointer-events: none; line-height: 1.5; }
        
        #sacrifice-tracker { position: absolute; right: 20px; top: 130px; width: 200px; background: rgba(15,15,15,0.9); padding: 15px; border-radius: 15px; color: #fff; border: 1px solid #444; pointer-events: none; }
        #sac-title { text-align:center; font-size:0.8rem; color:#f1c40f; margin-bottom:12px; border-bottom:1px solid #444; padding-bottom:8px; font-weight: bold; letter-spacing: 2px; }
        .basket-row { display: none; justify-content: space-between; margin-bottom: 12px; font-weight: bold; font-size: 0.9rem; align-items: center; }
        .token-dots { display: flex; gap: 6px; }
        .dot { width: 14px; height: 14px; border-radius: 50%; border: 2px solid #f1c40f; display: none; box-shadow: 0 0 5px #f1c40f; }
        
        .footer { background: linear-gradient(to top, rgba(0,0,0,0.85), transparent); padding: 40px; display: flex; justify-content: flex-end; align-items: center; pointer-events: auto; }
        .controls-container { display: flex; align-items: center; gap: 30px; margin-right: 50px; }
        #msg { color: #f1c40f; font-size: 1.6rem; font-weight: bold; text-shadow: 2px 2px 8px #000; letter-spacing: 1px; }
        #p-label { font-size: 2.2rem; font-weight: 900; letter-spacing: 3px; }
        .dice-box { width: 80px; height: 80px; background: #111; border: 3px solid #fff; border-radius: 15px; display: flex; align-items: center; justify-content: center; font-size: 42px; font-weight: 900; color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.2); }
        #roll-btn { padding: 22px 55px; font-size: 24px; background: #d63031; color: white; border: none; border-radius: 18px; cursor: pointer; font-weight: bold; box-shadow: 0 8px 0 #8a1d1d; transition: 0.1s; }
        #roll-btn:disabled { background: #555; box-shadow: 0 4px 0 #333; cursor: default; opacity: 0.6; }
    </style>
</head>
<body>

<div id="menu">
    <h1 style="color:#f1c40f; margin-bottom: 30px; font-size: 5.5rem; letter-spacing: 12px; text-shadow: 0 0 25px rgba(241,196,15,0.5);">ZLUDO</h1>
    <div class="setup-row">
        <div class="player-box" style="color:#d63031"><b>RED</b><br><select id="p-red"><option value="human">Player 1</option><option value="cpu">CPU</option><option value="off">OFF</option></select></div>
        <div class="player-box" style="color:#27ae60"><b>GREEN</b><br><select id="p-green"><option value="cpu">CPU</option><option value="human">Player 2</option><option value="off">OFF</option></select></div>
        <div class="player-box" style="color:#f1c40f"><b>YELLOW</b><br><select id="p-yellow"><option value="off">OFF</option><option value="human">Player 3</option><option value="cpu">CPU</option></select></div>
        <div class="player-box" style="color:#0984e3"><b>BLUE</b><br><select id="p-blue"><option value="off">OFF</option><option value="human">Player 4</option><option value="cpu">CPU</option></select></div>
    </div>
    <div style="display: flex; gap: 30px;">
        <div style="margin: 15px;"><label style="font-weight: bold; color: #f1c40f;">DIFFICULTY: </label><select id="diff" style="width: 150px;"><option value="easy">Easy</option><option value="normal" selected>Normal</option><option value="pro">Professional</option></select></div>
        <div style="margin:15px;"><label style="color:#f1c40f; font-weight:bold;">SOUND: </label><select id="sound-toggle" style="width: 80px;"><option value="on">ON</option><option value="off">OFF</option></select></div>
    </div>
    <button class="btn-start" onclick="startGame()">START GAME</button>
</div>

<div id="ui">
    <div class="header">
        <div style="font-weight: bold; letter-spacing: 1px;">CURRENT TURN: <span id="p-label" style="color:#d63031">RED</span></div>
        <div id="msg">READY?</div>
    </div>
    <div id="instr">
        <b style="color: #f1c40f; font-size: 1rem;">LUDO RULES:</b><br><br>
        â€¢ Need a <b>6</b> to enter the board.<br>
        â€¢ Rolling a <b>6</b> grants an extra turn.<br>
        â€¢ <b>Capture:</b> Landing on an opponent sends them to the <b>Sacrifice Zone</b>.<br>
        â€¢ <b>Victory:</b> Get all 4 seeds to the center OR have them all sacrificed!
    </div>
    
    <div id="sacrifice-tracker">
        <div id="sac-title">SACRIFICE ZONE</div>
        <div class="basket-row" id="row-red">RED <div class="token-dots" id="sac-red"><div class="dot" style="background:#d63031"></div><div class="dot" style="background:#d63031"></div><div class="dot" style="background:#d63031"></div><div class="dot" style="background:#d63031"></div></div></div>
        <div class="basket-row" id="row-green">GREEN <div class="token-dots" id="sac-green"><div class="dot" style="background:#27ae60"></div><div class="dot" style="background:#27ae60"></div><div class="dot" style="background:#27ae60"></div><div class="dot" style="background:#27ae60"></div></div></div>
        <div class="basket-row" id="row-yellow">YELLOW <div class="token-dots" id="sac-yellow"><div class="dot" style="background:#f1c40f"></div><div class="dot" style="background:#f1c40f"></div><div class="dot" style="background:#f1c40f"></div><div class="dot" style="background:#f1c40f"></div></div></div>
        <div class="basket-row" id="row-blue">BLUE <div class="token-dots" id="sac-blue"><div class="dot" style="background:#0984e3"></div><div class="dot" style="background:#0984e3"></div><div class="dot" style="background:#0984e3"></div><div class="dot" style="background:#0984e3"></div></div></div>
    </div>

    <div class="footer">
        <div class="controls-container">
            <div class="dice-box" id="dice-val">?</div>
            <button id="roll-btn" onclick="rollDie()">ROLL DICE</button>
        </div>
    </div>
</div>

<script>
    /* AUDIO SYSTEM */
    let audioCtx = null; let soundEnabled = true;
    function playSound(f, t, d, v=0.15) {
        if(!soundEnabled || !audioCtx) return;
        try { if(audioCtx.state === 'suspended') audioCtx.resume(); const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime); g.gain.setValueAtTime(v, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + d); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + d); } catch(e) {}
    }
    const sfx = { 
        roll:()=>playSound(220,'triangle',0.1,0.1), 
        move:()=>playSound(440,'sine',0.08,0.05), 
        kill:()=>{playSound(150,'sawtooth',0.4,0.2);playSound(80,'sawtooth',0.4,0.2);}, 
        win:()=>[523,659,783,1046].forEach((f,i)=>setTimeout(()=>playSound(f,'square',1.0,0.05),i*150)) 
    };

    /* SCENE SETUP */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 18, 15); camera.lookAt(0, -1, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    const ambLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambLight);
    const pLight = new THREE.PointLight(0xffffff, 0.9, 100); pLight.position.set(5, 20, 10); scene.add(pLight);

    /* COLORS & MAP DATA */
    const C = { green: 0x27ae60, red: 0xd63031, yellow: 0xf1c40f, blue: 0x0984e3, white: 0xecf0f1, wood: 0x4e342e, center: 0x222222, fRed: 0xf1948a, fBlue: 0x85c1e9, fGreen: 0x82e0aa, fYellow: 0xf7dc6f };
    const MAP = [{x:6,z:13},{x:6,z:12},{x:6,z:11},{x:6,z:10},{x:6,z:9}, {x:5,z:8},{x:4,z:8},{x:3,z:8},{x:2,z:8},{x:1,z:8},{x:0,z:8},{x:0,z:7},{x:0,z:6},{x:1,z:6},{x:2,z:6},{x:3,z:6},{x:4,z:6},{x:5,z:6},{x:6,z:5},{x:6,z:4},{x:6,z:3},{x:6,z:2},{x:6,z:1},{x:6,z:0},{x:7,z:0},{x:8,z:0},{x:8,z:1},{x:8,z:2},{x:8,z:3},{x:8,z:4},{x:8,z:5},{x:9,z:6},{x:10,z:6},{x:11,z:6},{x:12,z:6},{x:13,z:6},{x:14,z:6},{x:14,z:7},{x:14,z:8},{x:13,z:8},{x:12,z:8},{x:11,z:8},{x:10,z:8},{x:9,z:8},{x:8,z:9},{x:8,z:10},{x:8,z:11},{x:8,z:12},{x:8,z:13},{x:8,z:14},{x:7,z:14},{x:6,z:14}];
    const HOME_PATHS = { red: [{x:7,z:13},{x:7,z:12},{x:7,z:11},{x:7,z:10},{x:7,z:9},{x:7,z:8}], green: [{x:1,z:7},{x:2,z:7},{x:3,z:7},{x:4,z:7},{x:5,z:7},{x:6,z:7}], yellow: [{x:7,z:1},{x:7,z:2},{x:7,z:3},{x:7,z:4},{x:7,z:5},{x:7,z:6}], blue: [{x:13,z:7},{x:12,z:7},{x:11,z:7},{x:10,z:7},{x:9,z:7},{x:8,z:7}] };
    const START_POSITIONS = { red: 0, green: 13, yellow: 26, blue: 39 };
    const ENTRY_POINTS = { red: 51, green: 12, yellow: 25, blue: 38 };
    const SAFE_SQUARES = [0, 8, 13, 21, 26, 34, 39, 47];

    /* BOARD GEOMETRY */
    const board = new THREE.Group(); scene.add(board);
    const base = new THREE.Mesh(new THREE.BoxGeometry(16, 0.8, 16), new THREE.MeshStandardMaterial({ color: C.wood })); base.position.y = -0.41; board.add(base);
    
    for(let x=0; x<15; x++) for(let z=0; z<15; z++) {
        let col = C.white, h = 0.15;
        if(x<6 && z<6) col = C.green; if(x>8 && z<6) col = C.yellow; if(x<6 && z>8) col = C.red; if(x>8 && z>8) col = C.blue;
        if(x===7 && z>=8 && z<=13) col=C.fRed; if(z===7 && x>=8 && x<=13) col=C.fBlue; if(z===7 && x>=1 && x<=6) col=C.fGreen; if(x===7 && z>=1 && z<=6) col=C.fYellow;
        if(x===7 && z===7) { col=C.center; h=0.22; }
        const tile = new THREE.Mesh(new THREE.BoxGeometry(0.94, h, 0.94), new THREE.MeshStandardMaterial({ color: col })); 
        tile.position.set(x-7, h/2, z-7); board.add(tile);
    }

    /* DICE ASSET */
    function getDiceFace(n) {
        const c = document.createElement('canvas'); c.width=128; c.height=128; const ctx = c.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,128,128); ctx.fillStyle='#fff';
        const dots = [[],[[64,64]],[[32,32],[96,96]],[[32,32],[64,64],[96,96]],[[32,32],[32,96],[96,32],[96,96]],[[32,32],[32,96],[64,64],[96,32],[96,96]],[[32,32],[32,64],[32,96],[96,32],[96,64],[96,96]]][n];
        dots.forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], 12, 0, Math.PI*2); ctx.fill(); });
        return new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(c) });
    }
    const die = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1.1, 1.1), [getDiceFace(4), getDiceFace(3), getDiceFace(1), getDiceFace(6), getDiceFace(2), getDiceFace(5)]); die.position.set(0, 0.6, 0); scene.add(die);

    /* STATE VARIABLES */
    let playerConfig = {}, currentTurn = 'red', lastRoll = 0, canMove = false, rolling = false, seeds = [], winning = false, difficulty = 'normal';
    const sacrificeCounts = { red: 0, green: 0, yellow: 0, blue: 0 };

    /* GAME LOGIC */
    function startGame() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        soundEnabled = document.getElementById('sound-toggle').value === 'on';
        playerConfig = { red: document.getElementById('p-red').value, green: document.getElementById('p-green').value, yellow: document.getElementById('p-yellow').value, blue: document.getElementById('p-blue').value };
        difficulty = document.getElementById('diff').value;
        const teams = ['red', 'green', 'yellow', 'blue'];
        teams.forEach(t => {
            if(playerConfig[t] !== 'off') {
                document.getElementById(`row-${t}`).style.display = 'flex';
                spawnSeeds(t === 'green' || t === 'red' ? 0 : 9, t === 'green' || t === 'yellow' ? 0 : 9, C[t], t);
            }
        });
        document.getElementById('menu').style.display = 'none'; document.getElementById('ui').style.display = 'flex';
        updateUIHeader(); checkCPUTurn();
    }

    function spawnSeeds(hx, hz, color, team) {
        for(let i=0; i<4; i++) {
            const s = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.38, 0.85, 32), new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.2 }));
            const ox = (i<2)?1.5:4.5, oz = (i%2===0)?1.5:4.5; s.position.set(hx+ox-7.5, 0.55, hz+oz-7.5);
            s.userData = { team, state: "HOME", posIdx: null, homePos: s.position.clone() }; scene.add(s); seeds.push(s);
        }
    }

    function rollDie() {
        if(rolling || canMove || winning) return;
        rolling = true; document.getElementById('roll-btn').disabled = true;
        
        // Rigging Logic based on Difficulty
        let r = Math.random();
        if(difficulty === 'easy') { lastRoll = (r < 0.28) ? 6 : Math.floor(Math.random()*5)+1; }
        else if(difficulty === 'pro') { lastRoll = (r < 0.12) ? 6 : Math.floor(Math.random()*5)+1; }
        else { lastRoll = Math.floor(Math.random() * 6) + 1; }

        let start = Date.now();
        function animate() {
            let elapsed = Date.now() - start;
            if(elapsed < 1100) { if(Math.random()>0.85) sfx.roll(); die.position.y = Math.max(0.6, 0.6 + Math.abs(Math.sin(elapsed*0.012))*3.5*(1-elapsed/1100)); die.rotation.x+=0.15; die.rotation.y+=0.15; requestAnimationFrame(animate); }
            else { 
                die.position.set(0,0.6,0); const rots = {1:[0,0,0], 6:[Math.PI,0,0], 2:[-Math.PI/2,0,0], 5:[Math.PI/2,0,0], 3:[0,0,Math.PI/2], 4:[0,0,-Math.PI/2]}; 
                die.rotation.set(...rots[lastRoll]); document.getElementById('dice-val').innerText = lastRoll; rolling = false; processTurn(); 
            }
        }
        animate();
    }

    function processTurn() {
        const valid = seeds.filter(s => s.userData.team === currentTurn && isValidMove(s, lastRoll));
        if(valid.length === 0) { 
            if(lastRoll === 6) { document.getElementById('msg').innerText = "NO MOVES! ROLL AGAIN"; setTimeout(() => { document.getElementById('roll-btn').disabled = false; checkCPUTurn(); }, 800); } 
            else { document.getElementById('msg').innerText = "NO MOVES!"; setTimeout(nextTurn, 1000); } 
        } else { 
            canMove = true; document.getElementById('msg').innerText = "SELECT SEED"; 
            if(playerConfig[currentTurn] === 'cpu') { const strategicSeed = getBestCPUMove(valid, lastRoll); setTimeout(() => handleMove(strategicSeed), 800); } 
        }
    }

    function getBestCPUMove(validSeeds, roll) {
        if(difficulty === 'easy') return validSeeds[Math.floor(Math.random()*validSeeds.length)];
        let best = validSeeds[0], maxW = -999;
        validSeeds.forEach(s => {
            let w = 0; const d = s.userData; 
            if(d.state === "HOME" && roll === 6) w += 100;
            let targetIdx = (d.state==="HOME") ? START_POSITIONS[d.team] : (d.posIdx + roll)%52;
            if(!SAFE_SQUARES.includes(targetIdx)) { if(seeds.find(o => o.userData.team!==d.team && o.userData.state==="ACTIVE" && o.userData.posIdx===targetIdx)) w += 500; }
            if(d.state === "HOME_PATH") w += 50;
            if(w > maxW) { maxW = w; best = s; }
        });
        return best;
    }

    function isValidMove(s, d) { 
        const state = s.userData.state;
        if(state === "FINISHED" || state === "SACRIFICED") return false; 
        if(state === "HOME") return d === 6; 
        if(state === "ACTIVE") { 
            let entry = ENTRY_POINTS[s.userData.team], dist = (s.userData.posIdx <= entry) ? (entry - s.userData.posIdx) : (52 - s.userData.posIdx + entry); 
            return d > dist ? (d - dist - 1) < 6 : true; 
        } 
        return state === "HOME_PATH" && (s.userData.posIdx + d) <= 5; 
    }

    function handleMove(seed) {
        if(!canMove) return;
        canMove = false; sfx.move(); let killed = false, d = seed.userData;
        seed.scale.set(1, 1, 1);
        
        if(d.state === "HOME") { d.state = "ACTIVE"; d.posIdx = START_POSITIONS[d.team]; }
        else if(d.state === "ACTIVE") { 
            let entry = ENTRY_POINTS[d.team], dist = (d.posIdx <= entry) ? (entry - d.posIdx) : (52 - d.posIdx + entry); 
            if(lastRoll > dist) { d.posIdx = lastRoll - dist - 1; d.state = "HOME_PATH"; } else d.posIdx = (d.posIdx + lastRoll) % 52; 
        }
        else d.posIdx += lastRoll;

        if(d.state === "HOME_PATH" && d.posIdx === 5) { d.state = "FINISHED"; seed.position.set(0, -20, 0); checkWin(d.team); }
        else {
            const p = (d.state === "HOME_PATH") ? HOME_PATHS[d.team][d.posIdx] : MAP[d.posIdx];
            seed.position.set(p.x - 7, 0.55, p.z - 7);
            if(d.state === "ACTIVE" && !SAFE_SQUARES.includes(d.posIdx)) {
                seeds.forEach(o => { 
                    if(o !== seed && o.userData.team !== d.team && o.userData.state === "ACTIVE" && o.userData.posIdx === d.posIdx) { 
                        o.userData.state = "HOME"; o.userData.posIdx = null; o.position.copy(o.userData.homePos); killed = true; 
                    } 
                });
                if(killed) { sfx.kill(); d.state = "SACRIFICED"; seed.position.set(0, -20, 0); updateBasket(d.team); checkWin(d.team); }
            }
        }
        if(!winning) { if(killed || lastRoll === 6) { document.getElementById('msg').innerText = "BONUS TURN!"; setTimeout(() => { document.getElementById('roll-btn').disabled = false; checkCPUTurn(); }, 600); } else setTimeout(nextTurn, 500); }
    }

    function updateBasket(t) { sacrificeCounts[t]++; const dots = document.getElementById(`sac-${t}`).getElementsByClassName('dot'); for(let i=0; i<sacrificeCounts[t]; i++) if(dots[i]) dots[i].style.display = 'block'; }
    function checkWin(t) { if(seeds.filter(s => s.userData.team === t && (s.userData.state === "FINISHED" || s.userData.state === "SACRIFICED")).length === 4) { winning = true; sfx.win(); document.getElementById('msg').innerText = "ðŸ† WINNER!"; setTimeout(() => { alert(t.toUpperCase() + " WINS!"); location.reload(); }, 2000); } }
    
    function nextTurn() { 
        if(winning) return; 
        const turns = ['red', 'green', 'yellow', 'blue']; 
        let nextIdx = (turns.indexOf(currentTurn) + 1) % 4;
        currentTurn = turns[nextIdx];
        if(playerConfig[currentTurn] === 'off') return nextTurn(); 
        document.getElementById('roll-btn').disabled = false;
        updateUIHeader(); checkCPUTurn(); 
    }

    function updateUIHeader() {
        const label = document.getElementById('p-label');
        label.innerText = currentTurn.toUpperCase(); 
        label.style.color = "#" + C[currentTurn].toString(16).padStart(6, '0'); 
    }
    
    function checkCPUTurn() { if(playerConfig[currentTurn] === 'cpu' && !winning && !rolling) setTimeout(rollDie, 800); }

    window.addEventListener('mousedown', (e) => {
        if(!canMove || playerConfig[currentTurn] === 'cpu') return;
        const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
        const ray = new THREE.Raycaster(); ray.setFromCamera(mouse, camera);
        const hits = ray.intersectObjects(seeds);
        if(hits.length > 0 && hits[0].object.userData.team === currentTurn && isValidMove(hits[0].object, lastRoll)) handleMove(hits[0].object);
    });

    function draw() { 
        requestAnimationFrame(draw); 
        if (canMove) {
            const time = Date.now() * 0.008;
            seeds.forEach(s => {
                if (s.userData.team === currentTurn && isValidMove(s, lastRoll)) {
                    const scl = 1 + Math.sin(time) * 0.12;
                    s.scale.set(scl, scl, scl);
                } else s.scale.set(1, 1, 1);
            });
        }
        renderer.render(scene, camera); 
    }
    draw();
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
