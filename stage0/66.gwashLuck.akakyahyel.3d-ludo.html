
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>3D Ludo â€“ Enhanced</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  font-family: system-ui, Arial;
  background: #f1f5f9;
}
#ui {
  position: fixed;
  left: 12px;
  top: 12px;
  width: 340px;
  background: rgba(255,255,255,.95);
  border-radius: 14px;
  padding: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
  z-index: 10;
}
button {
  border: 0;
  border-radius: 10px;
  padding: 10px 12px;
  cursor: pointer;
  font-weight: 700;
}
#roll { background:#4f46e5; color:#fff; }
#reset { background:#e5e7eb; }
#dice { font-size: 36px; font-weight: 900; }
.player { font-weight: 700; }
.active { text-shadow: 0 0 8px currentColor; }
#camera { margin-top: 8px; }
#camera button { width: 48%; margin-bottom: 6px; }
#help { display:none; font-size:13px; margin-top:8px; }
</style>
</head>

<body>

<div id="ui">
  <h2>ðŸŽ² 3D Ludo</h2>
  <p id="turn"></p>
  <p>Dice: <span id="dice">â€“</span></p>
  <button id="roll">Roll Dice</button>
  <button id="reset">Reset</button>
  <button id="toggleHelp">Instructions</button>

  <div id="camera">
    <button onclick="camLeft()">â¬… Rotate</button>
    <button onclick="camRight()">âž¡ Rotate</button>
    <button onclick="camUp()">â¬† Zoom</button>
    <button onclick="camDown()">â¬‡ Zoom</button>
  </div>

  <div id="help">
    <b>Rules:</b>
    <ul>
      <li>4 players: Red, Blue, Green, Yellow</li>
      <li>Roll dice to move forward</li>
      <li>Landing on opponent sends them to Start</li>
      <li>First to reach Home wins</li>
    </ul>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf1f5f9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
let camAngle=0, camRadius=14, camHeight=10;

function updateCamera(){
  camera.position.set(Math.sin(camAngle)*camRadius, camHeight, Math.cos(camAngle)*camRadius);
  camera.lookAt(0,0,0);
}
updateCamera();

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,.7));
const sun = new THREE.DirectionalLight(0xffffff,.6);
sun.position.set(10,20,10);
scene.add(sun);

/* ================= BOARD ================= */
const board = new THREE.Group();
scene.add(board);
const tileSize = 1;

/* base */
for(let x=-4;x<=4;x++){
  for(let z=-4;z<=4;z++){
    const bg = new THREE.Mesh(
      new THREE.BoxGeometry(tileSize,.15,tileSize),
      new THREE.MeshStandardMaterial({color:0xe5e7eb})
    );
    bg.position.set(x,-0.01,z);
    board.add(bg);
  }
}

/* ================= TRACK ================= */
const track=[];
function tile(x,z){
  const m=new THREE.Mesh(
    new THREE.BoxGeometry(tileSize,.25,tileSize),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  m.position.set(x,0,z);
  board.add(m);
  track.push(m.position.clone());
}

for(let i=-4;i<=4;i++) tile(i,-4);
for(let i=-3;i<=4;i++) tile(4,i);
for(let i=3;i>=-4;i--) tile(i,4);
for(let i=3;i>=-3;i--) tile(-4,i);

const homeIndex=track.length-1;

/* ================= HOME STRETCHES (VISUAL) ================= */
const homeColors=[0xef4444,0x3b82f6,0x22c55e,0xeab308];
const stretches=[
  [[-3,-3],[-2,-3],[-1,-3]],
  [[3,-3],[3,-2],[3,-1]],
  [[3,3],[2,3],[1,3]],
  [[-3,3],[-3,2],[-3,1]],
];

stretches.forEach((cells,i)=>{
  cells.forEach(([x,z])=>{
    const t=new THREE.Mesh(
      new THREE.BoxGeometry(tileSize,.22,tileSize),
      new THREE.MeshStandardMaterial({color:homeColors[i]})
    );
    t.position.set(x,0.02,z);
    board.add(t);
  });
});

/* ================= HOME LABEL ================= */
const canvas=document.createElement('canvas');
canvas.width=256;canvas.height=128;
const ctx=canvas.getContext('2d');
ctx.fillStyle="#fff";ctx.fillRect(0,0,256,128);
ctx.fillStyle="#111";ctx.font="bold 40px Arial";
ctx.textAlign="center";ctx.textBaseline="middle";
ctx.fillText("HOME",128,64);
const label=new THREE.Sprite(
  new THREE.SpriteMaterial({map:new THREE.CanvasTexture(canvas),transparent:true})
);
label.scale.set(1.4,0.7,1);
label.position.copy(track[0]).add(new THREE.Vector3(0,1.9,0));
board.add(label);

/* ================= PLAYERS ================= */
const colors=[
  {name:'Red',c:0xef4444},
  {name:'Blue',c:0x3b82f6},
  {name:'Green',c:0x22c55e},
  {name:'Yellow',c:0xeab308}
];

const offsets=[
  new THREE.Vector3(-.25,0,-.25),
  new THREE.Vector3(.25,0,-.25),
  new THREE.Vector3(-.25,0,.25),
  new THREE.Vector3(.25,0,.25),
];

const players=colors.map((p,i)=>{
  const m=new THREE.Mesh(
    new THREE.SphereGeometry(.35,24,24),
    new THREE.MeshStandardMaterial({color:p.c, emissive:p.c, emissiveIntensity:.15})
  );
  m.position.copy(track[0]).add(offsets[i]).add(new THREE.Vector3(0,.5,0));
  scene.add(m);
  return {name:p.name,mesh:m,index:0};
});

let current=0,busy=false,gameOver=false;

/* ================= 3D DICE (VISUAL ONLY) ================= */
/* ================= 3D DICE (HIGH VISIBILITY) ================= */
const diceGeometry = new THREE.BoxGeometry(.9, .9, .9);

const diceMaterial = new THREE.MeshStandardMaterial({
  color: 0xf8fafc,          // off-white (stands out from board)
  emissive: 0x111111,       // subtle glow
  emissiveIntensity: 0.6,
  roughness: 0.25,
  metalness: 0.1
});

const diceMesh = new THREE.Mesh(diceGeometry, diceMaterial);
diceMesh.position.set(0, 1.8, 0); // slightly higher for clarity
scene.add(diceMesh);

/* --- Dice outline (edges) --- */
const diceEdges = new THREE.EdgesGeometry(diceGeometry);
const diceOutline = new THREE.LineSegments(
  diceEdges,
  new THREE.LineBasicMaterial({
    color: 0x111827,        // dark outline
    linewidth: 2
  })
);
diceMesh.add(diceOutline);


/* ================= UI ================= */
const diceEl=document.getElementById('dice');
const turnEl=document.getElementById('turn');

function updateTurn(){
  turnEl.innerHTML=`Turn: <span class="player active" style="color:${colors[current].c}">${players[current].name}</span>`;
}
updateTurn();

/* ================= MOVE ================= */
function moveAnimated(p,steps){
  let s=0;busy=true;
  (function next(){
    if(s>=steps||p.index>=homeIndex){busy=false;return;}
    p.index++;
    const pos=track[p.index];
    p.mesh.position.set(pos.x,.5,pos.z);
    s++;setTimeout(next,300);
  })();
}

/* ================= DICE (SPIN ADDED, LOGIC UNCHANGED) ================= */
function rollDiceAnim(cb){
  let c=10;
  const i=setInterval(()=>{
    const v=Math.floor(Math.random()*6)+1;
    diceMesh.rotation.x+=0.6;
    diceMesh.rotation.y+=0.6;
    diceEl.textContent=v;
    if(--c===0){
      clearInterval(i);
      cb(v);
    }
  },80);
}

/* ================= GAME ================= */
document.getElementById('roll').onclick=()=>{
  if(busy||gameOver)return;
  rollDiceAnim(r=>{
    const p=players[current];
    moveAnimated(p,r);
    setTimeout(()=>{
      players.forEach((o,i)=>{
        if(i!==current&&o.index===p.index&&p.index!==0){
          o.index=0;
          o.mesh.position.copy(track[0]).add(offsets[i]).add(new THREE.Vector3(0,.5,0));
        }
      });
      if(p.index>=homeIndex){
        turnEl.textContent=p.name+" wins!";
        gameOver=true;return;
      }
      current=(current+1)%players.length;
      updateTurn();
    },r*320);
  });
};

document.getElementById('reset').onclick=()=>location.reload();
document.getElementById('toggleHelp').onclick=()=>{
  const h=document.getElementById('help');
  h.style.display=h.style.display==='block'?'none':'block';
};

/* ================= CAMERA ================= */
function camLeft(){camAngle-=.1;updateCamera();}
function camRight(){camAngle+=.1;updateCamera();}
function camUp(){camRadius=Math.max(6,camRadius-1);updateCamera();}
function camDown(){camRadius=Math.min(20,camRadius+1);updateCamera();}

/* ================= LOOP ================= */
(function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
})();
</script>
</body>
</html>
 