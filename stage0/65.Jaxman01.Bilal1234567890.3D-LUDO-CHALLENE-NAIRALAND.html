<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ludo Challenge - Classic Grid</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #1a1a1a; }
        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }
        .hud-panel { pointer-events: auto; padding: 20px; color: white; text-shadow: 1px 1px 2px black; }
        #controls { text-align: center; margin-bottom: 30px; }
        button {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
            border: none; border-radius: 8px; padding: 15px 35px;
            font-size: 1.5rem; color: white; cursor: pointer;
            box-shadow: 0 4px #c66900; transition: transform 0.1s;
            font-weight: bold;
        }
        button:disabled { background: #555; box-shadow: 0 4px #222; cursor: not-allowed; }
        button:active:not(:disabled) { transform: translateY(4px); box-shadow: 0 0 #c66900; }
        #dice-result { 
            font-size: 3rem; font-weight: bold; margin-left: 20px; 
            vertical-align: middle; visibility: hidden; background: rgba(0,0,0,0.5);
            padding: 5px 15px; border-radius: 10px;
        }
        #status { font-size: 1.2rem; margin-top: 10px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "tween": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.0/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <div id="game-ui">
        <div class="hud-panel">
            <h2>3D Ludo Challenge</h2>
            <div id="status">Player RED's Turn</div>
        </div>
        <div class="hud-panel" id="controls">
            <button id="roll-btn">ROLL DICE</button>
            <span id="dice-result">?</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as TWEEN from 'tween';

        // ===============================================
        // *** 1. GAME STATE AND PATH DATA ***
        // ===============================================
        
        const pawns = [];
        const CELL_SIZE = 0.8;

        // The sequence of grid coordinates [row, col] for the main circular path
        const MAP_PATH = [
            [6,1],[6,2],[6,3],[6,4],[6,5],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],[0,7],[0,8], // Red to Green
            [1,8],[2,8],[3,8],[4,8],[5,8],[6,9],[6,10],[6,11],[6,12],[6,13],[6,14],[7,14],[8,14], // Green to Yellow
            [8,13],[8,12],[8,11],[8,10],[8,9],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],[14,7],[14,6], // Yellow to Blue
            [13,6],[12,6],[11,6],[10,6],[9,6],[8,5],[8,4],[8,3],[8,2],[8,1],[8,0],[7,0],[6,0] // Blue back to Red
        ];

        const gameState = {
            turn: 'RED',
            diceValue: 0,
            players: {
                RED:    { color: 0xff4136, startIdx: 0 },
                GREEN:  { color: 0x2ecc40, startIdx: 13 },
                YELLOW: { color: 0xffdc00, startIdx: 26 },
                BLUE:   { color: 0x0074d9, startIdx: 39 }
            },
            isRolling: false,
            waitingForMove: false
        };
        
        class LudoGameManager {
            constructor(state) {
                this.state = state;
                this.order = ['RED', 'GREEN', 'YELLOW', 'BLUE'];
            }
            roll() { 
                const result = Math.floor(Math.random() * 6) + 1;
                this.state.diceValue = result;
                return result;
            }
            switchTurn() { 
                if (this.state.diceValue !== 6) {
                    const currentIndex = this.order.indexOf(this.state.turn);
                    const nextIndex = (currentIndex + 1) % this.order.length;
                    this.state.turn = this.order[nextIndex];
                }
                document.getElementById('status').innerText = `Player ${this.state.turn}'s Turn`;
                document.getElementById('roll-btn').disabled = false;
                this.state.waitingForMove = false;
            }
        }
        
        const gameManager = new LudoGameManager(gameState);

        // --- THREE.JS SETUP ---
        let scene, camera, renderer, controls, raycaster, mouse, diceMesh;
        const GRID_SIZE = 15;
        const COLORS = { red: 0xff4136, green: 0x2ecc40, blue: 0x0074d9, yellow: 0xffdc00, white: 0xffffff, border: 0x333333 };

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            createBoard();
            createDice();
            createPawns();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('click', onMouseClick);
            document.getElementById('roll-btn').addEventListener('click', rollDice);
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function gridToWorld(r, c) {
            return { x: (c - 7) * CELL_SIZE, z: (r - 7) * CELL_SIZE };
        }

        function createBoard() {
            const baseGeo = new THREE.BoxGeometry((GRID_SIZE * CELL_SIZE) + 0.4, 0.1, (GRID_SIZE * CELL_SIZE) + 0.4);
            const base = new THREE.Mesh(baseGeo, new THREE.MeshStandardMaterial({ color: COLORS.border }));
            base.position.y = -0.05;
            scene.add(base);

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let color = COLORS.white;
                    if (r < 6 && c < 6) color = COLORS.red;
                    else if (r < 6 && c > 8) color = COLORS.green;
                    else if (r > 8 && c > 8) color = COLORS.yellow;
                    else if (r > 8 && c < 6) color = COLORS.blue;
                    else if (r === 7 && c > 0 && c < 7) color = COLORS.red;
                    else if (c === 7 && r > 0 && r < 7) color = COLORS.green;
                    else if (r === 7 && c > 7 && c < 14) color = COLORS.yellow;
                    else if (c === 7 && r > 7 && r < 14) color = COLORS.blue;

                    const pos = gridToWorld(r, c);
                    const cell = new THREE.Mesh(new THREE.BoxGeometry(CELL_SIZE * 0.92, 0.2, CELL_SIZE * 0.92), new THREE.MeshStandardMaterial({ color: color }));
                    cell.position.set(pos.x, 0.1, pos.z);
                    scene.add(cell);
                }
            }
        }

        function createPawns() {
            const yardCenters = [
                { color: 'RED', x: -4, z: -4 }, { color: 'GREEN', x: 4, z: -4 },
                { color: 'YELLOW', x: 4, z: 4 }, { color: 'BLUE', x: -4, z: 4 }
            ];

            yardCenters.forEach(yard => {
                for (let i = 0; i < 4; i++) {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({ color: gameState.players[yard.color].color });
                    const body = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.7, 16), mat);
                    body.position.y = 0.35;
                    group.add(body);
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), mat);
                    head.position.y = 0.7;
                    group.add(head);

                    const ox = (i % 2 === 0 ? -0.6 : 0.6);
                    const oz = (i < 2 ? -0.6 : 0.6);
                    group.position.set(yard.x + ox, 0.2, yard.z + oz);
                    
                    group.userData = { 
                        color: yard.color, 
                        inYard: true, 
                        pathIdx: -1,
                        homePos: group.position.clone() 
                    };
                    scene.add(group);
                    pawns.push(group);
                }
            });
        }

        function createDice() {
            const mats = [1,2,3,4,5,6].map(i => new THREE.MeshStandardMaterial({ map: createDiceFaceTexture(i) }));
            diceMesh = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), mats);
            diceMesh.position.set(0, 5, 0);
            scene.add(diceMesh);
        }

        function createDiceFaceTexture(dotCount) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'black';
            const dots = { 1:[[64,64]], 2:[[32,32],[96,96]], 3:[[32,32],[64,64],[96,96]], 4:[[32,32],[96,32],[32,96],[96,96]], 5:[[32,32],[96,32],[64,64],[32,96],[96,96]], 6:[[32,32],[96,32],[32,64],[96,64],[32,96],[96,96]] };
            dots[dotCount].forEach(d => { ctx.beginPath(); ctx.arc(d[0], d[1], 10, 0, Math.PI*2); ctx.fill(); });
            return new THREE.CanvasTexture(canvas);
        }

        async function rollDice() {
            if (gameState.isRolling || gameState.waitingForMove) return;
            gameState.isRolling = true;
            const result = gameManager.roll();
            diceMesh.position.y = 4;
            await new Promise(res => {
                new TWEEN.Tween(diceMesh.position).to({ y: 0.5 }, 600).easing(TWEEN.Easing.Bounce.Out).start();
                new TWEEN.Tween(diceMesh.rotation).to({ x: Math.random()*12, y: Math.random()*12 }, 600).onComplete(res).start();
            });
            const resSpan = document.getElementById('dice-result');
            resSpan.innerText = result; resSpan.style.visibility = 'visible';
            gameState.isRolling = false; gameState.waitingForMove = true;
            document.getElementById('status').innerText = `Select a ${gameState.turn} pawn`;
        }

        function onMouseClick(event) {
            if (!gameState.waitingForMove) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pawns, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && obj.type !== 'Group') obj = obj.parent;
                if (obj.userData.color === gameState.turn) handleMove(obj);
            }
        }

        function handleMove(pawn) {
            const diceValue = gameState.diceValue;
            const startIdx = gameState.players[pawn.userData.color].startIdx;

            if (pawn.userData.inYard) {
                if (diceValue === 6) {
                    pawn.userData.inYard = false;
                    pawn.userData.pathIdx = startIdx;
                    const pos = gridToWorld(MAP_PATH[startIdx][0], MAP_PATH[startIdx][1]);
                    new TWEEN.Tween(pawn.position).to({ x: pos.x, z: pos.z }, 500).easing(TWEEN.Easing.Back.Out)
                        .onComplete(() => gameManager.switchTurn()).start();
                } else {
                    document.getElementById('status').innerText = "Must roll 6 to exit Yard!";
                    setTimeout(() => gameManager.switchTurn(), 800);
                }
            } else {
                moveStepByStep(pawn, diceValue);
            }
        }

        function moveStepByStep(pawn, stepsLeft) {
            if (stepsLeft <= 0) {
                gameManager.switchTurn();
                return;
            }

            pawn.userData.pathIdx = (pawn.userData.pathIdx + 1) % MAP_PATH.length;
            const nextCoord = MAP_PATH[pawn.userData.pathIdx];
            const worldPos = gridToWorld(nextCoord[0], nextCoord[1]);

            // Jump animation
            new TWEEN.Tween(pawn.position)
                .to({ x: worldPos.x, y: 1.0, z: worldPos.z }, 150)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    new TWEEN.Tween(pawn.position)
                        .to({ y: 0.2 }, 150)
                        .easing(TWEEN.Easing.Quadratic.In)
                        .onComplete(() => moveStepByStep(pawn, stepsLeft - 1))
                        .start();
                }).start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>